{
  "hash": "319b3725eaca6df8ee7ffa0964e241ba",
  "result": {
    "markdown": "---\nnumber: 12\ntitle: \"STL and Vectors\"\ntextbook: \"Gaddis (Ch. 16.5)\"\n# draft: true\n---\n\n#   STL {background-image=\"images/STL/circle_template.jpg\"}\n\n---\n\n##  The C++ Standard Template Library\n\n- What is STL?\n- Why use STL?\n- Overview of STL Features and Concepts\n- Containers\n- Iterators\n- Algorithms\n- References for more information on STL\n\n---\n\n##  What is STL?\n\n> \"The Standard Template Library provides a set of well structured\n> generic C++ components that work together in a seamless way.\"\n>\n> \\- Alexander Stepanov & Meng Lee,\n>    _The Standard Template Library_\n\n- Designed to provide a common, familiar interface.\n- Designed to meet specific performance/complexity goals.\n- Keeps programmers from \"re-inventing the wheel\".\n\n---\n\n##  Why Use STL?\n\n- Reuse: \"Write less, do more\"\n    - STL hides complex, error-prone details.\n    - Allows you to focus on the problem.\n    - Type-safe compatibility between components.\n- Flexibility\n    - Iterators decouple algorithms from containers.\n    - Unanticipated combinations easily supported.\n- Efficiency\n    - Templates avoid virtual function overhead.\n    - Strict attention to time and/or space complexity of algorithms.\n\n\n---\n\n## STL Features and Concepts\n\n- Containers\n    - Sequence: `vector`, `list`, `deque`\n    - Associative: `set`, `multiset`, `map`, `multimap`\n- Adapters: `stack`, `queue`, `priority_queue`\n- Iterators\n    - Used to access elements in containers\n    - Input, output, forward, bidirectional, & random access\n    - Each container declares a trait for the type of iterator it provides\n- Generic Algorithms\n    - Mutating, non-mutating, sorting, numeric\n\n---\n\n## STL Containers\n\n- STL Containers are _Abstract Data Types_ (ADTs)\n- All containers are parameterized by the type(s) they contain.\n- All declare traits :\n    - e.g. `iterator`, `const_iterator`, `value_type`, etc.\n\n---\n\n## Container Types\n\n- Sequence\n    - Provide efficient linear access to data\n    - Element order is not related to value\n    - Think arrays and linked lists\n- Associative\n    - Provide efficient access to data stored as a key/value pair\n    - Keys can be ordered by `operator<`\n    - Implemented as balanced binary trees\n- Adapters\n    - Provide alternative ways to access sequence and associative containers\n    - e.g. `stack`, `queue`, `priority_queue`\n\n---\n\n# Sequence Container: `std::vector`\n\nSTLâ€™s `std::vector` is essentially a dynamic array.\n\n- Grows and shrinks at the end.\n- Supports `push_back()` and `pop_back()` sequential (end) access.\n- Optimized for random access using array index operator. (`[]`)\n- Supports random access iterators\n    - An _iterator_ is an object used to access individual items in a container, or to move (i.e. \"iterate\") through the container.\n- `vector`s know their own size!\n\n\n---\n\n## `std::vector` Example\n\n``` cpp\nusing std::vector;\nusing std::string;\n// [...]\nvector<string> v;                   // create vector\n\nv.push_back(\"The number is 10\");    // push some values\nv.push_back(\"The number is 20\");    // into it...\nv.push_back(\"The number is 30\");\n\ncout << \"Loop by index:\" << endl;\n\nfor(vector<string>::size_type i=0;  // size type is unsigned\n    i < v.size();                   // vector knows its size!\n    i++){                           // print values by\n   cout << v[i] << endl;            // indexing the\n}                                   // vector like an array\n```\n\n::: {.callout-tip appearance=\"minimal\"}\n**HINT:** Use `v.at(i)` instead of `v[i]` to enable bounds-checking!\n:::\n\n---\n\n## `std::vector` Example 2\n\n``` cpp\nstd::vector<std::string> v;         // create vector\n\nv.push_back(\"The number is 10\");    // push some values\nv.push_back(\"The number is 20\");    // into it...\nv.push_back(\"The number is 30\");\n\ncout << \"Loop by range using iterators:\" << endl;\n\nfor(auto it = v.begin();            // iterator\n    it != v.end();                  // runs from begin()\n    ++it)                           // to end(), one at a time\n{                                   // and is\n   cout << *it << endl;             // dereferenced to\n}                                   // print the value\n```\n\n* Think of an iterator as an arrow pointing to a value in the container.\n* The _dereference operator_ (`*`) is used to \"follow the arrow\" to get the value an iterator is pointing to.\n\n---\n\n## `std::vector` Example 3\n\n``` cpp\nstd::vector<std::string> v;         // create vector\n\nv.push_back(\"The number is 10\");    // push some values\nv.push_back(\"The number is 20\");    // into it...\nv.push_back(\"The number is 30\");\n\ncout << \"Loop by range-based `for`:\" << endl;\n\nfor( auto item : v ){               // for each item in v\n   cout << item << endl;            // print the item\n}\n```\n\n---\n\n## `std::vector` Example 4\n\n``` cpp\nauto v = std::vector<std::string>{3};    // pre-size to 3\n\nint  n = 1;\nfor( auto& item : v){                    // each item (by ref.)\n    item = std::string{\"The number is \"} // generate message\n         + std::to_string(10 * n++);     // and store in item\n}\n\ncout << \"Loop by range:\" << endl;\n\nfor( auto item : v ){                    // for each item\n   cout << item << endl;                 // print the item\n}\n```\n\n_`std::to_string()` is contained in `<std::string>`_\n\n\n---\n\n## Iterators\n\nIterators are a generalization of pointers.\n\n- Used to access information in containers, regardless of the internal layout\n- Four types:\n    - Forward (uses `++`)\n    - Bidirectional (uses `++` and `--`)\n    - Random-access (behave like normal pointers)\n    - Input (can be used with input streams)\n    - Output (can be used with output streams)\n\n---\n\n\n## Iterator Example\n\n``` cpp\nstd::vector<int> scores{3};  // pre-size to 3\n\nscores.at(0) = 88;\nscores.at(1) = 92;\nscores.at(2) = 76;\n\nfor(auto it = scores.begin(); it != grade_list.end(); it++){\n    std::cout << *it << '\\t';\n}\nstd::cout << '\\n';\n```\n\n---\n\n## `vector` Modifiers\n\nThese are algorithms that `vector`s know how to apply to themselves:\n\n    clear()     : clears all contents (empties the container)\n    erase()     : erase one element, given an iterator to it\n    insert()    : inserts element before a position (given an iterator)\n    pop_back()  : removes the last element\n    push_back() : adds a new element at the end\n    resize()    : changes the size of the vector\n    [...] There are others not shown here\n\n---\n\n### `clear()`\n\nEmpties the vector.\n\n```cpp\nstd::vector<int> v{4,8,15,16,23,42,108};\n\nv.clear();\n\nstd::cout << v.size();\n// 0\n```\n\n---\n\n### `erase(it_target)`\n\nErases the element pointed to by the iterator `it_target`.\n\n```cpp\nstd::vector<int> v{4,8,15,16,23,42,108};\nstd::vector<int>::iterator target = v.begin();\n                  // Move target to the third element:\ntarget += 2;      // by skipping the first two\n\nv.erase(target);  // erases the third element\n\nfor( auto value : v ){\n    std::cout << value << '\\t';\n}\n```\n\n```{output}\n    4  8  16  23  42  108\n```\n\n---\n\n### `insert( it_position, value )`\n\nInserts `value` at the position pointed to by the iterator `it_position`, shifting current values $\\ge$ `it_position` to the right.\n\n```cpp\nstd::vector<int> v{4,8,16,23,42,108};\nstd::vector<int>::iterator pos = v.begin();\n                   // Move pos to the third element:\npos += 2;          // by skipping the first two\n\nv.insert(pos, 15); // insert before 16\n\nfor( auto value : v ){\n    std::cout << value << '\\t';\n}\n// 4  8  15  16  23  42  108\n```\n\n---\n\n\n### `pop_back(  )`\n\nRemoves the last value in the vector.\n\n```cpp\nstd::vector<int> v{4,8,15,16,23,42,108};\n\nv.pop_back();\n\nfor( auto value : v ){\n    std::cout << value << '\\t';\n}\n// 4  8  15  16  23  42\n```\n\n---\n\n### `push_back(  )`\n\nAdds a new value at the end.\n\n```cpp\nstd::vector<int> v{4,8,15,16,23,42};\n\nv.push_back(108);\n\nfor( auto value : v ){\n    std::cout << value << '\\t';\n}\n// 4  8  15  16  23  42  108\n```\n\n---\n\n### `resize(  )`\n\nChanges size of the vector.  Use this to pre-allocate:\n\n```cpp\nstd::vector<int> v;\nv.resize(10);\n\nfor(int i = 0; i < v.size(); ++i){\n    v.at(i) = (i+1);\n}\n\nfor( auto value : v ){\n    std::cout << value << '\\t';\n}\n// 1  2  3  4  5  6  7  8  9  10\n```\n\n---\n\n## Passing `vector`s to functions\n\n`std::vector` is an _object type_, meaning that it is passed **by value** by default!  This means that even though it \"looks and feels\" like an array, the argument-to-parameter communication mechanism is quite different.\n\nLet's look at an example...\n\n---\n\n**Example: Vectors as parameters VS arrays as parameters**\n\nFirst, the \"main\" part of the program, which will utilize two overloaded functions:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nvoid example(int a[], int size);\nvoid example(std::vector<int> v);\nvoid print_all(int a[], int size);\nvoid print_all(std::vector<int> v);\n\nint main(){\n    int              a[]{1, 2, 3, 4, 5};\n    std::vector<int> v  {1, 2, 3, 4, 5};\n\n    example(a, 5);\n    example(v);\n\n    print_all(a, 5);\n    print_all(v);\n\n    return 0;\n}\n```\n\n---\n\n**Example: Vectors as parameters VS arrays as parameters**\n\n```cpp\nvoid example(int a[], int size){\n    for(int i = 0; i < size; ++i)\n        a[i] *= 2;\n}\n\nvoid example(std::vector<int> v){\n    for(std::vector<int>::size_type i = 0; i < v.size(); ++i)\n        v[i] *= 2;\n}\n\nvoid print_all(int a[], int size){\n    for (int i = 0; i < size; ++i)\n        std::cout << a[i] << '\\t';\n    std::cout << '\\n';\n}\n\nvoid print_all(std::vector<int> v){\n    for(auto value : v)\n        std::cout << value << '\\t';\n    std::cout << '\\n';\n}\n```\n\n---\n\n**Example: Vectors as parameters VS arrays as parameters**\n\nHere is the relevant part of the main program again...\n\n**_What output do you expect from this code?_**\n\n```cpp\nint main(){\n    int              a[]{1, 2, 3, 4, 5};\n    std::vector<int> v  {1, 2, 3, 4, 5};\n\n    example(a, 5);\n    example(v);\n\n    print_all(a, 5);\n    print_all(v);\n\n    return 0;\n}\n```\n\n---\n\n**Example: Vectors as parameters VS arrays as parameters**\n\nHere is the output:\n\n```text\n2\t4\t6\t8\t10\n1\t2\t3\t4\t5\n```\n\nIs that what you expected?\n\nThe `std::vector` is _passed by value_, so the elements are not modified in the caller (`main`) even though they were modified in the `example` function.\n\n* This means a copy was made - we need to keep in mind the potential cost of the copy when working with STL containers.\n\n---\n\n**We can pass _by reference_ if we want to.**  While we're at it, let's use `const` qualifiers to add safety guarantees to the printing functions.\n\n```cpp\nvoid example(int a[], int size){\n    for(int i = 0; i < size; ++i)\n        a[i] *= 2;\n}\n\nvoid example(std::vector<int>& v){\n    for(std::vector<int>::size_type i = 0; i < v.size(); ++i)\n        v[i] *= 2;\n}\n\nvoid print_all(const int a[], int size){\n    for (int i = 0; i < size; ++i)\n        std::cout << a[i] << '\\t';\n    std::cout << '\\n';\n}\n\nvoid print_all(const std::vector<int>& v){\n    for(auto value : v)\n        std::cout << value << '\\t';\n    std::cout << '\\n';\n}\n```\n\n---\n\n**Now, the output - without changing `main()` at all:**\n\n```text\n2\t4\t6\t8\t10\n2\t4\t6\t8\t10\n```\n\n**Hint:** Prefer to pass a `vector` (or other STL container) by `const` reference (or plain reference if you want to modify it in the function) unless there is a \"good reason\" to make a copy.\n\n",
    "supporting": [
      "12_vector_files"
    ],
    "filters": [],
    "includes": {}
  }
}