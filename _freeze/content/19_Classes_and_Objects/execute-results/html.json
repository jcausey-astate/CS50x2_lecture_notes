{
  "hash": "4f7b45ea31057edc3f3f2cbd09b01884",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nnumber: 19\ntitle: \"Classes and Objects\"\ntextbook: \"Gaddis (Ch. 13)\"\n# draft: true\n---\n\n\n## Introduction {.morespace}\n\n* Procedural (structured) Programming\n    - Concerned with processes (_actions_) that occur in a program.\n    - Basic unit of modularity is the _function_.\n* Object-Oriented Programming (OOP)\n    - Focuses on the data (_things_) and the functions that operate on it.\n    - Basic unit of modularity is the _class_ (or structure).\n\n---\n\n## OOP Central Concepts {.morespace}\n\n* Encapsulation\n    - Bundling\n    - Data / Implementation Hiding\n        + Principle of *least privilege*.\n    - Public Interface\n\n* Class Hierarchies (Inheritance)\n    - Factoring out common data/behavior.\n    - Standardizing a common (public) interface.\n\n---\n\n## OOP Terminology\n\n\\\n\n**_Class_** - Encapsulates data and functions that are related, essentially like a structure. Creates a new _type_.\n\n* The class is the _blueprint_ describing the new type of thing.\n\n**_Object_** - an instance of a class.\n\n* The object is the real thing that is built by following the blueprint.\n\n**_Attributes_** - a class's _member data_\n\n**_Methods_** - a class's _member functions_\n\n\\\n\n[We will use `class` and `struct` somewhat interchangeably.]{.red}\n\n---\n\n## Format of a Class\n\\\n\n```cpp\nclass ClassName {\n    declaration;\n    declaration;\n};\n```\n\n\\\n\n**Example**\n\n::: {.columns}\n:::: {.column width=50%}\n```cpp\nstruct Rectangle {\n    double length;\n    double width;\n    double area;\n};\n\n```\n::::\n:::: {.column width=50%}\n```cpp\nclass Rectangle {\n    public:\n        double length;\n        double width;\n        double area();\n};\n```\n::::\n:::\n\n---\n\n## Access Specifiers\n\n\\\n\n**`public`** - Available both inside and _outside_ the class definition.\n\n**`private`** - Only available _inside_ the class definition.\n\n**`protected`** - Similar to `private` (we'll see this later).\n\n\\\n\n* Order doesn't matter.\n\n* Default is `private` for `class`.  (Default is `public` for `struct`.)\n  * This is the _only_ difference between `class` and `struct` in C++.\n\n---\n\n## Methods {.morespace}\n\n* Prototype in _class declaration_\n* Definition usually in separate _implementation file_.\n    - May also be in same file.\n* _Scope resolution operator_ ( `::` ) – used to establish ownership of an identifier\n    - Must be used when splitting method definitions from the class declaration.\n* Private methods – what good are they?\n\n---\n\n## Separating *Specification* and *Implementation* {.morespace}\n\n* Header files ( _`MyClass`_`.h` ) – place class specification (declaration) here\n* Implementation file ( _`MyClass`_`.cpp` ) – implement methods here\n* `#include` the header from the implementation file\n* Implementation ( `.cpp` ) files can be compiled; header files cannot.\n* **NEVER** `#include` a `.cpp` file!\n\n\n---\n\n#### Example: Separate specification and implementation.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n_`Rectangle.h`_\n```cpp\n#ifndef RECTANGLE_H\n#define RECTANGLE_H\n\nclass Rectangle {\n    public:\n        double length;\n        double width;\n        double area() const;\n};\n\n#endif\n```\n:::\n\n::: {.column width=\"50%\"}\n_`Rectangle.cpp`_\n```cpp\n#include \"Rectangle.h\"\n\ndouble Rectangle::area() const{\n    return length * width;\n}\n```\n:::\n::::\n\n---\n\n## Include Guards\n\n\n```{cpp, echo=TRUE, eval=FALSE, `code-line-numbers`=\"1,2,11\"}\n#ifndef RECTANGLE_H  // <1>\n#define RECTANGLE_H  // <1>\n\nclass Rectangle {\n    public:\n        double length;\n        double width;\n        double area() const;\n};\n\n#endif  //<1>\n```\n\n1. **_Include Guards_** protect the definitions in a header file from being included more than once in a project.\n\n---\n\n## Accessors and Mutators {.morespace}\n\n* Provides a way to safely access data members.\n* Principle of _least privilege_.\n* Stale data (Avoid it!)\n* Allows the class to _disallow incorrect states_.\n\n---\n\n## Constructors {.morespace}\n\n* Allow an object to be _instantiated_ (created) in an already-working state.\n    - Contrast this with the _uninitialized_ state that regular data and `struct`s begin with.\n* Constructors _do not_ have any return type.\n* Constructors have the same name as the class.\n* _Default constructor_ is a constructor that takes no parameters; used to create a \"default\" or \"blank\" object.\n* Constructors may take parameters to allow _initialization_ during instantiation.\n* Classes do not always have a default constructor.\n\n\n---\n\n## Constructors {.morespace}\n\n* Allow an object to be _instantiated_ (created) in an already-working state.\n    - Contrast this with the _uninitialized_ state that regular data and `struct`s begin with.\n* Constructors _do not_ have any return type.\n* Constructors have the same name as the class.\n* _Default constructor_ is a constructor that takes no parameters; used to create a \"default\" or \"blank\" object.\n* Constructors may take parameters to allow _initialization_ during instantiation.\n* Classes do not always have a default constructor.\n\n---\n\n## Constructors (c-tors)\n\n\\\n\nA constructor's job is to initialize attributes of the class:\n\n\\\n\n``` cpp {code-line-numbers=\"3-6\"}\nclass Rectangle {\n    public:\n        Rectangle (int l, int w){\n            length = l;\n            width  = w;\n        }\n        int length;\n        int width;\n};\n```\n\n---\n\n## c-tor initialization lists {.morespace}\n\n\\\nBut... there is another way to do it:  **_Constructor initialization list_**\n\n* Compact syntax for placing values into attributes in a constructor implementation.\n* Guarantees initialization *before* body of constructor executes.\n\n\n---\n\n### Example: c-tor initialization list\n\n\n``` cpp {code-line-numbers=\"3\"}\nclass Rectangle {\n    public:\n        Rectangle (int l, int w) : length{l}, width{w} {}\n        int length = 0;\n        int width  = 0;\n};\n```\n\\\n\nThis:\n\n``` cpp\n : length{l}, width{w}\n```\n\nIs the _constructor initialization list_.  It is followed in this case by an _empty_ method body `{}`, which is OK since there is nothing more for this constructor to do.\n\n\\\n\n* The initialization list takes effect _**before**_ the body of the c-tor method begins to execute!\n\n---\n\n### No scope resolution ambiguity!\n\n\\\n\n``` cpp\nclass Rectangle {\n    public:\n        Rectangle (int length, int width)\n            : length{length}, width{width} {}\n        int length = 0;\n        int width  = 0;\n};\n```\n\\\n\n* Constructor initialization lists can only contain initializations for attributes and constructor delegation to base classes (we will see later).\n    * So, there cannot be ambiguity with respect to attribute versus parameter names.\n\n---\n\n## Destructors {.morespace}\n\n* Called automatically when object is destroyed\n    * Either by being deleted or going out of scope\n* Named same as class, but begins with `~`\n* No return value, no parameters\n* Cannot be overloaded\n* ... when and why destructors are needed\n\n---\n\n## Inline Methods {.morespace}\n\n* Implemented directly in class specification.\n* Substituted during compilation.\n* Speed VS executable size\n* “inline all 1-liners”\n* `inline` keyword\n    - Can be used to inline functions implemented separately.\n\n---\n\n## Overloading {.morespace}\n\n* Constructors may be overloaded\n    - Remember that there are consequences for default constructor\n* Methods may be overloaded\n* Destructors _may NOT_ be overloaded\n\n---\n\n## Pointers to Objects {.morespace}\n\n* Uses same pointer notation\n* “dot-notation” becomes “arrow-notation”:\n* Arrow operator (  `->`  )\n* Dynamic allocation of objects is possible\n\n---\n\n### `this` keyword  {.morespace}\n\n* `this` is a keyword representing a *pointer to* the current object.\n* Used to disambiguate naming within method bodies.\n\n**Example**\n\n```cpp\nclass Rectangle{\n    Rectangle(int l, int w);\n    void set_length(int length){\n        this->length = length;\n    }\n    // [...] other methods not shown.\nprivate:\n    int length;\n    int width;\n};\n```\n\\\n\n[CPP Core Guideline: Use a class if any member is non-public.](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c8-use-class-rather-than-struct-if-any-member-is-non-public){.small}\n\n\n---\n\n## Uniform Initialization Syntax\n\n\\\n\n* Added in C++11\n* Allows initialization of all types of variables with the same syntax.\n* The \"old\" syntax for each type still works, but consider using uniform syntax.\n\n\n**Syntax:**\\\n`variableType  variableName{argument1, argument2};`\n\n\\\n\n**Example:**\n\n```cpp\nint       age{23};\nRectangle classroom{24, 30};\n// The following is an array - we will talk more about these soon:\ndouble    temperatures[]{78.8, 80.2, 92.4, 87.5, 95.3, 95.1, 92.8};\n```\n\n---\n\n## Other Details {.morespace}\n\n* Timing of constructors, destructors\n* Arrays of objects\n    - Requires default constructor ...\n    - ... unless initialization syntax is used.\n        * May provide arguments only or constructor invocations.\n\n---\n\n## `const` methods {.tight}\n\n* In classes / structures, a method can \"promise\" not to modify the *state* of the object.\n    - meaning, values of attributes will not be modified\n* accomplished by marking methods as `const`:\n\n```cpp\nclass Rectangle{\npublic:\n    int get_length() const;  // const method\n    //[... other code not shown ...]\nprivate:\n    int length = 0;\n    int width  = 0;\n};\n```\n\n`get_length()` *cannot* modify the attributes (`length` and `width`).\n\n* This protection is often added to accessors, and [*should* be added whenever possible]{.highlight}.\n    - Mutators cannot be `const` methods, since they need to change the state of the object.\n\n",
    "supporting": [
      "19_Classes_and_Objects_files"
    ],
    "filters": [],
    "includes": {}
  }
}