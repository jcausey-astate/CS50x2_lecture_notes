{
  "hash": "3f85b8e6889aac98b50dd9e5ba69e434",
  "result": {
    "markdown": "---\nnumber: 11\ntitle: \"Pointers\"\ntextbook: \"Gaddis (Ch. 9)\"\n# draft: true\n---\n\n## Addresses and Data\n\nEvery variable in a program is stored at a unique memory address.\n\n\\\n\nThe unary **`&`** is the **_address operator_**; the address operator retrieves the address of its operand:\n\n\\\n\n``` cpp {code-line-numbers=\"3\"}\nint x = 42;\n// Print out the address at which x is stored:\nstd::cout << &x << \"\\n\";\n```\n\n::: {.aside}\nWe don't usually care about the address ourselves, and our users wouldn't care either.  So, printing it to the screen is only useful as a learning exercise.  But what we **do** care about is what we can do with the address of a variable.  Read on...\n:::\n\n---\n\n## Pointers\n\n* A _pointer_ is a variable that stores a memory address.\n    - Declare by adding the _pointer type modifier_ ( **`  *  `** ) to a variable declaration.\n        + The pointer will hold the address of a value of the specified type.\n\n**Example: (pointer to an `int`)**\n\n``` cpp {code-line-numbers=\"3\"}\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\n```\n\n---\n\n## Why?\n\n* **Low-level access.**\n    - To provide explicit, direct access (no copy) in a similar way to what we do implicity with _pass by reference_.\n* **Iteration**\n    - Pointer math makes array manipulation through pointers very convenient.\n    - Advanced data structures may only allow iteration through pointers.\n* **Dynamic Memory Allocation**\n    - Memory generated at runtime is only identified to the program through its address.\n\n---\n\n## Why? (simplified)\n\n<br /><br />\n\n**Observation and Modification**     \n\n* **_Observing_ Pointers:** Pointers can be used to _observe_ the contents of memory, and potentially to _modify_ the values under observation as well.    \n<br /><br />\n\n**Ownership**     \n\n* **_Owning_ Pointers:** Pointers can be used to maintain \"ownership\" of dynamically-allocated memory resources.\n\n---\n\n## Physical View\n\n``` cpp\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\n```\n\nThe following figure illustrates the _physical view_ of what a pointer actually looks like in memory.  The pointer `xPtr` contains the _address_ of the location where `x` is stored:\n\n![Physical view of pointer in memory.](images/shared/pointer_in_memory.svg)\n\n---\n\n## Logical View\n\n``` cpp\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\n```\n\nThe following figure illustrates the _logical view_ of what a pointer conceptually does.  The pointer `xPtr` _points to_ the the variable `x`:\n\n![Conceptual view of pointer in memory.](images/shared/pointer_in_memory_conceptual.svg)\n\n---\n\n## Physical and Logical View\n\n``` cpp\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\n```\n\n![Physical view of pointer in memory.](images/shared/pointer_in_memory.svg)\n\n![Conceptual view of pointer in memory.](images/shared/pointer_in_memory_conceptual.svg)\n\n---\n\n## Indirection\n\nKnowing the address of where something is stored gives a programmer low-level access to the data at that location.\n\n* Pointers store the addresses of other variables; they give us _indirect control_ over the values in those variables.\n* The **_indirection operator_** (**` * `**) allows us to \"follow\" a pointer to the address it is storing, so that we may operate on the data stored there.\n    - This is known as _dereferencing_ the pointer.\n    - The indirection operator is also sometimes called the _dereference operator_.\n\n---\n\n<!-- .slide: data-background=\"aliceblue\" -->\n**Example: Using a Pointer**\n\n``` cpp\n int x = 75;                  // just a normal integer\n \n // [...]          \n \n int* xPtr;                   // declare a pointer to an int\n xPtr = &x;                   // point xPtr to x\n \n // [...]          \n \n *xPtr = 100;                 // use xPtr, change value in x\n std::cout << *xPtr << \"\\n\";  // prints 100\n std::cout << x     << \"\\n\";  // x is also 100 now.\n```\n\n---\n\n## \"Null\" Pointers\n\nA pointer that doesn't point to _any_ (legal) memory address is referred to as a \"null pointer\".\n\n* C++11 added a keyword to represent the literal value of a null pointer:  `nullptr`.\n\n```cpp\nint* x = nullptr; // declare and initialize to nullptr\n```\n* Setting a pointer to `nullptr` guarantees that it cannot be _dereferenced_.\n    + (Basically, you can't use a null pointer for anything.) \n\n---\n\n### Pointers are Similar to...\n\n* Pass-by-Reference\n    - actually passes an _address_, not a data value\n    - does so implicitly; programmer does not need to take any action\n* Arrays\n    - array variables are _reference types_\n    - array variable will degrade to a pointer to the array when used in an expression without index notation (**`[i]`**).\n\n---\n\n## Pointers to Arrays\n\n``` cpp\nint a[5] = { 1, 2, 3, 4, 5 };  // normal array\n```\n\n**Pointers can be used to access elements of an array.**\n\n``` cpp \nint* aPtr = a; // no need for `&`: `a` degrades to a pointer\n```\n\n**Pointer mathematics.**      \n<small style=\"font-size: 70%;\"><i>This is why the **type** is important for pointers.</i></small>\n\n``` cpp\nstd::cout << *(aPtr + 2) << \"\\n\"; // prints a[2]\n```\n\n**Pointer and array notation is interchangeable.**\n\n``` cpp\nstd::cout << aPtr[2] << \"\\n\";  // easier than \"*(aPtr + 2)\"\n```\n\n---\n\n## More Pointer Math\n\nPointers support the following mathematical operations:\n\n\n``` {text}\nOperation           Example      Description\n----------------------------------------------------\n <ptr> + <int>      xPtr + 3     Add an offset\n <ptr> - <int>      xPtr - 2     Subtract an offset\n ++<ptr>            ++xPtr       (pre) increment\n <ptr>++            xPtr++       (post) increment\n --<ptr>            --xPtr       (pre) decrement\n <ptr>--            xPtr--       (post) decrement\n <ptr> - <ptr>      xPtr - yPtr  Offset distance \n                                 between two pointers\n```\n\n\n---\n\n## Pointers as \"Iterators\"\n\nYou can use a pointer to \"move around\" in an array:\n\n``` cpp\nint a[5] = { 1, 2, 3, 4, 5 };\n// [...]\nint* begin = a;               // start is first addr of a\nint* end   = a + 5;           // end is start + size\n\n// \"For each element in a\", using a pointer for movement:\nfor(int* current = begin; current != end; current++){\n    std::cout << *current << \"\\t\";\n}\n```\n\nThis design pattern is very common in the C++ Standard Template Library.\n\n---\n\n### `const` Pointers and Pointers to Constants\n\n* A pointer can be declared constant\n    - `int* const ptr;`\n        + Here, the pointer's _value_ (target address) cannot be changed.\n* A pointer can be use to _point to a constant_:\n    - `const int* ptr;`\n        + Here, the pointer cannot be used to modify the target _data_.\n* Finally, you can have a constant pointer to a constant:\n    - `const int* const ptr;`\n        + Neither the pointer nor its target may be changed.\n\n---\n\n## Passing Pointers to Functions\n\n* A pointer may be used as an alternative syntax for passing a 1-D array to a function.\n    - Pointer notation is commonly used for c-strings, for example.\n* Pointer values behave as a _primitive type_.\n    - They are passed _by value_, like all other primitive types.\n* Pointers may also be passed by reference if the address in the pointer itself should be changed by the function.\n    - Doing so requires adding the _reference type modifier_  (` & `)to the formal parameter, just like with any other primitive data.\n\n---\n\n## Common design pattern:  \"Range\"-based operations with pointers to arrays\n\n```cpp\n// Assume array `a` already declared as `int a[5];`\nint* begin = a;     // \"left\" edge of array\nint* end   = a + 5; // \"right\" edge of array\n```\n\n![Pointers to range in array `a`.](images/shared/range_iterators_in_array.svg)\n\nNotice that `end` physically points to the first memory address _beyond_ the end of the\narray.  For this reason, i**t would be an error to try to dereference `end`**.  We must be\ncareful to ensure that never happens.\n\n**This pattern also applies to _iterators_ to array-like data structures.**\n\n---\n\n## Common design pattern:  \"Range\"-based operations with pointers to sub-arrays\n\n```cpp\n// Assume array `a` already declared as `int a[5];`\nint* first = a + 1;  // \"left\" edge of subrange\nint* last  = a + 4;  // \"right\" edge of subrange\n```\n\n![Pointers to range in array `a`.](images/shared/range_iterators_to_subrange.svg)\n\nIn this usage, we are bracketing a _subrange_ of values within the larger array.  Again,\nnotice that the `last` pointer points to a value outside that subrange - it should not\nbe dereferenced.\n\n**This pattern also applies to _iterators_ to array-like data structures.**\n\n",
    "supporting": [
      "11_Pointers_files"
    ],
    "filters": [],
    "includes": {}
  }
}