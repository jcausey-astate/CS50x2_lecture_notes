<!DOCTYPE html>
<html>
<head>
	<title></title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link rel="icon" type="image/vnd.microsoft.icon" sizes="32x32" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/favicon.ico">
	<link rel="stylesheet" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/css/remark.css" />
	<link rel="stylesheet" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/css/slides-additional.css" />
	<link rel="stylesheet" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/css/prog-courses.css" />
    <base target="_blank" />
</head>


<body>
    <textarea id="source" class="three-col">


# Input and Output
## Gaddis Ch. 3, 5.11

---

## Review: Output Streams

Recall that a _stream_ is a one-way flow of information.  Output streams are streams that take information from the running program and move it to the outside world.

* The standard output stream is named `std::cout`
    - Often shortened to `cout` (add `using std::cout;` after the include)
    - We will refer to the standard output stream as `cout` in discussion.
* Output streams work together with the _stream insertion operator_ ( `&lt;&lt;` ).
    - `&lt;&lt;` inserts items into the output stream listed to its left.
    - (Almost) any type of data can be inserted into an output stream.

---

### Example


``` cpp
    std::cout &lt;&lt; &#34;Integer: &#34; &lt;&lt; 42 &lt;&lt; &#34;, Real number: &#34; &lt;&lt; 3.14 &lt;&lt; &#34;\n&#34;;
    int x = 88;
    std::cout &lt;&lt; &#34;From variable: &#34; &lt;&lt; x &lt;&lt; &#34;\n&#34;;
```

&lt;br /&gt;

The code shown above will produce the following output:

&lt;br /&gt;

    Integer: 42, Real number: 3.14
    From variable: 88

---

## Input Streams

An **_input stream_** brings information from the outside world _into_ the running program.

* The standard input stream is named `std::cin`
    - Often shortened to `cin` (add `using std::cin` after the include)
    - We will refer to the standard input stream as `cin` in discussion
* Input streams work together with the _stream extraction operator_ ( `&gt;&gt;` ).
    - `&gt;&gt;` extracts data from the stream (on its left) and stores the data in the variable on its right.

---

### Example

``` cpp
    int     temperature;
    double  rainfall;
    cout &lt;&lt; &#34;Enter the temperature in degrees Fahrenheit: &#34;;
    cin  &gt;&gt; temperature;
    cout &lt;&lt; &#34;Enter the day&#39;s rainfall total: &#34;;
    cin  &gt;&gt; rainfall;
```

The code shown above will read the temperature from the user (entered at the keyboard) as an integer value, storing it in `temperature`.  
Then, the rainfall total is read as a Real-number value and stored in `rainfall`.   
**Notice** the necessity of _prompting_ the user before reading the values!

---

## Stream Extraction - details

* The _type_ of the variable that is intended to store the data must match the _type_ of the data being extracted.
    - The extraction may fail if this is not the case.
* The stream extraction operator is _whitespace delimited_, meaning that it will read the next series of non-whitespace characters in the input stream and convert those to the required type.
    - This means you cannot read anything containing spaces using `&gt;&gt;`.

---

## Streams: Plural

You have used the _standard input_ stream and the _standard output_ stream; C&#43;&#43; provides the opportunity to create other streams as well.

* All input streams support the same operations.
* All output streams support the same operations.
* So, if you can use `std::cin` and `std::cout`, you can use any stream!

---

## Files

In the most general sense, a _file_ is an abstraction by which the operating system allows us to store a blob of related data on a device other than main memory.

* _**file**_ - a collection of related data stored on a device other than main memory and accessed by means of a _file name_.
* _**file name**_ - a string that uniquely identifies a single file on the system.

---

## Files

To work with files, start by including the `&lt;fstream&gt;` library.

* We will be working with files in _text mode_, meaning the contents are encoded as plain ASCII text.
    - Our interaction with the file will &#34;feel&#34; exactly the same as interacting with a user/screen.
* You can also access a file in pure _binary mode_ as well. (later)

---

## File Operations

Working with files will involve the following series of high-level steps:

1. Open the file
    * This associates the file name with the physical file, and initializes a stream to/from the file.
2. Read or write data from/to the file
    * The file can be read/written as a stream - just like any other stream.
3. Close the file
    * This allows the Operating System to release resources associated with the file, and flush buffers.

---

## Output File Streams

* Create a `std::ofstream` file stream object and use it to open and manipulate the file:
``` cpp
double value1 = 4.4, value2 = 3.8;       
std::ofstream fout;             // declare a stream
fout.open(&#34;my_input_file.txt&#34;); // open the file
fout &lt;&lt; value1                  // insert values
       &lt;&lt; &#34;\n&#34;                    // separated on
       &lt;&lt; value2;                 // two lines
fout.close();                   // close the file
```

---

## Input File Streams

* Create a `std::ifstream` file stream object and use it to open and manipulate the file:
``` cpp
double value1, value2;        
std::ifstream fin;             // declare a stream
fin.open(&#34;my_input_file.txt&#34;); // open the file
fin &gt;&gt; value1 &gt;&gt; value2;       // read some values
fin.close();                   // close the file
std::cout &lt;&lt; value1 &lt;&lt; &#34;, &#34; &lt;&lt; value2 &lt;&lt; &#34;\n&#34;;
```

---

## Alternatives

* You can also declare and open in one line:
``` cpp 
std::ifstream fin(&#34;my_input_file.txt&#34;);
```
* A `std::fstream` object can do _either_ input or output -- or both, but you must specify the _open mode_:
```cpp
std::fstream fp;
```

---

```cpp
std::fstream fp;
```
Now you can open for input:
``` cpp
fp.open(&#34;my_file.txt&#34;, std::ios::in); // open for input
```
Or for output:
``` cpp
fp.open(&#34;my_file.txt&#34;, std::ios::out); // open for output
```
Or append to the end of the file:
``` cpp
fp.open(&#34;my_file.txt&#34;, std::ios::out|std::ios::app); // append mode
```

---

## Open Modes
 
&lt;pre&gt;
Open Mode       Description
---------------------------------------------
std:: ios::in   Input mode (file must exist)
std:: ios::out  Output mode (file will be 
                created, if it exists, it will
                be overwritten)
std:: ios::app  Use with ios::out to append 
                to the end of an output file.
&lt;/pre&gt;

There are other modes as well, but they are not of interest to us at this time.

---

## File Open Failures

* Opening an input file may **fail** if:
    - The file does not exist, or is misnamed.
    - You do not have permission to read the file.
    - All OS file resources are in use.
* Opening an output file may **fail** if:
    - The file exists, but you do not have permission to overwrite it.
    - You do not have permission to write in the destination directory.
    - All OS file resources are in use.

---

## Testing for File Open Success

File streams support a function called `is_open()` that will return `true` if the file was opened successfully.  This function can be used to check for a failure to open. 

We will cover `if` statements soon, but here is a sneak peek:

``` cpp
std::ifstream fin;                         
fin.open(&#34;my_input_file.txt&#34;);             
if( !fin.is_open() ){                      
    std::cout &lt;&lt; &#34;Failed to open file.\n&#34;; 
    exit(1);                               
}
```

---

### Formatted Output

The `&lt;iomanip&gt;` library supplies a set of _stream manipulators_ that may be used in conjunction with the stream insertion operator to format output.  
&lt;pre style=&#39;font-size: .85em&#39;&gt;
Manipulator            Description
-----------------------------------------------------------
std::setw( w )         set the width of the next item in the
                       stream to &#39;w&#39;
std::setprecision( p ) set number of significant figures in 
                       output to &#39;p&#39;, or set the number of 
                       decimal places to &#39;p&#39; if used in 
                       conjunction with &#39;fixed&#39;.
std::fixed             set numeric output to fixed-point 
                       mode (use the number of decimal 
                       places specified by &#39;setprecision&#39;; 
                       no scientific notation)
std::showpoint         always show the decimal point 
std::left              set alignment to left-aligned
std::right             set alignment to right-aligned
&lt;/pre&gt;

---

### Example

``` cpp
double price = 100.0 / 3.0;  // 33.3333333...
std::cout &lt;&lt; std::setprecision(2) &lt;&lt; std::fixed;
std::cout &lt;&lt; &#34;Total price: $&#34; 
          &lt;&lt; std::setw(8) &lt;&lt; price &lt;&lt; &#34;\n&#34;;
std::cout &lt;&lt; &#34;100 items:   $&#34; 
          &lt;&lt; std::setw(8) &lt;&lt; 100 * price &lt;&lt; &#34;\n&#34;;
```
Output:
&lt;pre&gt;
Total price: $   33.33
100 items:   $ 3333.33
&lt;/pre&gt;

---

## `getline()`

In order to read a `std::string` that may contain whitespace from an input stream, the `getline()` function should be used:

``` cpp
std::string full_name;

std::cout &lt;&lt; &#34;Enter your first and last name: &#34;;
getline(std::cin, full_name);

std::cout &lt;&lt; &#34;Hello, &#34; &lt;&lt; full_name &lt;&lt; &#34;!\n&#34;;
```

`getline()` will read an entire line of user input (until the `&lt;ENTER&gt;` key is pressed).  The _syntax_ is: &lt;br /&gt;
&lt;tt&gt;getline( &lt;i&gt;source_stream&lt;/i&gt; , &lt;i&gt;destination_string&lt;/i&gt; )&lt;/tt&gt; &lt;br /&gt;

&lt;small&gt;Where _`source stream`_ is any input stream and _`destination string`_ is a variable of type `std::string`.&lt;/small&gt;

---

### Mixing `getline()` and `&gt;&gt;`

**Problem:** Stream extraction ( `&gt;&gt;` ) leaves the delimiting whitespace in the input stream (usually a `&#39;\n&#39;`).

* `getline()` is _newline-delimited_ by default.  
    - It will appear that the `getline()` was &#34;skipped&#34;.  Actually, it saw the `&#39;\n&#39;` and stopped.
* To remove the `&#39;\n&#39;`, use: &lt;br /&gt; _`stream_name`_`.ignore()`
    - Ex:  `std::cin.ignore();`
    - Better:&lt;small style=&#34;font-size: 87%;&#34;&gt;
 ``` cpp
 std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
 ```
&lt;/small&gt;

---

## `cin.get()`

The `cin.get()` function can be used to read a single character, which may be whitespace, from the standard input stream.

**Example**
``` cpp
char ch;
// Reading the &lt;ENTER&gt; key with `&gt;&gt;` alone is difficult... 
// So, use `get()`:
std::cout &lt;&lt; &#34;Press &lt;ENTER&gt; to continue...&#34;;
std::cin.get(ch); // Will wait for the enter key, then continue.
```

The `get()` function also works with other streams, in general the syntax is: &lt;br /&gt;
_`stream`_`.get(`*`character_var`*`)`


---

## In case the stream goes bad...

If you are working with an open stream, several things can cause the stream to no longer be in the &#34;good&#34; state.  The most common are:

* Failure of stream extraction operator to convert the apparent type it &#34;sees&#34; to the type requested on its right-hand side.
* End-of-file (or end of stream) encountered during a &#34;read&#34; operation.

In these cases you may be able to remedy the problem -- perhaps by removing unwanted characters from the stream with `ignore()`, or by moving the stream position &#34;earlier&#34; in the stream in case of EOF -- then resume operation.  The `clear()` method will help with this by clearing the stream&#39;s _state flags_:

``` cpp
std::cin.clear();  // clears the state flags on `cin`
```

</textarea>
    <script src="https://jcausey-astate.github.io/CS50x2_lecture_notes/js/remark-latest.min.js"></script>
<script src="https://jcausey-astate.github.io/CS50x2_lecture_notes/js/remark-macros.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js"></script>
<script>
	var slideshow = remark.create({
		highlightStyle: "github",
		highlightLines: true,
  		highlightSpans: true
	});

	
	window.MathJax = {
		tex: {
			inlineMath: [['$', '$'], ['\\(', '\\)']],
			displayMath: [             
      			['$$', '$$'],
      			['\\[', '\\]']
    		],
		}
	};
</script>
</body>

</html>