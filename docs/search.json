[
  {
    "objectID": "content/99_cmath_epsilon_comparison.html#mathematical-functions",
    "href": "content/99_cmath_epsilon_comparison.html#mathematical-functions",
    "title": "Supplement: cmath and Epsilon Comparison",
    "section": "Mathematical Functions",
    "text": "Mathematical Functions\nThere are many mathematical functions that do not have an operator in C++. The &lt;cmath&gt; library provides definitions for these. Some examples are:\n\n    Function Name      Description\n    --------------------------------------------------------\n    pow(base, exp)     Returns base raised to power of exp\n    sqrt(x)            Returns square root of x\n    floor(x)           Returns the mathematical floor of x\n    ceil(x)            Returns the mathematical ceiling of x\n    fabs(x)            Returns the absolute value of x\n    sin(theta)         Returns the mathematical sine of theta\n    (other trig functions available also; measure in radians)"
  },
  {
    "objectID": "content/99_cmath_epsilon_comparison.html#numerical-inaccuracy",
    "href": "content/99_cmath_epsilon_comparison.html#numerical-inaccuracy",
    "title": "Supplement: cmath and Epsilon Comparison",
    "section": "Numerical Inaccuracy",
    "text": "Numerical Inaccuracy\n\n\n\nComputers use binary (base-2) numbers internally.\n\nOur base-10 numbers must be converted.\nConversion for integers is 1-1\nConversion for Real numbers is not so simple…"
  },
  {
    "objectID": "content/99_cmath_epsilon_comparison.html#irrational-numbers",
    "href": "content/99_cmath_epsilon_comparison.html#irrational-numbers",
    "title": "Supplement: cmath and Epsilon Comparison",
    "section": "Irrational Numbers",
    "text": "Irrational Numbers\n\n\n\nEven in base-10, we have many numbers that are irrational (they are non-terminating and non-repeating decimals). You cannot represent these exactly with any finite number of digits.\n\nExamples: \\(\\pi\\), \\(e\\)\n\n\n\n\n\nSome numbers that can be expressed precisely in base-10 cannot be expressed precisely in binary:\n\nExamples: \\(0.1\\), \\(0.3\\)\n\n\n\n\n\nWe are forced to round such numbers. The computer does the same."
  },
  {
    "objectID": "content/99_cmath_epsilon_comparison.html#rounding-errors",
    "href": "content/99_cmath_epsilon_comparison.html#rounding-errors",
    "title": "Supplement: cmath and Epsilon Comparison",
    "section": "Rounding Errors",
    "text": "Rounding Errors\n\nThe conversion for literal values (like 0.1) into binary is deterministic, meaning it will always produce the same binary representation for the same decimal value.\n\nIf it were not, the entire computing architecture would be broken.\n\n\n\n\n\nHowever, the values are being rounded; thus, the internal representation contains some rounding error."
  },
  {
    "objectID": "content/99_cmath_epsilon_comparison.html#rounding-errors-1",
    "href": "content/99_cmath_epsilon_comparison.html#rounding-errors-1",
    "title": "Supplement: cmath and Epsilon Comparison",
    "section": "Rounding Errors",
    "text": "Rounding Errors\n\nInternal representations of floating-point values may contain some rounding error.\n\nApplying repeated mathematical operations to floating-point values amplifies this rounding error.\n\n\n\n\n\nTesting a calculated floating-point value for equality against another value is not guaranteed to produce the correct result, since rounding errors may have accumulated in the calculated value."
  },
  {
    "objectID": "content/99_cmath_epsilon_comparison.html#what-is-equal",
    "href": "content/99_cmath_epsilon_comparison.html#what-is-equal",
    "title": "Supplement: cmath and Epsilon Comparison",
    "section": "What is “Equal”?",
    "text": "What is “Equal”?\nThe values 3.1415926535897931 and 3.1415926535897927 are very nearly equal.\nIn most disciplines, a difference in the 15th decimal position would not be unacceptable.\nThe problem is that the == operator is often too strict a test. What we really want to know is whether the values are “equal” to within an acceptable tolerance."
  },
  {
    "objectID": "content/99_cmath_epsilon_comparison.html#epsilon-comparison",
    "href": "content/99_cmath_epsilon_comparison.html#epsilon-comparison",
    "title": "Supplement: cmath and Epsilon Comparison",
    "section": "Epsilon Comparison",
    "text": "Epsilon Comparison\nIf we can define the amount of error (or variation) that we are willing to accept, we can test for “near equality” by checking that the difference between two values is acceptably small.\n\nEpsilon Comparison involves testing that the magitude of the difference between two values is less than an established tolerance usually referred to as epsilon.\n\nconst double EPSILON = 1e-12;\n// [...]\nif( fabs(a - b) &lt; EPSILON ){\n    // a is essentially equal to b\n}"
  },
  {
    "objectID": "content/99_cmath_epsilon_comparison.html#summary",
    "href": "content/99_cmath_epsilon_comparison.html#summary",
    "title": "Supplement: cmath and Epsilon Comparison",
    "section": "Summary",
    "text": "Summary\n\nNever test floating-point values using == or !=.\nUse an epsilon comparison instead.\nThe value of epsilon may vary depending on your application.\n\nHow much precision do you really need?\nHow many mathematical calculations are being performed before the test for “equality”?\n\nFor more information on this topic, see:\n\n\n\nhttp://www.learncpp.com/cpp-tutorial/25-floating-point-numbers/\nhttp://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\nhttp://randomascii.wordpress.com/2012/06/26/doubles-are-not-floats-so-dont-compare-them/\n\n\n\n\n\n\n\n\n\n \n\n\nSupplement: cmath and Epsilon Comparison"
  },
  {
    "objectID": "content/37_Efficient_Sorting.html#first---simple-sorting-may-be-review",
    "href": "content/37_Efficient_Sorting.html#first---simple-sorting-may-be-review",
    "title": "Efficient Sorting",
    "section": "First - Simple sorting (may be review)",
    "text": "First - Simple sorting (may be review)\n\n\nWe will look at (or review) the following “simple” sorting algorithms:\n\nBubble Sort\nSelection Sort\nInsertion Sort"
  },
  {
    "objectID": "content/37_Efficient_Sorting.html#more-efficient-algorithms",
    "href": "content/37_Efficient_Sorting.html#more-efficient-algorithms",
    "title": "Efficient Sorting",
    "section": "More efficient algorithms",
    "text": "More efficient algorithms\n\n\nNow, let’s consider the following more efficient sorting algorithms:\n\nHeap sort\nQuick sort\nMerge sort\nRadix sort"
  },
  {
    "objectID": "content/35_Graphs.html#definition-and-terminology",
    "href": "content/35_Graphs.html#definition-and-terminology",
    "title": "Graphs",
    "section": "Definition and Terminology",
    "text": "Definition and Terminology\n\nA graph is a data structure containing nodes and connections between them (much like a tree), but with no requirement for hierarchical ordering.\n\nWe often call the nodes vertices, and the connections between them edges.\nA simple graph, then is the non-empty set of vertices and edges \\(G=(V,E)\\).\n\n\n\n\n\n\n\nA graph\n\n\n\n\n\n\nA directed graph\n\n\n\n\n\n\nA weighted graph"
  },
  {
    "objectID": "content/35_Graphs.html#terminology",
    "href": "content/35_Graphs.html#terminology",
    "title": "Graphs",
    "section": "Terminology",
    "text": "Terminology\n\nA directed graph (or “digraph”) is the non-empty set of vertices and edges \\(G=(V,E)\\) where the edges \\(E={v_i, v_j}\\) have a direction associated with them.\n\nNeither simple graphs nor digraphs allow pairs of vertices to have more than one edge connecting them. A multigraph relaxes this restriction.\nA pseudograph allows an edge to connect a single vertex to itself (a loop).\n\n\n\nA directed graph"
  },
  {
    "objectID": "content/35_Graphs.html#terminology-1",
    "href": "content/35_Graphs.html#terminology-1",
    "title": "Graphs",
    "section": "Terminology",
    "text": "Terminology\n\nA weighted graph is a graph in which each edge has a number (or weight) assigned.\n\nDepending on context, weight is also called “cost”, “distance”, “length”, or some other name.\n\nA graph is complete if for each pair of distinct vertices, there is exactly one edge connecting them.\n\n\nA weighted graph"
  },
  {
    "objectID": "content/35_Graphs.html#terminology-2",
    "href": "content/35_Graphs.html#terminology-2",
    "title": "Graphs",
    "section": "Terminology",
    "text": "Terminology\n\nA subgraph is a set of edges and vertices that are themselves subsets of the edges and vertices of a larger graph.\n\nA subgraph induced by vertices \\(V'\\) is a graph such that any edges in the subgraph \\((V', E')\\) are also in the larger graph.\nTwo vertices are adjacent if there is an edge connecting them that is a member of the same graph.\nThe edge connecting them is said to be incident with them.\n\n\n\nA Subgraph (in blue)"
  },
  {
    "objectID": "content/35_Graphs.html#terminology-3",
    "href": "content/35_Graphs.html#terminology-3",
    "title": "Graphs",
    "section": "Terminology",
    "text": "Terminology\n\nThe degree of a vertex \\(v\\) is the number of edges incident with \\(v\\).\n\nA vertex with no incident edges is called an isolated vertex.\n\nIt is possible to have a graph \\(G\\) containing only isolated vertices. (\\(E\\) can be empty).\n\n\n\n\nVertex Degrees"
  },
  {
    "objectID": "content/35_Graphs.html#representations",
    "href": "content/35_Graphs.html#representations",
    "title": "Graphs",
    "section": "Representations",
    "text": "Representations\n\nAside from drawings: Graphs may be represented by\n\nAdjacency lists\nAdjacency matrices\nIncidence matrices\n\nSee Drozdek pg 378-379"
  },
  {
    "objectID": "content/35_Graphs.html#representation-adjacency-list",
    "href": "content/35_Graphs.html#representation-adjacency-list",
    "title": "Graphs",
    "section": "Representation: Adjacency List",
    "text": "Representation: Adjacency List\nDrozdek, Figure 8.2\n\n\n\n\n\nGraph\n\n\n\n\n\nAdjacency Table"
  },
  {
    "objectID": "content/35_Graphs.html#representation-adjacency-matrix",
    "href": "content/35_Graphs.html#representation-adjacency-matrix",
    "title": "Graphs",
    "section": "Representation: Adjacency matrix",
    "text": "Representation: Adjacency matrix\nDrozdek, Figure 8.2"
  },
  {
    "objectID": "content/35_Graphs.html#representation-incidence-matrix",
    "href": "content/35_Graphs.html#representation-incidence-matrix",
    "title": "Graphs",
    "section": "Representation: Incidence matrix",
    "text": "Representation: Incidence matrix\nDrozdek, Figure 8.2"
  },
  {
    "objectID": "content/35_Graphs.html#traversals",
    "href": "content/35_Graphs.html#traversals",
    "title": "Graphs",
    "section": "Traversals",
    "text": "Traversals\n\nMuch like tree traversals, vertices are “visited” one at a time.\nUnlike trees, graphs have cycles, so tree traversal algorithms would result in infinite loops.\n\nA cycle is a path from one vertex \\(v_i\\) through one or more edges such that the path returns to \\(v_i\\).\n\nVertices must be “marked” to avoid re-visiting the same vertex.\nIsolated vertices must also be visited in some way."
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example",
    "href": "content/35_Graphs.html#depth-first-traversal-example",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-1",
    "href": "content/35_Graphs.html#depth-first-traversal-example-1",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-2",
    "href": "content/35_Graphs.html#depth-first-traversal-example-2",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-3",
    "href": "content/35_Graphs.html#depth-first-traversal-example-3",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-4",
    "href": "content/35_Graphs.html#depth-first-traversal-example-4",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-5",
    "href": "content/35_Graphs.html#depth-first-traversal-example-5",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-6",
    "href": "content/35_Graphs.html#depth-first-traversal-example-6",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-7",
    "href": "content/35_Graphs.html#depth-first-traversal-example-7",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-8",
    "href": "content/35_Graphs.html#depth-first-traversal-example-8",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-9",
    "href": "content/35_Graphs.html#depth-first-traversal-example-9",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nStarting with the list \\(V\\) of vertices, the next available vertex v is visited\n\nCreate the list of vertices adjacent to \\(v\\) , and perform depth-first traversal on them.\nIf v has no adjacent vertices, backtrack to the predecessor of \\(v\\) .\nWhen you backtrack to the vertex where you started, you are done.\nRepeat as long as there are unvisited vertices"
  },
  {
    "objectID": "content/35_Graphs.html#depth-first-traversal-example-10",
    "href": "content/35_Graphs.html#depth-first-traversal-example-10",
    "title": "Graphs",
    "section": "Depth-First Traversal: Example",
    "text": "Depth-First Traversal: Example\n\nThis algorithm generates a tree (or forest , a set of trees) called a spanning tree.\n\nA spanning tree includes all vertices of the original graph, but does not contain any cycles."
  },
  {
    "objectID": "content/35_Graphs.html#breadth-first-traversals",
    "href": "content/35_Graphs.html#breadth-first-traversals",
    "title": "Graphs",
    "section": "Breadth-First Traversals",
    "text": "Breadth-First Traversals\nWe have discussed Depth-First traversals, where the traversal choose one path and “follows” it as far as possible before returning to try other paths.\nThe Breadth-First Traversal instead focuses on visiting all neighboring vertices before proceeding to other vertices.\nIn a tree-like structure, we could visualize this as working across each level of the tree before proceeding further “down” toward the leaves.\nIn a graph, the idea is the same - work on all vertices you can discover at the same “level” (distance from the start) before moving further into the graph."
  },
  {
    "objectID": "content/35_Graphs.html#breadth-first-traversals-utilize-a-queue",
    "href": "content/35_Graphs.html#breadth-first-traversals-utilize-a-queue",
    "title": "Graphs",
    "section": "Breadth-First traversals utilize a Queue",
    "text": "Breadth-First traversals utilize a Queue\nWhereas depth-first traversals made use of a stack as the primary “bookkeeping” data structure to allow backtracking, breadth-first traversals will use a queue to aid in prioritizing the ordering of vertex visits. The general algorithm is:\nfunction breadthFirstSearch(graph G):\n    let unseen := all vertices from G\n    let edges := empty List {}\n    let working := empty Queue {}\n    for each vertex v in unseen do\n        remove v from unseen\n        enqueue v into working\n        while working is not empty do\n            v := dequeue from working\n            for all vertices u adjacent to v in G do\n                if u is in unseen\n                    enqueue u into working\n                    insert edge(vu) into edges\n    return edges\nSee also: Drozdek pg. 397"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm",
    "href": "content/35_Graphs.html#dijkstras-algorithm",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm",
    "text": "Dijkstra’s Algorithm\n\nLet the node at which we are starting be called the initial node. Let the distance of node \\(Y\\) be the distance from the initial node to \\(Y\\). Dijkstra’s algorithm will assign some initial distance values and will try to improve them step by step."
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-1",
    "href": "content/35_Graphs.html#dijkstras-algorithm-1",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm",
    "text": "Dijkstra’s Algorithm\n\nAssign to every node a tentative distance value: set it to zero for our initial node and to infinity for all other nodes.\nMark all nodes except the initial node as unvisited. Set the initial node as current. Create a set of the unvisited nodes called the unvisited set consisting of all the nodes except the initial node."
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-2",
    "href": "content/35_Graphs.html#dijkstras-algorithm-2",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm",
    "text": "Dijkstra’s Algorithm\n\nFor the current node, consider all of its unvisited neighbors and calculate their tentative distances.\n\n\nFor example, if the current node \\(A\\) is marked with a distance of 6, and the edge connecting it with a neighbor \\(B\\) has length 2, then the distance to \\(B\\) (through \\(A\\)) will be \\(6+2=8\\).\nIf this distance is less than the previously recorded distance, then overwrite that distance. Even though a neighbor has been examined, it is not marked as visited at this time, and it remains in the unvisited set ."
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-3",
    "href": "content/35_Graphs.html#dijkstras-algorithm-3",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm",
    "text": "Dijkstra’s Algorithm\n\nWhen finished considering the neighbors of current node, mark current node as visited and remove it from the unvisited set . A visited node will never be checked again; its distance recorded now is final and minimal.\n\n\nThe next current node will be the node marked with the lowest (tentative) distance in the unvisited set .\nIf the unvisited set is empty, then stop. The algorithm has finished. Otherwise, set the unvisited node marked with the smallest tentative distance as the next “current node” and go back to step (3)."
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-4",
    "href": "content/35_Graphs.html#dijkstras-algorithm-4",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm",
    "text": "Dijkstra’s Algorithm\nfunction Dijkstra(Graph, source):\n    let Q be an empty queue\n    for each vertex v in Graph.Vertices:  # Initialize\n        dist[v] ← INFINITY\n        prev[v] ← UNDEFINED\n        add v to Q\n    dist[source] ← 0\n    \n    while Q is not empty:\n        u ← vertex in Q with min dist[u]\n        remove u from Q\n        \n        for each neighbor v of u still in Q:\n            alt ← dist[u] + Graph.Edges(u, v)\n            if alt &lt; dist[v]:\n                dist[v] ← alt\n                prev[v] ← u\n    return dist[], prev[]\nSource: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-1",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-1",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-2",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-2",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-3",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-3",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-4",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-4",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-5",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-5",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-6",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-6",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-7",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-7",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-8",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-8",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-9",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-9",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-10",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-10",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7"
  },
  {
    "objectID": "content/35_Graphs.html#dijkstras-algorithm-example-11",
    "href": "content/35_Graphs.html#dijkstras-algorithm-example-11",
    "title": "Graphs",
    "section": "Dijkstra’s Algorithm Example",
    "text": "Dijkstra’s Algorithm Example\nDrozdek, Figure 8.7\n\n\n\n\nYou can find the shortest path by backtracking to the points where the “best” assigned distance updated to the final value."
  },
  {
    "objectID": "content/35_Graphs.html#fords-algorithm-bellman-ford-algorithm",
    "href": "content/35_Graphs.html#fords-algorithm-bellman-ford-algorithm",
    "title": "Graphs",
    "section": "Ford’s Algorithm (Bellman-Ford algorithm)",
    "text": "Ford’s Algorithm (Bellman-Ford algorithm)\nDijkstra’s Algorithm does not work if some weights are negative.\nTo solve this problem, a label-correcting algorithm can be used.\nFord’s algorithm is an example.\n\nDoes not permanently determine the shortest distance for any vertex until it processes the entire graph."
  },
  {
    "objectID": "content/35_Graphs.html#fords-algorithm-bellman-ford-algorithm-1",
    "href": "content/35_Graphs.html#fords-algorithm-bellman-ford-algorithm-1",
    "title": "Graphs",
    "section": "Ford’s Algorithm (Bellman-Ford algorithm)",
    "text": "Ford’s Algorithm (Bellman-Ford algorithm)\nfunction BellmanFord(list vertices, list edges, vertex source) is\n    distance := list of size n\n    predecessor := list of size n\n\n    for each vertex v in vertices do // Step 1: initialize graph\n        distance[v] := inf           // Init. vertex dist. to infinity\n        predecessor[v] := null       // Init. a null predecessor\n    \n    distance[source] := 0            // Dist. to self is zero.\n\n    repeat |V|−1 times:              // Step 2: relax edges repeatedly\n         for each edge(u, v) with weight w in edges do\n             if distance[u] + w &lt; distance[v] then\n                 distance[v] := distance[u] + w\n                 predecessor[v] := u\n\n                                     // Step 3: error if neg. weight cycle\n    if a negative-weight cycle exists, raise an error \n\n    return distance, predecessor\nSource: https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm"
  },
  {
    "objectID": "content/35_Graphs.html#general-label-correcting-algorithm",
    "href": "content/35_Graphs.html#general-label-correcting-algorithm",
    "title": "Graphs",
    "section": "General Label-Correcting Algorithm",
    "text": "General Label-Correcting Algorithm\nBased on Drozdek, Chapter 8.3\nfunction labelCorrectingAlgorithm (weighted simple digraph Graph, vertex first)\n    for all vertices v in Graph do      // Step 1: initialize graph\n        currDist[v] := inf              // Init. vertex dist. to infinity\n    currDist[first] := 0                // Dist. to self is zero\n    toBeChecked := {first}              // Set of vertices to check\n    while toBeChecked is not empty      // Step 2: relax edges repeatedly\n        v := a vertex in toBeChecked\n        remove v from toBeChecked\n        for all vertices u adjacent to v do\n            if currDist[u] &gt; currDist[v] + weight(edge(vu))\n                currDist[u] := currDist[v] + weight(edge(vu))\n                predecessor[u] := v\n                add u to toBeChecked if it is not there\nEfficiency hinges on the data structure used for toBeChecked"
  },
  {
    "objectID": "content/35_Graphs.html#all-to-all-shortest-pathsthe-wfi-algorithm",
    "href": "content/35_Graphs.html#all-to-all-shortest-pathsthe-wfi-algorithm",
    "title": "Graphs",
    "section": "All-To-All Shortest PathsThe WFI Algorithm",
    "text": "All-To-All Shortest PathsThe WFI Algorithm\nBased on Drozdek, Chapter 8.3\nfunction WFI(matrix weights):\n   for i := 1 to numberOfVertices do\n      for j := 1 to numberOfVertices do\n         for k := 1 to numberOfVertices do\n            if weights[j][k] &gt; weights[j][i] + weights[i][k] then\n               weights[j][k] := weights[j][i] + weights[i][k] then         \n   return weights\n\nweights is an adjacency matrix\nN-cubed efficiency…\nCan detect cycles if the diagonal of the weight matrix is initialized to infinity."
  },
  {
    "objectID": "content/35_Graphs.html#cycle-detection",
    "href": "content/35_Graphs.html#cycle-detection",
    "title": "Graphs",
    "section": "Cycle Detection",
    "text": "Cycle Detection\n\n\nWe often need to detect cycles in both directed and undirected graphs.\n\n\nDepth-First Traversal can be used for this."
  },
  {
    "objectID": "content/35_Graphs.html#cycle-detection-undirected-graphs",
    "href": "content/35_Graphs.html#cycle-detection-undirected-graphs",
    "title": "Graphs",
    "section": "Cycle Detection: Undirected Graphs",
    "text": "Cycle Detection: Undirected Graphs\nfunction detectCyclesDFS(vertex v, Graph G):\n    let static visited := {}   // Set of visited nodes (shared between calls)\n    let static edges   := {}   // Set of edges found (shared for all calls)\n    let has_cycle := false\n    insert v into visited\n    for each vertex u in G adjacent to v do\n        if u is not in visited:\n            has_cycle := has_cycle || detectCyclesDFS(u, G)\n        else if edge(u,v) is not in edges:\n            has_cycle := true  // cycle detected\n        add edge(u,v) to edges\n    return has_cycle"
  },
  {
    "objectID": "content/35_Graphs.html#cycle-detection-digraphs",
    "href": "content/35_Graphs.html#cycle-detection-digraphs",
    "title": "Graphs",
    "section": "Cycle Detection: Digraphs",
    "text": "Cycle Detection: Digraphs\nAlgorithm is a bit more complicated. Label vertices as “working” when we discover them, and as “finished” when we exhaust recursively traversing all adjacent nodes.\nIf we see a vertex labeled “working” for the second time, we have a cycle.\nfunction detectDigraphCyclesDFS(vertex v, Graph G):\n    let has_cycle := false\n    label[v] = WORKING         // label the current vertex as \"working\"\n    for each vertex u in G adjacent to v do\n        if u has no label yet:\n            has_cycle := has_cycle || detectDigraphCyclesDFS(u, G)\n        else if label[u] is not FINISHED\n            has_cycle := true  // cycle detected\n    num[v] = FINISHED          // mark v as \"finished\"\n    return has_cycle"
  },
  {
    "objectID": "content/35_Graphs.html#eulerian-graphs",
    "href": "content/35_Graphs.html#eulerian-graphs",
    "title": "Graphs",
    "section": "Eulerian Graphs",
    "text": "Eulerian Graphs\n(Euler is pronounced very much like “oiler”.)\n\nAn Eulerian trail is a path that includes all edges of the graph only once.\nAn Eulerian cycle is a cycle that is also an Eulerian trail.\nAn Eulerian graph is a graph that has an Eulerian cycle.\n\nA graph is Eulerian if every vertex is incident to an even number of edges."
  },
  {
    "objectID": "content/35_Graphs.html#finding-eulerian-cycles-fleurys-algorithm",
    "href": "content/35_Graphs.html#finding-eulerian-cycles-fleurys-algorithm",
    "title": "Graphs",
    "section": "Finding Eulerian Cycles : Fleury’s Algorithm",
    "text": "Finding Eulerian Cycles : Fleury’s Algorithm\n“Only take a bridge when there is no other path to take.”\nfunction FleuryAlgorithm(undirected graph G):\n    let success := false\n    let v := any vertex in G\n    let path := v\n    let untraversed := G\n    while v has untraversed edges\n        let e represent an edge to be determined later\n        if edge(v,u) is the only untraversed edge\n            e := edge(v,u)\n            remove v from untraversed\n        else e := edge(v,u) which is not a bridge in untraversed\n        path := path + u\n        remove e from untraversed\n        v := u\n    if untraversed has no edges\n        success := true\n    return success, path"
  },
  {
    "objectID": "content/35_Graphs.html#eularian-graph-and-cycle",
    "href": "content/35_Graphs.html#eularian-graph-and-cycle",
    "title": "Graphs",
    "section": "Eularian graph and cycle",
    "text": "Eularian graph and cycle\nDrozdek, Figure 8.34\n\n\n\n\nAn Eulerian graph\n\n\n\nEulerian Graph\n\n\n\nAn Eulerian path illustrated (numbers indicate traversal order from b)\n\n\n\nEulerian Path"
  },
  {
    "objectID": "content/35_Graphs.html#hamiltonian-graphs",
    "href": "content/35_Graphs.html#hamiltonian-graphs",
    "title": "Graphs",
    "section": "Hamiltonian Graphs",
    "text": "Hamiltonian Graphs\n\nA Hamiltonian cycle is a cycle that passes through all the vertices of the graph.\n\nA Hamiltonian graph is a graph that includes at least one Hamiltonian cycle.\nAll complete graphs are Hamiltonian.\n\nAs a consequence, an algorithm of first create a complete graph using false edges, then reducing it can be used to find Hamiltonian cycles in incomplete graphs.\n\n\n\n\nHamiltonian GraphImage: https://commons.wikimedia.org/wiki/File:Hamiltonian_path.svg"
  },
  {
    "objectID": "content/35_Graphs.html#the-traveling-salesman-problem-tsp",
    "href": "content/35_Graphs.html#the-traveling-salesman-problem-tsp",
    "title": "Graphs",
    "section": "The Traveling Salesman Problem (TSP)",
    "text": "The Traveling Salesman Problem (TSP)\nGiven a set of \\(n\\) cities, find the minimum length tour in which each city is visited exactly once, then you return home.\n\nThis is equivalent to finding the minimum Hamiltonian cycle.\nIf distances between each of the \\(n\\) cities are known, there are \\((n - 1)!\\) possible routes.\n\nEliminating reverse routes, you get \\(\\frac{(n - 1)!}{2}\\)\nClever algorithms can do it in a polynomial factor of \\(2^n\\) steps…\n\n\n\n\n\n\n\n\n\n \n\n\nGraphs"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heaps",
    "href": "content/33_Heaps_and_Heapsort.html#heaps",
    "title": "Heaps and HeapSort",
    "section": "Heaps",
    "text": "Heaps\nA heap is a kind of (usually binary) tree. They normally* come in two varieties:\n\nMin-Heaps always maintain the smallest value at the root.\nMax-Heaps always maintain the largest value at the root.\n\n\n\n*   There is also a more exotic heap called a “min-max-heap” that allows you to find the smallest and largest values in constant time, but we won’t consider that variation here."
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heaps-1",
    "href": "content/33_Heaps_and_Heapsort.html#heaps-1",
    "title": "Heaps and HeapSort",
    "section": "Heaps",
    "text": "Heaps\nIn order to be a Heap, the following properties must hold (a min heap is used as an example; for a max heap just reverse the comparison operator).\n\nThe empty tree is a heap.\nA non-empty tree is a heap if and only if the heap property is satisfied for all nodes in the tree."
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#the-heap-property",
    "href": "content/33_Heaps_and_Heapsort.html#the-heap-property",
    "title": "Heaps and HeapSort",
    "section": "The Heap Property",
    "text": "The Heap Property\nThe heap property, for any node in a tree, states:\n\nA node with no children satisfies the heap property.\nA node with one or more children satisfies the heap property if and only if:\n\n(for a min-heap) The subtree rooted at node \\(R\\) is a min-heap if each of \\(R\\)’s child subtrees are min-heaps and the values of each of \\(R\\)’s direct descendants (if they exist) are greater than or equal to the value at \\(R\\).\n(for a max-heap) The subtree rooted at node \\(R\\) is a max-heap if each of \\(R\\)’s child subtrees are max-heaps and the values of each of \\(R\\)’s direct descendants (if they exist) are less than or equal to the value at \\(R\\)."
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#binary-max-heap",
    "href": "content/33_Heaps_and_Heapsort.html#binary-max-heap",
    "title": "Heaps and HeapSort",
    "section": "Binary Max Heap",
    "text": "Binary Max Heap\n\nComplete Binary Max Heap"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#binary-min-heap",
    "href": "content/33_Heaps_and_Heapsort.html#binary-min-heap",
    "title": "Heaps and HeapSort",
    "section": "Binary Min Heap",
    "text": "Binary Min Heap\n\nComplete Binary Min Heap"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heap-convention",
    "href": "content/33_Heaps_and_Heapsort.html#heap-convention",
    "title": "Heaps and HeapSort",
    "section": "Heap Convention",
    "text": "Heap Convention\nIt is convention (not strictly a requirement) that heaps “fill in” at the leaf level from left-to-right, as shown in the image below.\n\nAll leaves are on the tree at level \\(h\\) or \\(h-1\\) where \\(h\\) is the tree height.\nThe tree is balanced.\nLeaves are added at level \\(h\\) from left-to-right.\n\n\nComplete Binary Max Heap"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heap-convention-1",
    "href": "content/33_Heaps_and_Heapsort.html#heap-convention-1",
    "title": "Heaps and HeapSort",
    "section": "Heap Convention",
    "text": "Heap Convention\nIt is convention (not strictly a requirement) that heaps “fill in” at the leaf level from left-to-right, as shown in the image below.\n\nAll leaves are on the tree at level \\(h\\) or \\(h-1\\) where \\(h\\) is the tree height.\nThe tree is balanced.\nLeaves are added at level \\(h\\) from left-to-right.\n\n\n\n\n\n\nComplete Binary Max Heap\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMax Heap in Array"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heap-convention-2",
    "href": "content/33_Heaps_and_Heapsort.html#heap-convention-2",
    "title": "Heaps and HeapSort",
    "section": "Heap Convention",
    "text": "Heap Convention\nThis allows us to make an easy representation of a heap in an array, by applying the following rules:\n\nThe first item in the array (index \\(0\\)) is the root.\nAn item at any index \\(i\\) can find its left-child at index \\(2i+1\\) and its right-child at index \\(2i+2\\).\n\nBy inverse relation, the parent of any node is at index \\((i-1)/2\\) using integer division.\n\n\n\nMax Heap in Array"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#inserting-into-a-heap",
    "href": "content/33_Heaps_and_Heapsort.html#inserting-into-a-heap",
    "title": "Heaps and HeapSort",
    "section": "Inserting Into a Heap",
    "text": "Inserting Into a Heap\nWhen inserting a new item in an existing heap, the item must be placed into a leaf, then the heap property must be restored.\n\nInsert at leaf\n\nfirst “empty” location in the array\n\nRestore Heap\n\n“Percolate up”\n\n\n\nMax Heap in Array"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#removing-from-a-heap",
    "href": "content/33_Heaps_and_Heapsort.html#removing-from-a-heap",
    "title": "Heaps and HeapSort",
    "section": "Removing From a Heap",
    "text": "Removing From a Heap\nWe generally only care about removing the item at the root of the heap.\n\nSince the heap is an array, this would open a “hole” at the beginning.\n\n“shifting” the entire array left would be expensive.\n\nInstead, the value of the last leaf is moved up to the root position, and then the heap property must be restored.\n\nThis re-heapify is a simple operation.\nUsually referred to as “sift-down”.\n\n\n\nMax Heap in Array"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heapify",
    "href": "content/33_Heaps_and_Heapsort.html#heapify",
    "title": "Heaps and HeapSort",
    "section": "Heapify",
    "text": "Heapify\nIf an array can be represented as a tree, then it should be possible to convert any arbitrary array to a min or max heap. We call this operation heapify.\n\nHow can we perform heapify?\n\nTop-down\nBottom-up"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heapify-1",
    "href": "content/33_Heaps_and_Heapsort.html#heapify-1",
    "title": "Heaps and HeapSort",
    "section": "Heapify",
    "text": "Heapify\nIf an array can be represented as a tree, then it should be possible to convert any arbitrary array to a min or max heap. We call this operation heapify.\n\nHow can we perform heapify?\n\nTop-down\n\nConstruct the heap by using the algorithm for insertion into an empty heap. (Can be performed in-place.)\n\nBottom-up"
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heapify-2",
    "href": "content/33_Heaps_and_Heapsort.html#heapify-2",
    "title": "Heaps and HeapSort",
    "section": "Heapify",
    "text": "Heapify\nIf an array can be represented as a tree, then it should be possible to convert any arbitrary array to a min or max heap. We call this operation heapify.\n\nHow can we perform heapify?\n\nTop-down\n\nConstruct the heap by using the algorithm for insertion into an empty heap. (Can be performed in-place.)\n\nBottom-up\n\nConstruct the heap by first making heaps from all of the subtrees (beginning at the leaves) and working toward the root."
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#uses-for-heaps",
    "href": "content/33_Heaps_and_Heapsort.html#uses-for-heaps",
    "title": "Heaps and HeapSort",
    "section": "Uses for Heaps",
    "text": "Uses for Heaps\n\nPriorty Queue\n\nMore space-efficient VS a linked-list Pri. Queue.\n\nAs the underlying data structure for Heapsort."
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heapsort",
    "href": "content/33_Heaps_and_Heapsort.html#heapsort",
    "title": "Heaps and HeapSort",
    "section": "Heapsort",
    "text": "Heapsort\n\nFirst the array must be made into a heap by running heapify.\n\nTraditionally a max heap is used.\n\nThen, the sort proceeds by taking advantage of the partial ordering provided by the heap property. On each “pass”\n\nThe maximum item is always at the top, so on each iteration, “remove” it by swapping it with the last element of the remaining heap.\n\nreduce the “size” of the heap by 1\n\nRestore the heap property by performing a sift-down from the root."
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heapsort-complexity",
    "href": "content/33_Heaps_and_Heapsort.html#heapsort-complexity",
    "title": "Heaps and HeapSort",
    "section": "Heapsort Complexity",
    "text": "Heapsort Complexity\n\nHeapify (bottom-up) takes \\(O(n)\\) steps.\n\n(top-down) takes \\(O(n\\lg(n))\\) steps.\n\nEach “pass” yields 1 value in the right place.\n\\(n\\) passes are required to sort all items.\nSift-Down takes \\(O(\\lg(n))\\) steps."
  },
  {
    "objectID": "content/33_Heaps_and_Heapsort.html#heapsort-complexity-1",
    "href": "content/33_Heaps_and_Heapsort.html#heapsort-complexity-1",
    "title": "Heaps and HeapSort",
    "section": "Heapsort Complexity",
    "text": "Heapsort Complexity\n\nHeapify (bottom-up) takes \\(O(n)\\) steps.\n\n(top-down) takes \\(O(n\\lg(n))\\) steps.\n\n(done once)\n\n\nEach “pass” yields 1 value in the right place.\n\\(n\\) passes are required to sort all items.\nSift-Down takes \\(O(\\lg(n))\\) steps. \nOverall: \\(O(n\\lg(n))\\)\n\n\n\n\n\n\n\n\n \n\n\nHeaps and HeapSort"
  },
  {
    "objectID": "content/31_Binary_Search_Trees.html#trees",
    "href": "content/31_Binary_Search_Trees.html#trees",
    "title": "Trees - Binary Search Trees",
    "section": "Trees",
    "text": "Trees\nIn the computer science sense, trees are simply non-linear linked structures where each node may link to two or more other nodes, in a hierarchical fashion.\n\nThe entry point into a tree is called the root.\nTrees are (usually) drawn “upside down”, with the root at the top.\nNormally, we don’t draw the null pointers when we draw a tree… but we must remember that they are there."
  },
  {
    "objectID": "content/31_Binary_Search_Trees.html#trees-1",
    "href": "content/31_Binary_Search_Trees.html#trees-1",
    "title": "Trees - Binary Search Trees",
    "section": "Trees",
    "text": "Trees\nWe use terms borrowed from family trees to describe the hierarchical relationships between nodes in CS trees. (parent, child, grandparent, sibling, etc.)\n\nInterior nodes – have at least one child\nLeaf nodes – have no children\nEdge - A non-null outgoing link from a node to its child node.\nHeight - Longest path along edges from root to any leaf, plus one.\n\n(The empty tree is height 0, a single node is height 1.)\n\nSubtree - any node in the tree, and all its descendants."
  },
  {
    "objectID": "content/31_Binary_Search_Trees.html#binary-trees",
    "href": "content/31_Binary_Search_Trees.html#binary-trees",
    "title": "Trees - Binary Search Trees",
    "section": "Binary Trees",
    "text": "Binary Trees\nA binary tree is a tree in which each node has up to two children.\n\nThese are the most common type\nEasy to design and conceptualize (and code)\nUseful in many contexts\nThe order of the values may or may not matter."
  },
  {
    "objectID": "content/31_Binary_Search_Trees.html#binary-search-trees-1",
    "href": "content/31_Binary_Search_Trees.html#binary-search-trees-1",
    "title": "Trees - Binary Search Trees",
    "section": "Binary Search Trees",
    "text": "Binary Search Trees\nBinary search trees are shaped by the order in which values are added to the container.\n\nOrder of value addition affects efficiency.\nConsider these different situations:\n\n“Random” arrival\nNon-random (partially ordered) arrival\nDiscuss best, average, worst case search time for each."
  },
  {
    "objectID": "content/31_Binary_Search_Trees.html#examples---build-algorithms-for-the-following",
    "href": "content/31_Binary_Search_Trees.html#examples---build-algorithms-for-the-following",
    "title": "Trees - Binary Search Trees",
    "section": "Examples - Build algorithms for the following:",
    "text": "Examples - Build algorithms for the following:\n\nAdd items\nSearch for items\nTraversals\n\nIn-order\npre-order\npost-order\n\nRemove items"
  },
  {
    "objectID": "content/31_Binary_Search_Trees.html#visualizations",
    "href": "content/31_Binary_Search_Trees.html#visualizations",
    "title": "Trees - Binary Search Trees",
    "section": "Visualizations",
    "text": "Visualizations\n\n\nhttps://www.cs.usfca.edu/~galles/visualization/BST.html\n\n\n\n\n\n\n\n \n\n\nTrees - Binary Search Trees"
  },
  {
    "objectID": "content/29_Skip_Lists.html#linked-list-efficiency",
    "href": "content/29_Skip_Lists.html#linked-list-efficiency",
    "title": "Skip Lists",
    "section": "Linked List Efficiency",
    "text": "Linked List Efficiency\nHow efficient is a linked list?\n\n\n\nAdding/removing items\n\nat Head\nat Tail\nin-order\n\nFinding (searching) items\n\nOrdered list?\nUn-ordered list?\n\nTraversal"
  },
  {
    "objectID": "content/29_Skip_Lists.html#what-about-binary-search",
    "href": "content/29_Skip_Lists.html#what-about-binary-search",
    "title": "Skip Lists",
    "section": "What About Binary Search?",
    "text": "What About Binary Search?\nRecall how the binary search algorithm removed the complexity from searching an (ordered) array…\nWhat if we could do some kind of non-sequential search on a linked list?\n\n\nA special kind of linked list that allows just such a search is called a skip list ."
  },
  {
    "objectID": "content/29_Skip_Lists.html#skip-list",
    "href": "content/29_Skip_Lists.html#skip-list",
    "title": "Skip Lists",
    "section": "Skip List",
    "text": "Skip List\nBy making different nodes hold different numbers of pointers, you can search non-sequentially:\n\nPerfect Skip List"
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#redefining-base-class-methods",
    "href": "content/27_virtual_and_polymorphism.html#redefining-base-class-methods",
    "title": "Virtual Methods and Polymorphism",
    "section": "Redefining Base Class Methods",
    "text": "Redefining Base Class Methods\n\nA method is said to be redefined in a derived class when it has the same name (and perhaps parameter list) as a method in the base class.\n\nThis is not the same thing as overloading.\n\nBase class objects use the base class method… derived class objects use the derived class method."
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#problem-with-redefining",
    "href": "content/27_virtual_and_polymorphism.html#problem-with-redefining",
    "title": "Virtual Methods and Polymorphism",
    "section": "Problem with Redefining",
    "text": "Problem with Redefining\nConsider this situation:\n\nClass BaseClass defines methods x() and y(). x() calls y().\nClass DerivedClass inherits from BaseClass and redefines method y().\nAn object D of class DerivedClass is created and method x() is called.\nWhen x() is called, which y() is used; the one defined in BaseClass or the the redefined one in DerivedClass?"
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#problem-with-redefining-1",
    "href": "content/27_virtual_and_polymorphism.html#problem-with-redefining-1",
    "title": "Virtual Methods and Polymorphism",
    "section": "Problem with Redefining",
    "text": "Problem with Redefining\nAnswer to the riddle:\n\nThe BASE class’s y() method is called!\n\nThis isn’t what you want…\nbut it should be what you expect…\n\n\n\n\n\nFrom x() in the base class’s point-of-view (at compile time), the only available y() is its own.\n\n\n\n\nCompiler binds the method call in x() to the base class y() at compile time… Once it’s done, it’s done.\n\n\n\n\nThis is called static binding"
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#class-hierarchies",
    "href": "content/27_virtual_and_polymorphism.html#class-hierarchies",
    "title": "Virtual Methods and Polymorphism",
    "section": "Class Hierarchies",
    "text": "Class Hierarchies\n\nA derived class can also be used as a base class.\nThis (of course) complicates issues like method redefining…"
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#virtual-methods",
    "href": "content/27_virtual_and_polymorphism.html#virtual-methods",
    "title": "Virtual Methods and Polymorphism",
    "section": "Virtual Methods",
    "text": "Virtual Methods\nVirtual Method: a method in a base class that expects to be redefined in derived classes.\n\nDefined with keyword virtual\n\nvirtual void y();\n\nAllows dynamic binding – method name bound at runtime to the corresponding code. ( as opposed to static binding )\n\nDynamic binding is based on the type of the object actually initiating the call at runtime."
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#polymorphism",
    "href": "content/27_virtual_and_polymorphism.html#polymorphism",
    "title": "Virtual Methods and Polymorphism",
    "section": "Polymorphism",
    "text": "Polymorphism\nA pointer of the base-class type may be “pointed” to a derived class object.\n\nRemember the “is-a” relationship…\n\nBase-class pointers can only access members defined in the base class.\nThis won’t work in reverse!\n\nWhen the base class uses dynamic binding…\n\nBase class pointer to derived class object behaves appropriately for the derived class.\nThis is called polymorphism.\n\n\n\n\n\nPolymorphism requires a pointer or reference."
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#redefining-vs-overriding",
    "href": "content/27_virtual_and_polymorphism.html#redefining-vs-overriding",
    "title": "Virtual Methods and Polymorphism",
    "section": "Redefining VS Overriding",
    "text": "Redefining VS Overriding\nRedefining: refers to statically-bound methods.\nOverriding: refers to dynamically-bound methods.\n\n\nRedefined methods do not exhibit polymorphic behavior\nOverridden methods do exhibit polymorphic behavior."
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#when-to-use-virtual",
    "href": "content/27_virtual_and_polymorphism.html#when-to-use-virtual",
    "title": "Virtual Methods and Polymorphism",
    "section": "When to Use virtual",
    "text": "When to Use virtual\nWhenever you think a derived class might want to override a method!\n\nYes, there is a performance cost…\n\nDynamic binding requires a runtime “vtable” - a look-up table where the virtual function mapping is determined.\n\nDestructors – It is (almost) always a good idea to make these virtual!\n\nIf a class might be used as a base class, it is recommended to make the destructor virtual."
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#pure-virtual-methods",
    "href": "content/27_virtual_and_polymorphism.html#pure-virtual-methods",
    "title": "Virtual Methods and Polymorphism",
    "section": "Pure virtual Methods",
    "text": "Pure virtual Methods\nPure virtual method: a method that is not implemented (at all) in the base class, and is thus required to be overridden in derived classes.\n\nCreated by using “assignment”-style syntax:\n\nvirtual void y() = 0;\n\nThe “= 0” tells the compiler “this is a pure virtual method—don’t expect an implementation”."
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#abstract-base-classes",
    "href": "content/27_virtual_and_polymorphism.html#abstract-base-classes",
    "title": "Virtual Methods and Polymorphism",
    "section": "Abstract Base Classes",
    "text": "Abstract Base Classes\nAbstract base class: a base class that contains at least one pure virtual method.\n\nUseful for factoring out common behavior from a family of objects.\n\nFor specifying a required common interface.\n\nYou cannot instantiate an object from an abstract base class.\nYou can create pointers to abstract base classes (useful for polymorphic behavior)."
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#multiple-inheritance",
    "href": "content/27_virtual_and_polymorphism.html#multiple-inheritance",
    "title": "Virtual Methods and Polymorphism",
    "section": "Multiple Inheritance",
    "text": "Multiple Inheritance\n\nMultiple base classes\nInherit from all base classes (may result in multiple attributes/methods with same name)\nScope resolution will be required.\n\n\nMultiple Inheritance"
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#example-students-and-faculty.",
    "href": "content/27_virtual_and_polymorphism.html#example-students-and-faculty.",
    "title": "Virtual Methods and Polymorphism",
    "section": "Example: Students and faculty.",
    "text": "Example: Students and faculty.\nclass Student{                 | class Faculty{\npublic:                        | public:\n    std::string   name;        |    std::string name;\n    unsigned long id;          |    double      salary;\n};                             | };\nNotice the overlap - both classes need a name (and maybe other things as well).\nGood programming practice would say we should “factor out” the common code…"
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#example-students-and-faculty.-1",
    "href": "content/27_virtual_and_polymorphism.html#example-students-and-faculty.-1",
    "title": "Virtual Methods and Polymorphism",
    "section": "Example: Students and faculty.",
    "text": "Example: Students and faculty.\nclass Person{\npublic:\n    std::string name;\n};\n\nclass Student : public Person{ | class Faculty : public Person{\npublic:                        | public:\n    unsigned long id;          |    double salary;\n};                             | };\nNow, we have the common code collected in a base class Person. Good!\n\n\nBut what if we want to add graduate assistants (GA’s)?\n\n\nA GA is a student who also has some responsibilities similar to faculty. Could we use multiple inheritance?"
  },
  {
    "objectID": "content/27_virtual_and_polymorphism.html#example-students-and-faculty.-2",
    "href": "content/27_virtual_and_polymorphism.html#example-students-and-faculty.-2",
    "title": "Virtual Methods and Polymorphism",
    "section": "Example: Students and faculty.",
    "text": "Example: Students and faculty.\nclass Person{\npublic:\n    std::string name;\n};\n\nclass Student : public Person{ | class Faculty : public Person{\npublic:                        | public:\n    unsigned long id;          |    double salary;\n};                             | };\n\nclass GA : public Student, public Faculty {\npublic:\n    std::vector&lt;std::string&gt; labs;\n};\n\n\nint main() {\n    GA ga1;\n    ga1.name = \"Alice\";  // Error!\n}"
  },
  {
    "objectID": "content/25_Class_Template.html#function-templates",
    "href": "content/25_Class_Template.html#function-templates",
    "title": "Templates and Generic Programming",
    "section": "Function Templates",
    "text": "Function Templates\nFunction templates provide a pattern for a function that can work with many types of data.\n\nWhen written, the data type specifiers are replaced with type parameters.\nWhen called, the compiler generates a function with actual data types that match those provided in the call.\n\nExample\ntemplate&lt;typename Numeric&gt;\nNumeric times10(Numeric num){\n     return 10 * num;\n}\n\n\n\nNumeric is the type parameter (it can be any valid identifier, but is usually capitalized (UpperCamelCase or sometimes ALL_CAPS) by convention.\n\n\n\n// Using the function:\nstd:: cout &lt;&lt; times10(3.14) &lt;&lt; '\\n';"
  },
  {
    "objectID": "content/25_Class_Template.html#function-template-notes",
    "href": "content/25_Class_Template.html#function-template-notes",
    "title": "Templates and Generic Programming",
    "section": "Function Template Notes",
    "text": "Function Template Notes\n\n\n\nMultiple type parameters can be defined.\n\nAll type parameters specified in template prefix must be used in the definition.\n\n\n\n\n\nFunction templates can be overloaded (as long as each overload has a unique signature)."
  },
  {
    "objectID": "content/25_Class_Template.html#function-template-notes-1",
    "href": "content/25_Class_Template.html#function-template-notes-1",
    "title": "Templates and Generic Programming",
    "section": "Function Template Notes",
    "text": "Function Template Notes\n\nA function template is just a pattern: No actual code is generated until the function is called.\n\nA function template uses no memory.\n\nWhen passing objects to a function template, the object must be able to behave in the way expected by the function.\n\nIf the function is expecting a number, your object must be able to behave like a number.\nYou can determine the requirements by examining operators and operations performed on the parameters.\nBe sure to document these requirements in your function documentation!"
  },
  {
    "objectID": "content/25_Class_Template.html#class-templates",
    "href": "content/25_Class_Template.html#class-templates",
    "title": "Templates and Generic Programming",
    "section": "Class Templates",
    "text": "Class Templates\nC++ class templates are used to create generic classes and abstract data types.\n\nOften used for “container types”.\n\nAllows writing a container once, re-using it for many types.\n\nType arguments are provided when an object of the class template type is created."
  },
  {
    "objectID": "content/25_Class_Template.html#class-template-notes",
    "href": "content/25_Class_Template.html#class-template-notes",
    "title": "Templates and Generic Programming",
    "section": "Class Template Notes",
    "text": "Class Template Notes\n\nAll references to the class as a type must include the type argument list.\n\nWhen declaring/instantiating objects\nWhenever scope resolution is required."
  },
  {
    "objectID": "content/25_Class_Template.html#implementation-note",
    "href": "content/25_Class_Template.html#implementation-note",
    "title": "Templates and Generic Programming",
    "section": "Implementation Note",
    "text": "Implementation Note\nTemplate libraries (classes, functions, methods) should be implemented in the header file. We do not split into .h/.cpp pairs as we would with non-template code.\nThis is the result of the fact that template code does not directly compile to any object representation.\nRemember that templates provide a pattern from which the compiler will generate the actual “code” and produce an object representation automatically."
  },
  {
    "objectID": "content/23_Linked_Lists.html#the-linked-list-adt",
    "href": "content/23_Linked_Lists.html#the-linked-list-adt",
    "title": "Linked Lists",
    "section": "The Linked List ADT",
    "text": "The Linked List ADT\n\nLinked list: set of data structures (nodes) that contain references to other data structures\n\nRelationship is linear: Each node references the next node (and sometimes the previous node).\n\nReferences may be addresses (pointers) or array indices\nNodes can be located anywhere in memory.\nData can be added/removed during execution.\n\n\nLinked List"
  },
  {
    "objectID": "content/23_Linked_Lists.html#singly-linked-lists",
    "href": "content/23_Linked_Lists.html#singly-linked-lists",
    "title": "Linked Lists",
    "section": "Singly-Linked Lists",
    "text": "Singly-Linked Lists\n\nCan grow or shrink as needed (unlike arrays).\n\n\n\n\nAdding at the end of a linked list.\n\n\n\nCan insert data between other nodes easily.\n\n\n\n\nAdding in the middle of a linked list."
  },
  {
    "objectID": "content/23_Linked_Lists.html#doubly-linked-lists",
    "href": "content/23_Linked_Lists.html#doubly-linked-lists",
    "title": "Linked Lists",
    "section": "Doubly-Linked Lists",
    "text": "Doubly-Linked Lists\nA doubly-linked list is a linked list in which the nodes support access to both the next and previous items in the list, allowing bidirectional traversal.\n\nDoubly-Linked List"
  },
  {
    "objectID": "content/21_Copy_Constructor.html#memberwise-assignment-in-initialization",
    "href": "content/21_Copy_Constructor.html#memberwise-assignment-in-initialization",
    "title": "Assignment, Copy Constructor",
    "section": "Memberwise Assignment in Initialization",
    "text": "Memberwise Assignment in Initialization\nWhat happens when you do:\nRectangle r1{3, 4};\nRectangle r2 = r1;  // what happens here?"
  },
  {
    "objectID": "content/21_Copy_Constructor.html#memberwise-assignment-in-initialization-1",
    "href": "content/21_Copy_Constructor.html#memberwise-assignment-in-initialization-1",
    "title": "Assignment, Copy Constructor",
    "section": "Memberwise Assignment in Initialization",
    "text": "Memberwise Assignment in Initialization\nWhat happens when you do:\nRectangle r1{3, 4};\nRectangle r2 = r1;  // This is _initialization_, not assignment!\nEach attribute in r2 receives a copy of the corresponding attribute in r1.\nBut, this time it isn’t actually assignment, even though it “looks like assignment”. It is actually initialization during construction, the same as:\nRectangle r2{r1};\nWhen can this be a problem???"
  },
  {
    "objectID": "content/21_Copy_Constructor.html#memberwise-assignment-1",
    "href": "content/21_Copy_Constructor.html#memberwise-assignment-1",
    "title": "Assignment, Copy Constructor",
    "section": "Memberwise Assignment",
    "text": "Memberwise Assignment\nWhen can this be a problem???\n\nPointers pointing outside the physical object are a problem.\nSystem resources (streams, etc.) are a problem.\nThe solution has two parts:\n\nOverloaded assignment operator\nCopy Constructor"
  },
  {
    "objectID": "content/21_Copy_Constructor.html#overloaded-assignment-operator-1",
    "href": "content/21_Copy_Constructor.html#overloaded-assignment-operator-1",
    "title": "Assignment, Copy Constructor",
    "section": "Overloaded Assignment Operator",
    "text": "Overloaded Assignment Operator\nMost operators in C++ can be overloaded to work with custom object types. The assignment operator is one of them.\nC++ operators are actually implemented as special operator functions (or methods). The symbols are just “syntactic sugar” to make our code easier to read. For example:\nx = y;  // Assume x and y are object types.\nThe statement above is converted to function notation by the compiler to the following equivalent statement:\nx.operator=(y);  // Assume x and y are object types."
  },
  {
    "objectID": "content/21_Copy_Constructor.html#overloaded-assignment-operator-2",
    "href": "content/21_Copy_Constructor.html#overloaded-assignment-operator-2",
    "title": "Assignment, Copy Constructor",
    "section": "Overloaded Assignment Operator",
    "text": "Overloaded Assignment Operator\nIf we create a method matching the prototype for the assignment operator, we can take control of how assignment happens for our object. This is necessary whenever the physical object and logical object differ. Here is the general prototype pattern:\nObjTypeName & operator=( const ObjTypeName& source );"
  },
  {
    "objectID": "content/21_Copy_Constructor.html#overloaded-assignment-operator-3",
    "href": "content/21_Copy_Constructor.html#overloaded-assignment-operator-3",
    "title": "Assignment, Copy Constructor",
    "section": "Overloaded Assignment Operator",
    "text": "Overloaded Assignment Operator\nExample with MyClass:\nMyClass{\n    public:\n    [...]\n        MyClass& operator=(const MyClass& source); // assignment op\n    [...]\n};\nThe implementation would just need to do whatever is necessary to make the current object a complete, independent copy of the source object. The current object is always the left-hand operand from the assignment statement. (Which means the current object is always the destination of the assignment.)"
  },
  {
    "objectID": "content/21_Copy_Constructor.html#copy-constructor-1",
    "href": "content/21_Copy_Constructor.html#copy-constructor-1",
    "title": "Assignment, Copy Constructor",
    "section": "Copy Constructor",
    "text": "Copy Constructor\n\nCommonly takes a const reference to an object of the same class as a parameter.\nMust take a reference, but might not always be const.\n\nMyClass{\n    public:\n        MyClass(const MyClass& orig); // copy c-tor\n    [...]\n};"
  },
  {
    "objectID": "content/21_Copy_Constructor.html#copy-constructor-2",
    "href": "content/21_Copy_Constructor.html#copy-constructor-2",
    "title": "Assignment, Copy Constructor",
    "section": "Copy Constructor",
    "text": "Copy Constructor\nMyClass{\n    public:\n        MyClass(const MyClass& orig); // copy c-tor\n    [...]\n};\n// - - - -\n// Implementation\nMyClass::MyClass(const MyClass& orig){\n    // Do whatever is necessary to make the current\n    // object a complete, independent copy of the \n    // `orig` object.\n}"
  },
  {
    "objectID": "content/21_Copy_Constructor.html#copy-constructor-dry-principle",
    "href": "content/21_Copy_Constructor.html#copy-constructor-dry-principle",
    "title": "Assignment, Copy Constructor",
    "section": "Copy Constructor: DRY Principle",
    "text": "Copy Constructor: DRY Principle\n\n“Don’t Repeat Yourself”\n\nThe copy constructor and the assignment operator perform nearly the same operation (both make an independent copy of the source object). It is common to see the copy c-tor implemented in terms of the assignment operator:\nMyClass{\n    public:\n        MyClass(const MyClass& orig);              // copy c-tor\n        MyClass& operator=(const MyClass& source); // assignment op\n    [...]\n};\n// - - - -\n// Copy c-tor Implementation\nMyClass::MyClass(const MyClass& orig){\n    *this = orig;\n}\n\n\n\n\n\n\n\n\n \n\n\nAssignment, Copy Constructor\n\n\n \n\n\n\nThe DRY Principle states: “Every piece of knowledge must have a single, unambiguous, authoritative representation within a system”."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#introduction",
    "href": "content/19_Classes_and_Objects.html#introduction",
    "title": "Classes and Objects",
    "section": "Introduction",
    "text": "Introduction\n\nProcedural (structured) Programming\n\nConcerned with processes (actions) that occur in a program.\nBasic unit of modularity is the function.\n\nObject-Oriented Programming (OOP)\n\nFocuses on the data (things) and the functions that operate on it.\nBasic unit of modularity is the class (or structure)."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#oop-central-concepts",
    "href": "content/19_Classes_and_Objects.html#oop-central-concepts",
    "title": "Classes and Objects",
    "section": "OOP Central Concepts",
    "text": "OOP Central Concepts\n\nEncapsulation\n\nBundling\nData / Implementation Hiding\n\nPrinciple of least privilege.\n\nPublic Interface\n\nClass Hierarchies (Inheritance)\n\nFactoring out common data/behavior.\nStandardizing a common (public) interface."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#oop-terminology",
    "href": "content/19_Classes_and_Objects.html#oop-terminology",
    "title": "Classes and Objects",
    "section": "OOP Terminology",
    "text": "OOP Terminology\n\n\nClass - Encapsulates data and functions that are related, essentially like a structure. Creates a new type.\n\nThe class is the blueprint describing the new type of thing.\n\nObject - an instance of a class.\n\nThe object is the real thing that is built by following the blueprint.\n\nAttributes - a class’s member data\nMethods - a class’s member functions\n\n\nWe will use class and struct somewhat interchangeably."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#format-of-a-class",
    "href": "content/19_Classes_and_Objects.html#format-of-a-class",
    "title": "Classes and Objects",
    "section": "Format of a Class",
    "text": "Format of a Class\n\n\nclass ClassName {\n    declaration;\n    declaration;\n};\n\n\nExample\n\n\nstruct Rectangle {\n    double length;\n    double width;\n    double area;\n};\n\nclass Rectangle {\n    public:\n        double length;\n        double width;\n        double area();\n};"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#access-specifiers",
    "href": "content/19_Classes_and_Objects.html#access-specifiers",
    "title": "Classes and Objects",
    "section": "Access Specifiers",
    "text": "Access Specifiers\n\n\npublic - Available both inside and outside the class definition.\nprivate - Only available inside the class definition.\nprotected - Similar to private (we’ll see this later).\n\n\n\nOrder doesn’t matter.\nDefault is private for class. (Default is public for struct.)\n\nThis is the only difference between class and struct in C++."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#methods",
    "href": "content/19_Classes_and_Objects.html#methods",
    "title": "Classes and Objects",
    "section": "Methods",
    "text": "Methods\n\nPrototype in class declaration\nDefinition usually in separate implementation file.\n\nMay also be in same file.\n\nScope resolution operator ( :: ) – used to establish ownership of an identifier\n\nMust be used when splitting method definitions from the class declaration.\n\nPrivate methods – what good are they?"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#separating-specification-and-implementation",
    "href": "content/19_Classes_and_Objects.html#separating-specification-and-implementation",
    "title": "Classes and Objects",
    "section": "Separating Specification and Implementation",
    "text": "Separating Specification and Implementation\n\nHeader files ( MyClass.h ) – place class specification (declaration) here\nImplementation file ( MyClass.cpp ) – implement methods here\n#include the header from the implementation file\nImplementation ( .cpp ) files can be compiled; header files cannot.\nNEVER #include a .cpp file!"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#include-guards",
    "href": "content/19_Classes_and_Objects.html#include-guards",
    "title": "Classes and Objects",
    "section": "Include Guards",
    "text": "Include Guards\n#ifndef RECTANGLE_H \n#define RECTANGLE_H \n\nclass Rectangle {\n    public:\n        double length;\n        double width;\n        double area() const;\n};\n\n#endif\nInclude Guards protect the definitions in a header file from being included more than once in a project."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#accessors-and-mutators",
    "href": "content/19_Classes_and_Objects.html#accessors-and-mutators",
    "title": "Classes and Objects",
    "section": "Accessors and Mutators",
    "text": "Accessors and Mutators\n\nProvides a way to safely access data members.\nPrinciple of least privilege.\nStale data (Avoid it!)\nAllows the class to disallow incorrect states."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#constructors",
    "href": "content/19_Classes_and_Objects.html#constructors",
    "title": "Classes and Objects",
    "section": "Constructors",
    "text": "Constructors\n\nAllow an object to be instantiated (created) in an already-working state.\n\nContrast this with the uninitialized state that regular data and structs begin with.\n\nConstructors do not have any return type.\nConstructors have the same name as the class.\nDefault constructor is a constructor that takes no parameters; used to create a “default” or “blank” object.\nConstructors may take parameters to allow initialization during instantiation.\nClasses do not always have a default constructor."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#constructors-1",
    "href": "content/19_Classes_and_Objects.html#constructors-1",
    "title": "Classes and Objects",
    "section": "Constructors",
    "text": "Constructors\n\nAllow an object to be instantiated (created) in an already-working state.\n\nContrast this with the uninitialized state that regular data and structs begin with.\n\nConstructors do not have any return type.\nConstructors have the same name as the class.\nDefault constructor is a constructor that takes no parameters; used to create a “default” or “blank” object.\nConstructors may take parameters to allow initialization during instantiation.\nClasses do not always have a default constructor."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#constructors-c-tors",
    "href": "content/19_Classes_and_Objects.html#constructors-c-tors",
    "title": "Classes and Objects",
    "section": "Constructors (c-tors)",
    "text": "Constructors (c-tors)\n\n\nA constructor’s job is to initialize attributes of the class:\n\n\nclass Rectangle {\n    public:\n        Rectangle (int l, int w){\n            length = l;\n            width  = w;\n        }\n        int length;\n        int width;\n};"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#c-tor-initialization-lists",
    "href": "content/19_Classes_and_Objects.html#c-tor-initialization-lists",
    "title": "Classes and Objects",
    "section": "c-tor initialization lists",
    "text": "c-tor initialization lists\n\nBut… there is another way to do it: Constructor initialization list\n\nCompact syntax for placing values into attributes in a constructor implementation.\nGuarantees initialization before body of constructor executes."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#destructors",
    "href": "content/19_Classes_and_Objects.html#destructors",
    "title": "Classes and Objects",
    "section": "Destructors",
    "text": "Destructors\n\nCalled automatically when object is destroyed\n\nEither by being deleted or going out of scope\n\nNamed same as class, but begins with ~\nNo return value, no parameters\nCannot be overloaded\n… when and why destructors are needed"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#inline-methods",
    "href": "content/19_Classes_and_Objects.html#inline-methods",
    "title": "Classes and Objects",
    "section": "Inline Methods",
    "text": "Inline Methods\n\nImplemented directly in class specification.\nSubstituted during compilation.\nSpeed VS executable size\n“inline all 1-liners”\ninline keyword\n\nCan be used to inline functions implemented separately."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#overloading",
    "href": "content/19_Classes_and_Objects.html#overloading",
    "title": "Classes and Objects",
    "section": "Overloading",
    "text": "Overloading\n\nConstructors may be overloaded\n\nRemember that there are consequences for default constructor\n\nMethods may be overloaded\nDestructors may NOT be overloaded"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#pointers-to-objects",
    "href": "content/19_Classes_and_Objects.html#pointers-to-objects",
    "title": "Classes and Objects",
    "section": "Pointers to Objects",
    "text": "Pointers to Objects\n\nUses same pointer notation\n“dot-notation” becomes “arrow-notation”:\nArrow operator ( -&gt; )\nDynamic allocation of objects is possible"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#uniform-initialization-syntax",
    "href": "content/19_Classes_and_Objects.html#uniform-initialization-syntax",
    "title": "Classes and Objects",
    "section": "Uniform Initialization Syntax",
    "text": "Uniform Initialization Syntax\n\n\n\nAdded in C++11\nAllows initialization of all types of variables with the same syntax.\nThe “old” syntax for each type still works, but consider using uniform syntax.\n\nSyntax:\nvariableType  variableName{argument1, argument2};\n\n\nExample:\nint       age{23};\nRectangle classroom{24, 30};\n// The following is an array - we will talk more about these soon:\ndouble    temperatures[]{78.8, 80.2, 92.4, 87.5, 95.3, 95.1, 92.8};"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#other-details",
    "href": "content/19_Classes_and_Objects.html#other-details",
    "title": "Classes and Objects",
    "section": "Other Details",
    "text": "Other Details\n\nTiming of constructors, destructors\nArrays of objects\n\nRequires default constructor …\n… unless initialization syntax is used.\n\nMay provide arguments only or constructor invocations."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#const-methods",
    "href": "content/19_Classes_and_Objects.html#const-methods",
    "title": "Classes and Objects",
    "section": "const methods",
    "text": "const methods\n\nIn classes / structures, a method can “promise” not to modify the state of the object.\n\nmeaning, values of attributes will not be modified\n\naccomplished by marking methods as const:\n\nclass Rectangle{\npublic:\n    int get_length() const;  // const method\n    //[... other code not shown ...]\nprivate:\n    int length = 0;\n    int width  = 0;\n};\nget_length() cannot modify the attributes (length and width).\n\nThis protection is often added to accessors, and should be added whenever possible.\n\nMutators cannot be const methods, since they need to change the state of the object.\n\n\n\n\n\n\n\n\n\n \n\n\nClasses and Objects"
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#dynamic-memory-notes",
    "href": "content/17_Dynamic_Memory.html#dynamic-memory-notes",
    "title": "Dynamic Memory",
    "section": "Dynamic Memory Notes",
    "text": "Dynamic Memory Notes\n\n\nnew allocates memory from a pool of free memory known as the free store (or more commonly, “heap”).\n\nThe heap is a limited resource.\n\nThe pointer returned from the new operation is the only “link” you have to the heap-allocated memory.\n\nThe “owner” of this pointer has the responsibility to make sure the memory is eventually deleted.\n\nIf you lose the pointer, you’ve leaked the memory!\nYou may transfer ownership to another part of the program by passing the pointer.\n\n\n\n\nConceptual memory layout with stack and heap."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#dynamic-arrays",
    "href": "content/17_Dynamic_Memory.html#dynamic-arrays",
    "title": "Dynamic Memory",
    "section": "Dynamic Arrays",
    "text": "Dynamic Arrays\n\n\n\nNormal C++ arrays cannot be sized at runtime. This is a severe limitation.\n\n\n\n\nEither we over-allocate, which wastes space…\nOr we place a strict limit on the ability of the program’s data to “grow”.\n\nWith dynamic memory allocation, a variable can be used to determine the size of an array at runtime.\n\n\nThis gives us the ability to write programs that “adapt” to the size of the data."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#dynamic-array-notes",
    "href": "content/17_Dynamic_Memory.html#dynamic-array-notes",
    "title": "Dynamic Memory",
    "section": "Dynamic Array Notes",
    "text": "Dynamic Array Notes\n\n\nNote the different new and delete operators for arrays:\n\n\nint size = 10;\nint* a = new int[size];   // new array\n// [...]\ndelete [] a;              // delete array\na = nullptr;\n\n\n\nnew Array Syntax\n\nnew  type[size]\n\n\n\n\n\ndelete Array Syntax\n\ndelete []  ptr"
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#what-if-something-goes-wrong",
    "href": "content/17_Dynamic_Memory.html#what-if-something-goes-wrong",
    "title": "Dynamic Memory",
    "section": "What if something goes wrong?",
    "text": "What if something goes wrong?\n\nAn exception is thrown and the program will terminate if there is not enough free memory to complete the request.\nOr, you can use the (std::nothrow) version:\n\nint *xPtr = new(std::nothrow) int;\n\n\nIn this case, test that the address returned isn’t nullptr (nullptr will indicate failure).\n\n\nEx:   if(xPtr == nullptr)   // failed"
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#dynamic-memory-summary",
    "href": "content/17_Dynamic_Memory.html#dynamic-memory-summary",
    "title": "Dynamic Memory",
    "section": "Dynamic Memory Summary",
    "text": "Dynamic Memory Summary\n\nIf you “new” it, you “delete” it!\nnew and delete operations may or may not be in the same scope\n\nThis is a feature: It is one way to make data survive going out of scope.\n\nFailure to delete == memory leak!\nThis is what destructors are good at!\n\nObjects that do “new” operations will require a destructor."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#modern-c-smart-pointers",
    "href": "content/17_Dynamic_Memory.html#modern-c-smart-pointers",
    "title": "Dynamic Memory",
    "section": "Modern C++ Smart Pointers",
    "text": "Modern C++ Smart Pointers\nC++11 introduced “smart pointers”, which are really objects that are used to wrap a raw pointer and provide more automatic management of resources “owned” by the pointer.\n\n\n\nThree kinds of smart pointer in C++11:\n\nunique_ptr - used for exclusive ownership\nshared_ptr - used for shared ownership\nweak_ptr - a non-owning reference to a shared_ptr that can be upgraded to a shared_ptr.\n\n\n\nRequires the header &lt;memory&gt;"
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#unique_ptr",
    "href": "content/17_Dynamic_Memory.html#unique_ptr",
    "title": "Dynamic Memory",
    "section": "unique_ptr",
    "text": "unique_ptr\nA unique_ptr retains sole ownership of an object, and destroys the object when the unique_ptr goes out of scope.\n\nExample\nint main(){   \n   unique_ptr&lt;int&gt; ptr{ new int }; // allocate & take ownership\n   *ptr = 99;                      // place 99 at ptr\n   std::cout &lt;&lt; *ptr &lt;&lt; \"\\n\";      // print value at ptr (99)\n   return 0;                       // frees memory as ptr leaves\n}                                  // its local scope\n\nYou must tell the unique_ptr what type of data it will point to.\n\nThe part in the angle-brackets is called a template type argument\n\nYou must initialize the unique_ptr to contain a pointer to a dynamically-allocated object."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#unique_ptr-to-array",
    "href": "content/17_Dynamic_Memory.html#unique_ptr-to-array",
    "title": "Dynamic Memory",
    "section": "unique_ptr to Array",
    "text": "unique_ptr to Array\nint main(){\n    int n_scores;                           // size\n    std::cout &lt;&lt; \"Enter number of scores: \";\n    std::cin  &gt;&gt; n_scores;\n\n    // allocate array and take ownership with `scores`:\n    std::unique_ptr&lt;double[]&gt; scores{ new double[n_scores] };\n\n    for(int i = 0; i &lt; n_scores; i++){\n        std::cout &lt;&lt; \"Enter score \" &lt;&lt; (i+1) &lt;&lt; \": \";\n        std::cin  &gt;&gt; scores[i];\n    }\n    // [...]    Use the data for something interesting...\n    return 0;   // scores gets de-allocated automatically\n}\n\nPay attention to the type argument &lt;double[]&gt; : Type &lt;double*&gt; will not work here."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#alternative-construct-with-make_unique",
    "href": "content/17_Dynamic_Memory.html#alternative-construct-with-make_unique",
    "title": "Dynamic Memory",
    "section": "Alternative: Construct with make_unique():",
    "text": "Alternative: Construct with make_unique():\nModern C++ idioms seem to be pushing toward using the make_unique() function (and make_shared() for shared_ptr):\n\n\nint main(){\n    unique_ptr&lt;int&gt; ptr{ std::make_unique(99) }; // allocate and init\n    std::cout &lt;&lt; *ptr &lt;&lt; \"\\n\";                   // print value at ptr (99)\n    \n    int n_scores;                                // size for array\n    std::cout &lt;&lt; \"Enter number of scores: \";\n    std::cin  &gt;&gt; n_scores;\n\n    // allocate array and take ownership with `scores`:\n    std::unique_ptr&lt;double[]&gt; scores{ std::make_unique&lt;double[]&gt;(n_scores) };\n\n    for(int i = 0; i &lt; n_scores; i++){\n        std::cout &lt;&lt; \"Enter score \" &lt;&lt; (i+1) &lt;&lt; \": \";\n        std::cin  &gt;&gt; scores[i];\n    }\n    // [...]    Use the data for something interesting...\n    return 0;   // scores and ptr are de-allocated automatically\n}"
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#putting-it-together-with-auto",
    "href": "content/17_Dynamic_Memory.html#putting-it-together-with-auto",
    "title": "Dynamic Memory",
    "section": "Putting it together with auto:",
    "text": "Putting it together with auto:\n\n\n\nint main(){\n    auto ptr{ std::make_unique(99) };         // allocate and init\n    std::cout &lt;&lt; *ptr &lt;&lt; \"\\n\";                // print value at ptr (99)\n    \n    int n_scores;                             // size for array\n    std::cout &lt;&lt; \"Enter number of scores: \";\n    std::cin  &gt;&gt; n_scores;\n\n    // allocate array and take ownership with `scores`:\n    auto scores{ std::make_unique&lt;double[]&gt;(n_scores) };\n\n    for(int i = 0; i &lt; n_scores; i++){\n        std::cout &lt;&lt; \"Enter score \" &lt;&lt; (i+1) &lt;&lt; \": \";\n        std::cin  &gt;&gt; scores[i];\n    }\n    // [...]    Use the data for something interesting...\n    return 0;   // scores and ptr are de-allocated automatically\n}\n\nChoose the version you think is easier to understand.\n\n\n\n\n\n\n\n \n\n\nDynamic Memory"
  },
  {
    "objectID": "content/15_Structures.html#enum",
    "href": "content/15_Structures.html#enum",
    "title": "Structures",
    "section": "enum",
    "text": "enum\nEnumerated Type\n\nAllows the programmer to specify mnemonic literals.\nLow-level, not very flexible.\nExample:\n\nenum WorkDayAbr = {mon, tue, wed, thr, fri};\n\n//... later in the program ...\n\nWorkDayAbr today = mon;"
  },
  {
    "objectID": "content/15_Structures.html#modern-c-prefers-scoped-enum",
    "href": "content/15_Structures.html#modern-c-prefers-scoped-enum",
    "title": "Structures",
    "section": "Modern C++ prefers “scoped enum”",
    "text": "Modern C++ prefers “scoped enum”\nenum class WorkDayAbr{ mon, tue, wed,   // struct or class\n                       thr, fri };\n-----------------------------------------\nint rain[5]     {5, 15, 35, 95, 10};\nstring names[5] {\"Monday\", \"Tuesday\", \"Wednesday\", \n                 \"Thursday\",\"Friday\"};\nfor (int i = static_cast&lt;int&gt;(WorkDayAbr::mon);\n     i &lt;= static_cast&lt;int&gt;(WorkDayAbr::fri); ++i) {\n    cout &lt;&lt; \"Rain chance for \" &lt;&lt; names[i] &lt;&lt; \": \" &lt;&lt; rain[i] &lt;&lt; endl;\n}\n\nenum values do not implicitly cast to int - you have to static_cast.\nYou can define your own operators (like ++) to make it easier to work with these…\nCore Guidelines: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-enum"
  },
  {
    "objectID": "content/15_Structures.html#structures",
    "href": "content/15_Structures.html#structures",
    "title": "Structures",
    "section": "Structures",
    "text": "Structures\nStructures are used to “glue” several other types together to create a new type.\nThis is ideal when there is a lot of “related” data that represents a single “thing” in your code.\n\nStructures specify attributes, and potentially also behaviors.\nThe keyword struct is used to define a structure:\n\nstruct Circle {\n   int x;\n   int y;\n   double radius;\n};  // Notice the semicolon!"
  },
  {
    "objectID": "content/15_Structures.html#structures-and-functions",
    "href": "content/15_Structures.html#structures-and-functions",
    "title": "Structures",
    "section": "Structures and Functions",
    "text": "Structures and Functions\nThe previous function passed a structure to the printCircle() function by value.\n\nIs this a good idea?\nConsider passing by (const) reference instead:\n\nvoid printCircle(const Circle& c){\n    cout &lt;&lt; \"(\"      &lt;&lt; c.x\n         &lt;&lt; \",\"      &lt;&lt; c.y\n         &lt;&lt; \") r = \" &lt;&lt; c.radius;\n}\nAnd if you need the parameter to be changed by the function, use non-const reference:\nvoid readCircle(Circle& c){\n    cout &lt;&lt; \"Enter x and y: \";\n    cin  &gt;&gt; c.x &gt;&gt; c.y;\n    cout &lt;&lt; \"Enter radius:  \";\n    cin  &gt;&gt; c.radius;\n}"
  },
  {
    "objectID": "content/15_Structures.html#parallel-arrays-vs-structures",
    "href": "content/15_Structures.html#parallel-arrays-vs-structures",
    "title": "Structures",
    "section": "Parallel Arrays VS Structures",
    "text": "Parallel Arrays VS Structures\n\nParallel arrays store related data by common indexing.\nStructures store related data in a single variable…\n\nAn array of structures can be used in place of parallel arrays.\n\nWhen should you choose structures?\n\nHow closely are the data related?\nDo the items really “belong” to the same thing?\n\nIf so, structures would make sense\n\n\nPassing a single array VS passing several arrays\n\nEase of use is always a factor!"
  },
  {
    "objectID": "content/15_Structures.html#what-about-operators",
    "href": "content/15_Structures.html#what-about-operators",
    "title": "Structures",
    "section": "What About Operators?",
    "text": "What About Operators?\n\n\n\n\n\n\nA look ahead\n\n\nYou can also overload operators (and other functions) so that they will work with your new type:\n\n\n\nstd::ostream& operator&lt;&lt; (std::ostream& outstr,\n                          const Circle& c) {\n    outstr &lt;&lt; \"(\"      &lt;&lt; c.x\n           &lt;&lt; \",\"      &lt;&lt; c.y\n           &lt;&lt; \") r = \" &lt;&lt; c.radius;\n    return outstr;\n}\n\n\nMore info on operator overloading is coming soon … or read ahead to Chapter 14, or search online."
  },
  {
    "objectID": "content/15_Structures.html#assignment",
    "href": "content/15_Structures.html#assignment",
    "title": "Structures",
    "section": "Assignment",
    "text": "Assignment\nWhat happens when you assign one structure to another directly?\n\nThe assignment operator ( = ) makes a bit-wise copy of the entire structure’s contents.\n\n“Plain old data” is copied exactly correctly.\nArrays are encapsulated in the structure; they get copied as well!\n\nContrast with how arrays are usually treated…\n\n\n\n\n\nPointers can cause trouble!\n\nThe copy applies to the pointer only, not the item being pointed to.\n\nResources can cause trouble!\n\nNever make a copy of something like an open stream."
  },
  {
    "objectID": "content/15_Structures.html#initial-values",
    "href": "content/15_Structures.html#initial-values",
    "title": "Structures",
    "section": "Initial Values",
    "text": "Initial Values\nC++11 added the ability to include initialization in a structure definition:\nstruct Person {\n    int    age   = 0;    // initialize to 0\n    string name;\n};\n\nHere, inline member initialization is used to provide initial values for age.\n\n\nPerson p3{20, \"Cassandra\"}; // only if -std=c++14 or later\n\n\nC++ version warning:\nIf you specify initializers, you will not be able to use uniform initializer syntax with your new type in C++11, but in C++14 and afterward, it is OK."
  },
  {
    "objectID": "content/13_Input_and_Output.html#input-streams",
    "href": "content/13_Input_and_Output.html#input-streams",
    "title": "Input and Output",
    "section": "Input Streams",
    "text": "Input Streams\nAn input stream brings information from the outside world into the running program.\n\nThe standard input stream is named std::cin\n\nOften shortened to cin (add using std::cin after the include)\nWe will refer to the standard input stream as cin in discussion\n\nInput streams work together with the stream extraction operator ( &gt;&gt; ).\n\n&gt;&gt; extracts data from the stream (on its left) and stores the data in the variable on its right."
  },
  {
    "objectID": "content/13_Input_and_Output.html#stream-extraction---details",
    "href": "content/13_Input_and_Output.html#stream-extraction---details",
    "title": "Input and Output",
    "section": "Stream Extraction - details",
    "text": "Stream Extraction - details\n\nThe type of the variable that is intended to store the data must match the type of the data being extracted.\n\nThe extraction may fail if this is not the case.\n\nThe stream extraction operator is whitespace delimited, meaning that it will read the next series of non-whitespace characters in the input stream and convert those to the required type.\n\nThis means you cannot read anything containing spaces using &gt;&gt;."
  },
  {
    "objectID": "content/13_Input_and_Output.html#streams-plural",
    "href": "content/13_Input_and_Output.html#streams-plural",
    "title": "Input and Output",
    "section": "Streams: Plural",
    "text": "Streams: Plural\nYou have used the standard input stream and the standard output stream; C++ provides the opportunity to create other streams as well.\n\nAll input streams support the same operations.\nAll output streams support the same operations.\nSo, if you can use std::cin and std::cout, you can use any stream!"
  },
  {
    "objectID": "content/13_Input_and_Output.html#getline",
    "href": "content/13_Input_and_Output.html#getline",
    "title": "Input and Output",
    "section": "getline()",
    "text": "getline()\nIn order to read a std::string that may contain whitespace from an input stream, the getline() function should be used:\nstd::string full_name;\n\nstd::cout &lt;&lt; \"Enter your first and last name: \";\ngetline(std::cin, full_name);\n\nstd::cout &lt;&lt; \"Hello, \" &lt;&lt; full_name &lt;&lt; \"!\\n\";\ngetline() will read an entire line of user input (until the &lt;ENTER&gt; key is pressed). The syntax is:  getline( source_stream , destination_string ) \nWhere source stream is any input stream and destination string is a variable of type std::string."
  },
  {
    "objectID": "content/13_Input_and_Output.html#cin.get",
    "href": "content/13_Input_and_Output.html#cin.get",
    "title": "Input and Output",
    "section": "cin.get()",
    "text": "cin.get()\nThe cin.get() function can be used to read a single character, which may be whitespace, from the standard input stream.\nExample\nchar ch;\n// Reading the &lt;ENTER&gt; key with `&gt;&gt;` alone is difficult... \n// So, use `get()`:\nstd::cout &lt;&lt; \"Press &lt;ENTER&gt; to continue...\";\nstd::cin.get(ch); // Will wait for the enter key, then continue.\nThe get() function also works with other streams, in general the syntax is:  stream.get(character_var)"
  },
  {
    "objectID": "content/13_Input_and_Output.html#in-case-the-stream-goes-bad",
    "href": "content/13_Input_and_Output.html#in-case-the-stream-goes-bad",
    "title": "Input and Output",
    "section": "In case the stream goes bad…",
    "text": "In case the stream goes bad…\nIf you are working with an open stream, several things can cause the stream to no longer be in the “good” state. The most common are:\n\nFailure of stream extraction operator to convert the apparent type it “sees” to the type requested on its right-hand side.\nEnd-of-file (or end of stream) encountered during a “read” operation.\n\nIn these cases you may be able to remedy the problem – perhaps by removing unwanted characters from the stream with ignore(), or by moving the stream position “earlier” in the stream in case of EOF – then resume operation. The clear() method will help with this by clearing the stream’s state flags:\nstd::cin.clear();  // clears the state flags on `cin`"
  },
  {
    "objectID": "content/13_Input_and_Output.html#files-1",
    "href": "content/13_Input_and_Output.html#files-1",
    "title": "Input and Output",
    "section": "Files",
    "text": "Files\nTo work with files, start by including the &lt;fstream&gt; library.\n\nWe will be working with files in text mode, meaning the contents are encoded as plain ASCII text.\n\nOur interaction with the file will “feel” exactly the same as interacting with a user/screen.\n\nYou can also access a file in pure binary mode as well. (later)"
  },
  {
    "objectID": "content/13_Input_and_Output.html#file-operations",
    "href": "content/13_Input_and_Output.html#file-operations",
    "title": "Input and Output",
    "section": "File Operations",
    "text": "File Operations\nWorking with files will involve the following series of high-level steps:\n\nOpen the file\n\nThis associates the file name with the physical file, and initializes a stream to/from the file.\n\nRead or write data from/to the file\n\nThe file can be read/written as a stream - just like any other stream.\n\nClose the file\n\nThis allows the Operating System to release resources associated with the file, and flush buffers."
  },
  {
    "objectID": "content/13_Input_and_Output.html#output-file-streams",
    "href": "content/13_Input_and_Output.html#output-file-streams",
    "title": "Input and Output",
    "section": "Output File Streams",
    "text": "Output File Streams\n\nCreate a std::ofstream file stream object and use it to open and manipulate the file:\n\ndouble value1 = 4.4, value2 = 3.8;       \nstd::ofstream fout;             // declare a stream\nfout.open(\"my_input_file.txt\"); // open the file\nfout &lt;&lt; value1                  // insert values\n     &lt;&lt; \"\\n\"                    // separated on\n     &lt;&lt; value2;                 // two lines\nfout.close();                   // close the file"
  },
  {
    "objectID": "content/13_Input_and_Output.html#input-file-streams",
    "href": "content/13_Input_and_Output.html#input-file-streams",
    "title": "Input and Output",
    "section": "Input File Streams",
    "text": "Input File Streams\n\nCreate a std::ifstream file stream object and use it to open and manipulate the file:\n\ndouble value1, value2;        \nstd::ifstream fin;             // declare a stream\nfin.open(\"my_input_file.txt\"); // open the file\nfin &gt;&gt; value1 &gt;&gt; value2;       // read some values\nfin.close();                   // close the file\nstd::cout &lt;&lt; value1 &lt;&lt; \", \" &lt;&lt; value2 &lt;&lt; \"\\n\";"
  },
  {
    "objectID": "content/13_Input_and_Output.html#alternatives",
    "href": "content/13_Input_and_Output.html#alternatives",
    "title": "Input and Output",
    "section": "Alternatives",
    "text": "Alternatives\n\nYou can also declare and open in one line:\n\nstd::ifstream fin{\"my_input_file.txt\"};\n\nA std::fstream object can do either input or output – or both, but you must specify the open mode:\n\nstd::fstream fp;"
  },
  {
    "objectID": "content/13_Input_and_Output.html#open-modes",
    "href": "content/13_Input_and_Output.html#open-modes",
    "title": "Input and Output",
    "section": "Open Modes",
    "text": "Open Modes\n\n\n\nOpen Mode       Description\n---------------------------------------------\nstd:: ios::in   Input mode (file must exist)\nstd:: ios::out  Output mode (file will be \n                created, if it exists, it will\n                be overwritten)\nstd:: ios::app  Use with ios::out to append \n                to the end of an output file.\n\n\n\nThere are other modes as well, but they are not of interest to us at this time."
  },
  {
    "objectID": "content/13_Input_and_Output.html#file-open-failures",
    "href": "content/13_Input_and_Output.html#file-open-failures",
    "title": "Input and Output",
    "section": "File Open Failures",
    "text": "File Open Failures\n\nOpening an input file may fail if:\n\nThe file does not exist, or is misnamed.\nYou do not have permission to read the file.\nAll OS file resources are in use.\n\nOpening an output file may fail if:\n\nThe file exists, but you do not have permission to overwrite it.\nYou do not have permission to write in the destination directory.\nAll OS file resources are in use."
  },
  {
    "objectID": "content/13_Input_and_Output.html#testing-for-file-open-success",
    "href": "content/13_Input_and_Output.html#testing-for-file-open-success",
    "title": "Input and Output",
    "section": "Testing for File Open Success",
    "text": "Testing for File Open Success\nFile streams support a function called is_open() that will return true if the file was opened successfully. This function can be used to check for a failure to open.\nWe will cover if statements soon, but here is a sneak peek:\nstd::ifstream fin;                         \nfin.open(\"my_input_file.txt\");             \nif( !fin.is_open() ){                      \n    std::cout &lt;&lt; \"Failed to open file.\\n\"; \n    exit(1);                               \n}"
  },
  {
    "objectID": "content/11_Pointers.html#addresses-and-data",
    "href": "content/11_Pointers.html#addresses-and-data",
    "title": "Pointers",
    "section": "Addresses and Data",
    "text": "Addresses and Data\nEvery variable in a program is stored at a unique memory address.\n\n\nThe unary & is the address operator; the address operator retrieves the address of its operand:\n\n\nint x = 42;\n// Print out the address at which x is stored:\nstd::cout &lt;&lt; &x &lt;&lt; \"\\n\";\n\n\nWe don’t usually care about the address ourselves, and our users wouldn’t care either. So, printing it to the screen is only useful as a learning exercise. But what we do care about is what we can do with the address of a variable. Read on…"
  },
  {
    "objectID": "content/11_Pointers.html#pointers",
    "href": "content/11_Pointers.html#pointers",
    "title": "Pointers",
    "section": "Pointers",
    "text": "Pointers\n\nA pointer is a variable that stores a memory address.\n\nDeclare by adding the pointer type modifier ( * ) to a variable declaration.\n\nThe pointer will hold the address of a value of the specified type.\n\n\n\nExample: (pointer to an int)\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x"
  },
  {
    "objectID": "content/11_Pointers.html#why",
    "href": "content/11_Pointers.html#why",
    "title": "Pointers",
    "section": "Why?",
    "text": "Why?\n\nLow-level access.\n\nTo provide explicit, direct access (no copy) in a similar way to what we do implicity with pass by reference.\n\nIteration\n\nPointer math makes array manipulation through pointers very convenient.\nAdvanced data structures may only allow iteration through pointers.\n\nDynamic Memory Allocation\n\nMemory generated at runtime is only identified to the program through its address."
  },
  {
    "objectID": "content/11_Pointers.html#why-simplified",
    "href": "content/11_Pointers.html#why-simplified",
    "title": "Pointers",
    "section": "Why? (simplified)",
    "text": "Why? (simplified)\n\nObservation and Modification\n\nObserving Pointers: Pointers can be used to observe the contents of memory, and potentially to modify the values under observation as well.\n\n\nOwnership\n\nOwning Pointers: Pointers can be used to maintain “ownership” of dynamically-allocated memory resources."
  },
  {
    "objectID": "content/11_Pointers.html#physical-view",
    "href": "content/11_Pointers.html#physical-view",
    "title": "Pointers",
    "section": "Physical View",
    "text": "Physical View\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\nThe following figure illustrates the physical view of what a pointer actually looks like in memory. The pointer xPtr contains the address of the location where x is stored:\n\nPhysical view of pointer in memory."
  },
  {
    "objectID": "content/11_Pointers.html#logical-view",
    "href": "content/11_Pointers.html#logical-view",
    "title": "Pointers",
    "section": "Logical View",
    "text": "Logical View\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\nThe following figure illustrates the logical view of what a pointer conceptually does. The pointer xPtr points to the the variable x:\n\nConceptual view of pointer in memory."
  },
  {
    "objectID": "content/11_Pointers.html#physical-and-logical-view",
    "href": "content/11_Pointers.html#physical-and-logical-view",
    "title": "Pointers",
    "section": "Physical and Logical View",
    "text": "Physical and Logical View\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\n\n\n\nPhysical view of pointer in memory.\n\n\n\n\n\nConceptual view of pointer in memory."
  },
  {
    "objectID": "content/11_Pointers.html#indirection",
    "href": "content/11_Pointers.html#indirection",
    "title": "Pointers",
    "section": "Indirection",
    "text": "Indirection\nKnowing the address of where something is stored gives a programmer low-level access to the data at that location.\n\nPointers store the addresses of other variables; they give us indirect control over the values in those variables.\nThe indirection operator (*) allows us to “follow” a pointer to the address it is storing, so that we may operate on the data stored there.\n\nThis is known as dereferencing the pointer.\nThe indirection operator is also sometimes called the dereference operator."
  },
  {
    "objectID": "content/11_Pointers.html#null-pointers",
    "href": "content/11_Pointers.html#null-pointers",
    "title": "Pointers",
    "section": "“Null” Pointers",
    "text": "“Null” Pointers\nA pointer that doesn’t point to any (legal) memory address is referred to as a “null pointer”.\n\nC++11 added a keyword to represent the literal value of a null pointer: nullptr.\n\nint* x = nullptr; // declare and initialize to nullptr\n\nSetting a pointer to nullptr guarantees that it cannot be dereferenced.\n\n(Basically, you can’t use a null pointer for anything.)"
  },
  {
    "objectID": "content/11_Pointers.html#pointers-to-arrays",
    "href": "content/11_Pointers.html#pointers-to-arrays",
    "title": "Pointers",
    "section": "Pointers to Arrays",
    "text": "Pointers to Arrays\nint a[5]{ 1, 3, 5, 7, 9 };  // normal array\nPointers can be used to access elements of an array.\nint* aPtr = a; // no need for `&`: `a` degrades to a pointer\nPointer mathematics.\nThis is why the type is important for pointers.\nstd::cout &lt;&lt; *(aPtr + 2) &lt;&lt; \"\\n\"; // prints a[2]\nPointer and array notation is interchangeable.\nstd::cout &lt;&lt; aPtr[2] &lt;&lt; \"\\n\";  // easier than \"*(aPtr + 2)\""
  },
  {
    "objectID": "content/11_Pointers.html#more-pointer-math",
    "href": "content/11_Pointers.html#more-pointer-math",
    "title": "Pointers",
    "section": "More Pointer Math",
    "text": "More Pointer Math\nPointers support the following mathematical operations:\nOperation           Example      Description\n----------------------------------------------------\n &lt;ptr&gt; + &lt;int&gt;      xPtr + 3     Add an offset\n &lt;ptr&gt; - &lt;int&gt;      xPtr - 2     Subtract an offset\n ++&lt;ptr&gt;            ++xPtr       (pre) increment\n &lt;ptr&gt;++            xPtr++       (post) increment\n --&lt;ptr&gt;            --xPtr       (pre) decrement\n &lt;ptr&gt;--            xPtr--       (post) decrement\n &lt;ptr&gt; - &lt;ptr&gt;      xPtr - yPtr  Offset distance \n                                 between two pointers"
  },
  {
    "objectID": "content/11_Pointers.html#pointers-as-iterators",
    "href": "content/11_Pointers.html#pointers-as-iterators",
    "title": "Pointers",
    "section": "Pointers as “Iterators”",
    "text": "Pointers as “Iterators”\nYou can use a pointer to “move around” in an array:\nint a[5] = { 1, 3, 5, 7, 9 };\n// [...]\nint* begin = a;               // start is first addr of a\nint* end   = a + 5;           // end is start + size\n\n// \"For each element in a\", using a pointer for movement:\nfor(int* current = begin; current != end; current++){\n    std::cout &lt;&lt; *current &lt;&lt; \"\\t\";\n}\nThis design pattern is very common in the C++ Standard Template Library."
  },
  {
    "objectID": "content/11_Pointers.html#passing-pointers-to-functions",
    "href": "content/11_Pointers.html#passing-pointers-to-functions",
    "title": "Pointers",
    "section": "Passing Pointers to Functions",
    "text": "Passing Pointers to Functions\n\nA pointer may be used as an alternative syntax for passing a 1-D array to a function.\n\nPointer notation is commonly used for c-strings, for example.\n\nPointer values behave as a primitive type.\n\nThey are passed by value, like all other primitive types.\n\nPointers may also be passed by reference if the address in the pointer itself should be changed by the function.\n\nDoing so requires adding the reference type modifier (&)to the formal parameter, just like with any other primitive data."
  },
  {
    "objectID": "content/11_Pointers.html#common-design-pattern-range-based-operations-with-pointers-to-arrays",
    "href": "content/11_Pointers.html#common-design-pattern-range-based-operations-with-pointers-to-arrays",
    "title": "Pointers",
    "section": "Common design pattern: “Range”-based operations with pointers to arrays",
    "text": "Common design pattern: “Range”-based operations with pointers to arrays\n// Assume array `a` already declared as `int a[5];`\nint* begin = a;     // \"left\" edge of array\nint* end   = a + 5; // \"right\" edge of array\n\nPointers to range in array a.Notice that end physically points to the first memory address beyond the end of the array. For this reason, it would be an error to try to dereference end. We must be careful to ensure that never happens.\nThis pattern also applies to iterators to array-like data structures."
  },
  {
    "objectID": "content/11_Pointers.html#common-design-pattern-range-based-operations-with-pointers-to-sub-arrays",
    "href": "content/11_Pointers.html#common-design-pattern-range-based-operations-with-pointers-to-sub-arrays",
    "title": "Pointers",
    "section": "Common design pattern: “Range”-based operations with pointers to sub-arrays",
    "text": "Common design pattern: “Range”-based operations with pointers to sub-arrays\n// Assume array `a` already declared as `int a[5];`\nint* first = a + 1;  // \"left\" edge of subrange\nint* last  = a + 4;  // \"right\" edge of subrange\n\nPointers to range in array a.In this usage, we are bracketing a subrange of values within the larger array. Again, notice that the last pointer points to a value outside that subrange - it should not be dereferenced.\nThis pattern also applies to iterators to array-like data structures."
  },
  {
    "objectID": "content/09_C-Strings.html#ascii-encoding",
    "href": "content/09_C-Strings.html#ascii-encoding",
    "title": "Characters and C-Style Strings",
    "section": "ASCII Encoding",
    "text": "ASCII Encoding\nInternally, all characters must be encoded into a numeric representation.\nThere is more than one way to do it… But C++ (by default) type char uses the ASCII encoding scheme."
  },
  {
    "objectID": "content/09_C-Strings.html#testing-characters",
    "href": "content/09_C-Strings.html#testing-characters",
    "title": "Characters and C-Style Strings",
    "section": "Testing Characters",
    "text": "Testing Characters\nThe following functions require the &lt;cctype&gt; header.\n\nCharacter testing functions."
  },
  {
    "objectID": "content/09_C-Strings.html#case-conversion",
    "href": "content/09_C-Strings.html#case-conversion",
    "title": "Characters and C-Style Strings",
    "section": "Case Conversion",
    "text": "Case Conversion\nAlso require the &lt;cctype&gt; header.\nFunctions:\n\ntoupper(char c): if c is a lowercase letter, return uppercase equivalent; otherwise, return c unchanged.\ntolower(char c): if c is an uppercase letter, return lowercase equivalent; otherwise, return c unchanged."
  },
  {
    "objectID": "content/09_C-Strings.html#case-conversion-example",
    "href": "content/09_C-Strings.html#case-conversion-example",
    "title": "Characters and C-Style Strings",
    "section": "Case Conversion Example",
    "text": "Case Conversion Example\nchar ch1 = 'H';\nchar ch2 = 'e';\nchar ch3 = '!';\n\ncout &lt;&lt; static_cast&lt;char&gt;(toupper(ch1)); //-&gt;'H’\ncout &lt;&lt; static_cast&lt;char&gt;(toupper(ch2)); //-&gt;'E’\ncout &lt;&lt; static_cast&lt;char&gt;(toupper(ch3)); //-&gt;'!'\n\ncout &lt;&lt; static_cast&lt;char&gt;(tolower(ch1)); //-&gt;'h’\ncout &lt;&lt; static_cast&lt;char&gt;(tolower(ch2)); //-&gt;'e’\ncout &lt;&lt; static_cast&lt;char&gt;(tolower(ch3)); //-&gt;'!'"
  },
  {
    "objectID": "content/09_C-Strings.html#c-style-strings",
    "href": "content/09_C-Strings.html#c-style-strings",
    "title": "Characters and C-Style Strings",
    "section": "C-Style Strings",
    "text": "C-Style Strings\nC++ provides support for a low-level representation of strings of characters as they were defined in the C language: as null-terminated arrays of type char. We refer to strings of this type as C-Style strings, or simply C-Strings.\n\nString literals such as \"SMITH\" are internally represented as c-strings by default.\nInternally, they look like the following:\n\n\n“SMITH” as seen in memory."
  },
  {
    "objectID": "content/09_C-Strings.html#c-string-variables",
    "href": "content/09_C-Strings.html#c-string-variables",
    "title": "Characters and C-Style Strings",
    "section": "C-String Variables",
    "text": "C-String Variables\nVariables that store c-strings are just arrays of type char:\nchar name[6] = \"SMITH\";\nProduces:\n\n\n\n“SMITH” as seen in a C-style string.\n\n\nThe trailing '\\0' is added automatically during the initialization.\n\nIMPORTANT: The assignment operator only works with c-strings in an initialization statement! You cannot assign c-strings using =!"
  },
  {
    "objectID": "content/09_C-Strings.html#c-string-input",
    "href": "content/09_C-Strings.html#c-string-input",
    "title": "Characters and C-Style Strings",
    "section": "C-String Input",
    "text": "C-String Input\n\nYou can enter c-strings using &gt;&gt; (stream extraction).\n\nInput is whitespace-terminated.\nNo bounds-checking is performed!\n\nFor input containing whitespace, and to control the amount of input, use cin.getline():\n\nSyntax:  std::cin.getline(c_str_name,max_size)\nconst int SIZE = 64;\nchar      name[SIZE];\nstd::cout &lt;&lt; \"Enter your name: \";\nstd::cin.getline(name, SIZE);"
  },
  {
    "objectID": "content/09_C-Strings.html#what-c-strings-cannot-do",
    "href": "content/09_C-Strings.html#what-c-strings-cannot-do",
    "title": "Characters and C-Style Strings",
    "section": "What C-Strings Cannot Do",
    "text": "What C-Strings Cannot Do\n\nYou cannot directly assign c-strings.\n\nWhy? They are arrays!\n\nYou cannot directly compare c-strings.\n\nWhy? They are arrays!"
  },
  {
    "objectID": "content/09_C-Strings.html#c-string-functions",
    "href": "content/09_C-Strings.html#c-string-functions",
    "title": "Characters and C-Style Strings",
    "section": "C-String Functions",
    "text": "C-String Functions\nThe &lt;cstring&gt; header file contains functions that are useful for dealing with c-style strings:\n    Function                    Description \n    ------------------------------------------------------------\n    strlen(str)                 Returns length of `str`\n\n    strcmp(str1, str2)          Compares `str1` to `str2` \n                                \"alphabetically\"\n\n    strcpy(dst, src)            Copies `src` into `dst` \n                                (no bounds check) \n\n    strncpy(dst, src, count)    Copies up to `count` \n                                characters from `src` into \n                                `dst` (no null-terminator added)\n\n    strcat(dst, src)            Concatenates `src` to the end \n                                of `dst` (no bounds check)  \n\n    strncat(dst, src, count)    Concatenates up to `count` \n                                characters from `src` to end \n                                of `dst`, plus the \n                                null-terminator"
  },
  {
    "objectID": "content/09_C-Strings.html#conversion-functions",
    "href": "content/09_C-Strings.html#conversion-functions",
    "title": "Characters and C-Style Strings",
    "section": "Conversion Functions",
    "text": "Conversion Functions\nRequire &lt;cstdlib&gt;\n    Function                   Description \n    ------------------------------------------------------------\n    atoi(str)                   Converts c-string to an int\n    atol(str)                   Converts c-string to a long\n    atof(str)                   Converts c-string to a double"
  },
  {
    "objectID": "content/07_Recursion.html#recursion",
    "href": "content/07_Recursion.html#recursion",
    "title": "Recursion",
    "section": "Recursion",
    "text": "Recursion\nA function is said to be recursive if it contains a call to itself.\n\nRecursive definitions are often more “natural”.\n\nEmbodies a “divide-and-conquer” strategy\n\n\nvoid countDown(int timer) {   \n    if (timer == 0) {\n       std::cout &lt;&lt; \"Blastoff!\";\n    }\n    else{ \n        std::cout &lt;&lt; timer &lt;&lt; \"...\\n\";\n        countDown(timer-1); // recursive call\n    }\n}"
  },
  {
    "objectID": "content/07_Recursion.html#purpose",
    "href": "content/07_Recursion.html#purpose",
    "title": "Recursion",
    "section": "Purpose",
    "text": "Purpose\n\nRecursion is an alternative way to achieve repetition.\n\nSometimes the iterative approach (loop) isn’t obvious.\n\nRecursion allows us to reduce a difficult problem to a simpler-to-solve problem.\n\nEventually, you hope to reach a (comparatively) trivial case (called the base case).\nRecursive calls stop when the base case is reached."
  },
  {
    "objectID": "content/07_Recursion.html#two-steps-to-recursive-repetition",
    "href": "content/07_Recursion.html#two-steps-to-recursive-repetition",
    "title": "Recursion",
    "section": "Two Steps to Recursive Repetition",
    "text": "Two Steps to Recursive Repetition\nSimilarly to looping (the 3 parts of a loop), recursion has two important steps related to controlling the repetition:\n\n\n\nbase case: A trivial version of the problem in which the function can directly return a result (without calling itself).\n\n\n\n\nrecursive step: A version of the problem in which simplification through a recursive call is required. (No answer can be directly returned.)"
  },
  {
    "objectID": "content/07_Recursion.html#creating-a-recursive-solution",
    "href": "content/07_Recursion.html#creating-a-recursive-solution",
    "title": "Recursion",
    "section": "Creating a Recursive Solution",
    "text": "Creating a Recursive Solution\n\nIdentify the base case and create a condition to test for it.\n\nthis becomes your base condition.\n\n\nIdentify a way to simplify the problem so that applying the simplification repeatedly will eventually lead to the base case.\n\nthis will become the recursive step."
  },
  {
    "objectID": "content/07_Recursion.html#typical-approach",
    "href": "content/07_Recursion.html#typical-approach",
    "title": "Recursion",
    "section": "Typical Approach",
    "text": "Typical Approach\nWhen faced with a very complex problem, the following approach can be used to find a recursive solution:\n\nIdentify patterns in the problem.\n\nLook for a simpler problem that is still the same problem.\n\nThis shows how to simplify during the recursive step(s).\nSome work might be required when you simplify the problem. Pay attention to this “left-over work” - it is key to how the recursive solution performs its task.\n\n\nIdentify the simplest possible version of the (same) problem.\n\nThis is your base case; devise a base condition to test for it.\nIdeally, the base case is trivial, requiring little or no work to solve."
  },
  {
    "objectID": "content/07_Recursion.html#the-base-condition",
    "href": "content/07_Recursion.html#the-base-condition",
    "title": "Recursion",
    "section": "The Base Condition",
    "text": "The Base Condition\n\nA recursive function must contain a test to determine if the base case has been reached.\nThe base condition can always return a result directly, without a recursive call.\nFailure of the recursive step to converge to the base case will result in infinite recursion, which is recursion that continues indefinitely.\n\nInfinite recursion will lead to a program and/or system crash."
  },
  {
    "objectID": "content/07_Recursion.html#recursion-vs-iteration",
    "href": "content/07_Recursion.html#recursion-vs-iteration",
    "title": "Recursion",
    "section": "Recursion VS Iteration",
    "text": "Recursion VS Iteration\n\nFor every recursive function, an iterative solution can also be found.\n\nSometimes finding the iterative solution is difficult.\n\nRecursive solutions will always be less efficient.\nSometimes shorter development time is more important."
  },
  {
    "objectID": "content/07_Recursion.html#towers-of-hanoi",
    "href": "content/07_Recursion.html#towers-of-hanoi",
    "title": "Recursion",
    "section": "Towers of Hanoi",
    "text": "Towers of Hanoi"
  },
  {
    "objectID": "content/07_Recursion.html#towers-of-hanoi-1",
    "href": "content/07_Recursion.html#towers-of-hanoi-1",
    "title": "Recursion",
    "section": "Towers of Hanoi",
    "text": "Towers of Hanoi\n\n\nRules\n\n\n\n\nAll plates begin on one of three pegs, ordered from smallest to largest.\nThe goal is to move all plates to another of the pegs, likewise ordered.\nOnly one plate can be moved at a time.\nPlates not in motion must rest on one of the three pegs.\nA larger plate can never be placed atop a smaller plate."
  },
  {
    "objectID": "content/07_Recursion.html#towers-of-hanoi-2",
    "href": "content/07_Recursion.html#towers-of-hanoi-2",
    "title": "Recursion",
    "section": "Towers of Hanoi",
    "text": "Towers of Hanoi\n\n\nAlgorithm\n\n\n\nMove \\(n-1\\) plates from start to temp (using goal for storage).\nMove the final plate from start to goal.\nMove \\(n-1\\) plates from temp to goal (using start for storage).\n\nSpoiler Alert!"
  },
  {
    "objectID": "content/07_Recursion.html#towers-of-hanoi-3",
    "href": "content/07_Recursion.html#towers-of-hanoi-3",
    "title": "Recursion",
    "section": "Towers of Hanoi",
    "text": "Towers of Hanoi\n\n\nAlgorithm\n\n\n\nMove \\(n-1\\) plates from start to temp (using goal for storage).\nMove the final plate from start to goal.\nMove \\(n-1\\) plates from temp to goal (using start for storage).\n\nSpoiler Alert!\nvoid towers(int n, char start='A', char goal='C', char temp='B'){\n    if(n &gt; 0){\n        towers(n-1, start, temp, goal);\n        cout &lt;&lt; \"Move plate from \" &lt;&lt; start &lt;&lt; \" to \" &lt;&lt; goal &lt;&lt; \".\\n\";\n        towers(n-1, temp, goal, start);\n    }\n}"
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#modular-programming",
    "href": "content/05_Functions_Value_Parameters.html#modular-programming",
    "title": "Functions and Value Parameters",
    "section": "Modular Programming",
    "text": "Modular Programming\n\nModular programming refers to the practice of designing a program so that it is broken up into small, manageable pieces called functions or modules.\nIn C++, a function is a collection of related statements that perform a single logical task, and may produce a value.\nIn Object-Oriented programming, a function that is part of an object (and defined in a class) is referred to as a method. For example, in cin.ignore(), the ignore() function is actually a method owned by the cin object."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#motivation",
    "href": "content/05_Functions_Value_Parameters.html#motivation",
    "title": "Functions and Value Parameters",
    "section": "Motivation",
    "text": "Motivation\n\nModular programs are easier to read and understand.\n\nEach logical step has its own function definition that is easily examined separately from other code.\n\nModular programs are easier to maintain.\n\nChanging an algorithm to fix or improve it involves simply re-writing the function where it is implemented.\n\nModular programs promote code re-use.\n\nIt is much easier to re-use a neatly packaged function than to try to find all the code in a monolithic program that performs a particular action."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#calls-and-definitions",
    "href": "content/05_Functions_Value_Parameters.html#calls-and-definitions",
    "title": "Functions and Value Parameters",
    "section": "Calls and Definitions",
    "text": "Calls and Definitions\n\n\n\nA function call is an expression that causes a function to be executed.\n\nEx: pow(3, 6)\nFunction calls may or may not evaluate to a result. If it does, this result is referred to as a return value.\n\n\n\nA function definition is the code that defines the actions taken by the function when it is called.\n\nThe main() function we have been writing is an example."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#types-of-functions",
    "href": "content/05_Functions_Value_Parameters.html#types-of-functions",
    "title": "Functions and Value Parameters",
    "section": "Types of Functions",
    "text": "Types of Functions\nFunctions can be generally divided into two categories:\n\nFruitful functions (or value-producing functions) are functions whose purpose is to compute and return a value.\n\nMathematical functions are the best example of this.\n\nNon-fruitful functions (or void functions) are functions that do not directly return any result.\n\nThese functions usually produce some useful side-effect.\nAn example would be the close() method of a file stream.\nSome languages (and so some programmers) refer to these as procedures."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#calling-a-function",
    "href": "content/05_Functions_Value_Parameters.html#calling-a-function",
    "title": "Functions and Value Parameters",
    "section": "Calling a Function",
    "text": "Calling a Function\n\nAny expression can contain a function call.*\n\nNon-fruitful functions are often called as a stand-alone statement.\nFruitful functions are usually called as part of a larger expression.\n\nAny function can call any other function (including itself).\nLike a variable, a function must be “declared” before it is first called. The compiler must know:\n\nfunction name\nreturn type\nnumber and type of parameters required\n\n\n\n* Assuming the function’s return type is syntactically appropriate for the expression."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#defining-a-function",
    "href": "content/05_Functions_Value_Parameters.html#defining-a-function",
    "title": "Functions and Value Parameters",
    "section": "Defining a function",
    "text": "Defining a function\nThe function definition must define the function’s interface, as well as the statements that must be executed to perform the function’s action.\n\nThe function header defines the function’s interface.\n\nname, return type, list of parameters\n\nThe function body is the block of statements that are executed when the function is called."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#formal-and-actual-parameters",
    "href": "content/05_Functions_Value_Parameters.html#formal-and-actual-parameters",
    "title": "Functions and Value Parameters",
    "section": "Formal and Actual Parameters",
    "text": "Formal and Actual Parameters\n\nFormal parameters (or parameters): The temporary placeholders declared in the function header used to receive data provided by the caller.\nActual parameters (or arguments): The data values that are actually passed to the function during a call.\n\n\n\n\n\nUnfortunately, the terms “parameter” and “argument” are often used nearly interchangeably in conversation. This can lead to confusion. Please take care to make a distinction between the two."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#data-flow-pass-by-value",
    "href": "content/05_Functions_Value_Parameters.html#data-flow-pass-by-value",
    "title": "Functions and Value Parameters",
    "section": "Data Flow: Pass by Value",
    "text": "Data Flow: Pass by Value\n\nIn pass by value, the value of the actual parameter is copied into the formal parameter.\nPass by value is the default method by which data is moved into a function for primitive types, structured types and object types.\n\nChanges to the formal parameter cannot affect the actual parameter."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#returning-values-from-a-function",
    "href": "content/05_Functions_Value_Parameters.html#returning-values-from-a-function",
    "title": "Functions and Value Parameters",
    "section": "Returning Values from a Function",
    "text": "Returning Values from a Function\nFruitful functions produce a value by means of a return statement in the function definition.\n\nMust define the type of the return value in the function header.\nThe value returned must match the type specified in the header.\nWhen called, the function call is “replaced” by the value that it returns.\n\nWe often say the function evaluates to the resulting value."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#scope",
    "href": "content/05_Functions_Value_Parameters.html#scope",
    "title": "Functions and Value Parameters",
    "section": "Scope",
    "text": "Scope\n\n\n\nA function is a like a sealed box. The only way “in” is through the parameter list or global scope. The only direct way “out” is through a return.\n\n\n\n\nFormal parameters are locally-scoped within the function definition.\nVariables declared in a function will be locally-scoped within the function definition.\nGlobal variables declared before a function definition will be available in the function definition."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#static-local-variables",
    "href": "content/05_Functions_Value_Parameters.html#static-local-variables",
    "title": "Functions and Value Parameters",
    "section": "static Local Variables",
    "text": "static Local Variables\nA static variable displays a hybrid of local and global behavior. It is used to maintain state between calls.\nvoid foo(){\n    static int count = 1;\n    std::cout &lt;&lt; \"Call # \" &lt;&lt; count &lt;&lt; \"\\n\";\n    count++;\n}\n\nThe identifier is governed by local scoping rules\nThe value is governed by global scoping rules (it doesn’t go away between calls).\n\nProvides “sticky” values that are “remembered” between calls."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#function-prototypes",
    "href": "content/05_Functions_Value_Parameters.html#function-prototypes",
    "title": "Functions and Value Parameters",
    "section": "Function Prototypes",
    "text": "Function Prototypes\nWe would prefer to define the main() function first… But the compiler requires that all other function interfaces be specified before they can be called.\n\nfunction prototype: A declaration statement for a function, providing the function’s interface but not a body.\nPlaced at the top of a program so that the function definition can be placed after main(), in any order."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#default-parameter-values",
    "href": "content/05_Functions_Value_Parameters.html#default-parameter-values",
    "title": "Functions and Value Parameters",
    "section": "Default Parameter Values",
    "text": "Default Parameter Values\nOften a parameter will always be set to a common value; in these cases, a default value can be specified for the parameter. Doing so makes the parameter optional when calling the function.\n\nDefault parameters are specified in the function prototype (if used) or header by using initialization syntax:\n\ndouble divide( double dividend, double divisor = 2.0 );\n\nIf the actual parameter corresponding to the default parameter is omitted, the default value (2.0 in this case) will be used.\n\n\n\n\n\nThe default value must only be specified once. If you use a prototype, the default value is specified there. Only specify the default value in the header of the definition if no prototype is used. It is an error to specify it in both places.\nRemember it this way: Place the default value in the first place the compiler will encounter it."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#default-parameter-notes",
    "href": "content/05_Functions_Value_Parameters.html#default-parameter-notes",
    "title": "Functions and Value Parameters",
    "section": "Default Parameter Notes",
    "text": "Default Parameter Notes\n\nOrder is important!\n\nOnce you give one parameter a default, all parameters to its right must also have defaults.\nIn a call, once you omit an argument, you must also omit all arguments to its right.\n\nBest practice is to place the most often customized parameters further left, and the ones for which the default is usually OK to the right.\n\nThis isn’t a rule—it’s just a usability consideration."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#documentation",
    "href": "content/05_Functions_Value_Parameters.html#documentation",
    "title": "Functions and Value Parameters",
    "section": "Documentation",
    "text": "Documentation\nAll function definitions require documentation headers describing the function, its parameters, and return value. See course Grading Guidelines.\n/**\n * Divide `dividend` by `divisor` and return the result.\n * @param   dividend    Dividend for the division \n * @param   divisor     Divisor for the division \n *                      (defaults to 2.0)\n * @return  The result of `dividend` / `divisor` is returned.\n */\ndouble divide( double dividend, double divisor ){\n    return dividend / divisor;\n}\n\nDoxygen-style documentation headers begin with /** (two stars, not just one).\nThis allows Doxygen to tell them apart from “regular” block comments.\n\n\nIf a function’s purpose is simple, just list it at the beginning of the documentation header.\nMore complex functions can use the @brief and @detailed tags to provide a short and complete description (see documentation guidelines).\n\n\nThe @param directive lets you document parameters. Give the name, then some space, then a short description of what the parameter is used for.\n\n\nThe @return directive lets you provide a short description of the value that will be returned.\n\n\n\nYou only need to create the parameter and return value documentation if your function has parameters / return value. A void function does not need a @return documentation; a function with no parameters does not need @param documentation.\nDon’t write documentation that doesn’t provide any information.\nDO try to write concise, high-quality documentation."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#stubs-and-drivers",
    "href": "content/05_Functions_Value_Parameters.html#stubs-and-drivers",
    "title": "Functions and Value Parameters",
    "section": "Stubs and Drivers",
    "text": "Stubs and Drivers\n\nNo need to define full functionality immediately.\n\n\n\n\n\n\n\nCompile Early, Compile Often\n\n\nLet the compiler be your helper, not your adversary.\n\n\n\n\nA valid* function body only needs an appropriate return statement.\n\nThe rest can be left “empty” until later.\n\nfunction stub: an empty function used for incremental development.\ndriver: a function used only for testing other functions by calling them.\n\n\n* “Valid” doesn’t imply correct—it just means you are syntactically valid and can compile (and maybe even run) the program to see if there are other errors."
  },
  {
    "objectID": "content/03_Selection.html#making-decisions",
    "href": "content/03_Selection.html#making-decisions",
    "title": "Selection",
    "section": "Making Decisions",
    "text": "Making Decisions\nOne of the things computers are “good at” is determining the result of logic-based (Boolean) expressions, and using those results to make decisions quickly.\n\nChoose to whether or not to perform an operation.\n\nIf it is raining outside, take an umbrella.\n\nChoose between possible outcomes.\n\nIf you are taller than 38”, proceed to the ride, otherwise leave the line.\n\nSelect from a variety of possible choices.\n\nShow the user a menu with many options; respond to his/her choice appropriately."
  },
  {
    "objectID": "content/03_Selection.html#first-some-operators",
    "href": "content/03_Selection.html#first-some-operators",
    "title": "Selection",
    "section": "First, some operators…",
    "text": "First, some operators…\nBefore we can make decisions based on the answers to logic questions, we need to learn what kinds of questions we can ask, and how to phrase the questions.\n\nAll decisions must be based on logical tests that evaluate to a clear true or false result. (Boolean expressions)\nC++ provides a full set of relational operators for making comparisons, and logical operators for combining these comparisons into complex expressions."
  },
  {
    "objectID": "content/03_Selection.html#relational-operators",
    "href": "content/03_Selection.html#relational-operators",
    "title": "Selection",
    "section": "Relational Operators",
    "text": "Relational Operators\nRelational operators compare two values, and evaluate to a bool result based on the truthfulness of the comparison:\n\n\n\nOperator    Description     \n------------------------------------\n   &gt;        greater than    \n   &lt;        less than       \n   &gt;=       greater than or equal to\n   &lt;=       less than or equal to\n   ==       equal to \n   !=       not equal to"
  },
  {
    "objectID": "content/03_Selection.html#logical-operators",
    "href": "content/03_Selection.html#logical-operators",
    "title": "Selection",
    "section": "Logical Operators",
    "text": "Logical Operators\nLogical (or Boolean) operators are used to combine relational expressions to create a more complex test condition:\n\n\n\nOperator    Description     \n----------------------\n   &&       and\n   ||       or\n   !        not (unary)"
  },
  {
    "objectID": "content/03_Selection.html#control-structures",
    "href": "content/03_Selection.html#control-structures",
    "title": "Selection",
    "section": "Control Structures",
    "text": "Control Structures\nA control structure is a special language construct that allows a programmer to change the “natural” top-down execution order of the statements in a program.\nAlthough control structures (such as the if) are not actually statements, they are often passively referred to as such. Most do not end with a semicolon."
  },
  {
    "objectID": "content/03_Selection.html#the-if-control-structure",
    "href": "content/03_Selection.html#the-if-control-structure",
    "title": "Selection",
    "section": "The if Control Structure",
    "text": "The if Control Structure\nThe most basic form of the C++ if control structure allows us to choose whether or not to take a specific action:\nSyntax\n\nif( conditional_expression )\n    statement_executed_if_true;\n\nExample\n// Assume x is an integer whose value was entered by the user.\n\nif( x &lt; 0 )   // Check for a negative value\n    std::cout &lt;&lt; \"You entered a negative value.\\n\";"
  },
  {
    "objectID": "content/03_Selection.html#using-a-block",
    "href": "content/03_Selection.html#using-a-block",
    "title": "Selection",
    "section": "Using a Block",
    "text": "Using a Block\nSince a single statement isn’t enough to solve most problems, the body of an if may also be a block:\n// Assume x is an integer whose value was entered by the user.\n\nif( x &lt; 0 )  { // Check for a negative value\n    std::cout &lt;&lt; \"You entered a negative value.\\n\";\n    x = 0;     // Ensure that x is non-negative.\n}\nRecall that a block just means a set of statements contained within curly braces."
  },
  {
    "objectID": "content/03_Selection.html#choose-between-two-outcomes",
    "href": "content/03_Selection.html#choose-between-two-outcomes",
    "title": "Selection",
    "section": "Choose Between Two Outcomes",
    "text": "Choose Between Two Outcomes\nThe if-else construct allows us to choose between two outcomes:\nSyntax\n\nif( conditional_expression )\n    statement_executed_if_true;\nelse\n    statement_executed_if_false;\n\nExample\n// Assume x is an integer whose value was entered by the user.\n\nif( x &lt; 0 )   // Check for a negative value\n    std::cout &lt;&lt; \"You entered a negative value.\\n\";\nelse\n    std::cout &lt;&lt; x &lt;&lt; \" is non-negative.\\n\";"
  },
  {
    "objectID": "content/03_Selection.html#if-else-with-blocks",
    "href": "content/03_Selection.html#if-else-with-blocks",
    "title": "Selection",
    "section": "if-else with Blocks",
    "text": "if-else with Blocks\nThe body of both the if and else part may be blocks:\n// Assume x is an integer whose value was entered by the user,\n// and rt_x is a double that is already declared.\n\nif( x &lt; 0 )  { // Check for a negative value\n    std::cout &lt;&lt; \"You entered a negative value.\\n\";\n    x = 0;     // Ensure that x is non-negative.\n}\nelse {\n    std::cout &lt;&lt; \"Calculating root...\\n\";\n    rt_x = sqrt(x);\n}"
  },
  {
    "objectID": "content/03_Selection.html#information",
    "href": "content/03_Selection.html#information",
    "title": "Selection",
    "section": "Information",
    "text": "Information\n\nThe else part is optional - only use it if you need it.\nIt is recommended to always use blocks for the body of the if and else.\n\nWill save time debugging if more code is added later.\n\nAlways indent the body of the if and else.\n\nIndentation shows ownership (for human programmer’s benefit)\n\nAny legal C++ statement may go in the body of the if/else, including nested if constructs."
  },
  {
    "objectID": "content/03_Selection.html#selecting-from-multiple-options",
    "href": "content/03_Selection.html#selecting-from-multiple-options",
    "title": "Selection",
    "section": "Selecting from Multiple Options",
    "text": "Selecting from Multiple Options\nA clever application of nesting ifs inside elses is commonly used to select from multiple (more than 2) options. It is often referred to as the if-else chain:\n// Assume door is an integer containing 1, 2, or 3:\n\nstd::cout &lt;&lt; \"Behind door #\" &lt;&lt; door &lt;&lt; \", you see a \";\nif(door == 1) {         // door #1\n    std::cout &lt;&lt; \"trip to Hawaii!\\n\";\n}\nelse if(door == 2) {    // door #2\n    std::cout &lt;&lt; \"new car!\\n\";\n}\nelse {                  // door #3\n    std::cout &lt;&lt; \"goat!\\n\";\n}"
  },
  {
    "objectID": "content/03_Selection.html#final-details",
    "href": "content/03_Selection.html#final-details",
    "title": "Selection",
    "section": "Final Details",
    "text": "Final Details\n\nC++ control structures do not strictly require conditions to be type bool.\n\nAny non-zero value will be considered equivalent to “true”.\nAny value that compares “equal to” zero is considered equivalent to “false”.\n\nBeware of the assignment operator! See example below:\n\n// This will print \"8 is 4!\" ... Why?\nint x = 8;\n// [...]\nstd::cout &lt;&lt; x;\nif( x = 4 ) {\n    std::cout &lt;&lt; \" is 4!\";\n}\n\nx is assigned 8. So far so good…\n\n\nWe print x, which is 8 right now. Still OK.\n\n\nThe expression x = 4 assigns the value 4 to x. Then, it evaluates to 4, which is not zero, so the if considers it to be equivalent to true…\nNow we have a problem.\n\n\nWe print the string \" is 4!\", since the if condition was “true-like”.\nThe exact output is:\nx is 4!\n\n\n\n\n\n\n\n\n\n\n\n \n\n\nSelection"
  },
  {
    "objectID": "content/01_SP_Basics.html#first-principles",
    "href": "content/01_SP_Basics.html#first-principles",
    "title": "Structured Programming Basics",
    "section": "First Principles",
    "text": "First Principles\n\ncomputer - a programmable machine designed to follow instructions\n\nComputers are able to perform mathematical and logical operations at great speed.\n\nalgorithm - a precise, step-by-step plan for solving a problem\nprogram - a set of instructions expressed in a programming language that a computer follows to perform a task\nprogrammer - a person who writes a computer program\nprogramming language - any language designed specifically for use in creating computer programs"
  },
  {
    "objectID": "content/01_SP_Basics.html#computer-code",
    "href": "content/01_SP_Basics.html#computer-code",
    "title": "Structured Programming Basics",
    "section": "Computer Code",
    "text": "Computer Code\nComputers execute code that is stored in computer memory in a binary form.\n11000111 01000100 00100100 00000100 00011000 10000111 00000100\nHumans are not skilled at writing in machine language."
  },
  {
    "objectID": "content/01_SP_Basics.html#language-levels",
    "href": "content/01_SP_Basics.html#language-levels",
    "title": "Structured Programming Basics",
    "section": "Language Levels",
    "text": "Language Levels\n\nLow-Level\n\nMachine Language\n\nPure binary, but usually expressed as hexadecimal\n\nAssembly Language\n\nCorresponds more or less 1:1 with machine language (easy conversion)\nMore human-readable (for some definition of more)\n\n\nHigh-Level\n\nC, C++, Python, Swift, etc.\n\nDesigned to look like a human language\nMust be translated to machine language"
  },
  {
    "objectID": "content/01_SP_Basics.html#a-complete-c-program",
    "href": "content/01_SP_Basics.html#a-complete-c-program",
    "title": "Structured Programming Basics",
    "section": "A Complete C++ Program:",
    "text": "A Complete C++ Program:\n#include &lt;iostream&gt;\n\nint main(){\n    std::cout &lt;&lt; \"Hello, World!\\n\";\n    return 0;\n}\nNow, we will take a look at the parts of the program, and see what each part does."
  },
  {
    "objectID": "content/01_SP_Basics.html#a-complete-c-program-1",
    "href": "content/01_SP_Basics.html#a-complete-c-program-1",
    "title": "Structured Programming Basics",
    "section": "A Complete C++ Program:",
    "text": "A Complete C++ Program:\n#include &lt;iostream&gt;\n\nint main(){\n    std::cout &lt;&lt; \"Hello, World!\\n\";\n    return 0;\n}\n\n\nThis line is called a preprocessor directive.\nIt communicates with a phase of the C++ compiler called the preprocessor, telling it to include code from a file named “iostream”, which is a C++ library.\n\nThe iostream library contains code that is used for input and output activities.\n\n\n\n\nThis line is called a function header.\nIt begins the definition of a function called “main”.\nEvery C++ program must contain a main() function.\n\nThe main() function tells the computer where to begin executing.\nInstructions will be executed one at a time, starting with the first line of main.\n\n\n\n\n\nThe curly braces enclose a block of code in C++.\nblock - a set of related C++ statements that perform an action\nEvery opening curly brace must match with a closing brace.\n\nWe indent the code between the { and the }.\n\n\n\n\n\nThis statement sends the words “Hello, World” to the screen.\nstd::cout is the name of the standard output stream\n\nA stream is a one-way flow of data from the point of view of the program.\n\n&lt;&lt; is the stream insertion operator, used to place things into a stream.\n\"Hello, World!\\n\" is a string literal; a string is just a collection of characters that are treated as a single unit.\n\nString literals are always surrounded by double-quotes.\n\nliteral: A literal is a value that is typed directly into the source code, in a representation that the programming language recognizes as a value of a recognized type. Literal values must be formatted according to the syntax rules of the language.\n\n\n\n\nThis line terminates the program by causing the main() function to return the value 0 to the operating system.\n\nNo code following this line would ever be executed; this means that the return 0; line will always be the last line in main().\n\nThe operating system considers zero to be an indication that the program exited “normally”.\n\nOther values are possible, and we will use them later."
  },
  {
    "objectID": "content/01_SP_Basics.html#escape-characters",
    "href": "content/01_SP_Basics.html#escape-characters",
    "title": "Structured Programming Basics",
    "section": "Escape Characters",
    "text": "Escape Characters\n    std::cout &lt;&lt; \"Hello, World\\n\";\n\nWe often want to include control characters in our string literals, but we don’t have the ability to type these in directly. C++ allows the use of escape characters for this purpose.\n\n\nescape character - any character combination beginning with “\\”, used to represent a character that cannot otherwise be represented in a string literal.\n\nExamples:\nCode     Meaning\n-----------------\n \\n      newline (think of the &lt;ENTER&gt; key)\n \\t      tab character\n \\\"      allows a double-quote in a string literal\n \\\\      allows a backslash in a string literal\n \\r      carriage-return (used in Windows line endings: \"\\r\\n\")"
  },
  {
    "objectID": "content/01_SP_Basics.html#our-development-toolchain",
    "href": "content/01_SP_Basics.html#our-development-toolchain",
    "title": "Structured Programming Basics",
    "section": "Our Development Toolchain",
    "text": "Our Development Toolchain\n\n\nUser’s Side: Editing, running and testing.\nServer Side: Stores files, provides compiler and other tools."
  },
  {
    "objectID": "content/01_SP_Basics.html#some-linux-unix-terminal-basics",
    "href": "content/01_SP_Basics.html#some-linux-unix-terminal-basics",
    "title": "Structured Programming Basics",
    "section": "Some Linux / UNIX terminal basics",
    "text": "Some Linux / UNIX terminal basics\nhttps://towardsdatascience.com/basics-of-bash-for-beginners-92e53a4c117a\nhttps://www.educative.io/blog/bash-shell-command-cheat-sheet\nhttps://wiki.cs.astate.edu/index.php/Common_Linux_Commands (Requires VPN access.)"
  },
  {
    "objectID": "content/01_SP_Basics.html#practice-developing-and-compiling",
    "href": "content/01_SP_Basics.html#practice-developing-and-compiling",
    "title": "Structured Programming Basics",
    "section": "Practice Developing and Compiling",
    "text": "Practice Developing and Compiling\n#include &lt;iostream&gt;\n\nint main(){\n    std::cout &lt;&lt; \"Hello, World!\\n\";\n    return 0;\n}\nMake modifications to the program so that it will print out your name, favorite food, and favorite TV series.\n\n\n\n\n\n\n\n \n\n\nStructured Programming Basics"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CS 50x2 Slides",
    "section": "",
    "text": "Structured Programming Basics\n\n\n\n\n\n\n\n\n\n\nVariables, Operators, Common Errors\n\n\n\n\n\n\n\n\n\n\nSelection\n\n\n\n\n\n\n\n\n\n\nRepetition\n\n\n\n\n\n\n\n\n\n\nFunctions and Value Parameters\n\n\n\n\n\n\n\n\n\n\nFunctions and Reference Parameters\n\n\n\n\n\n\n\n\n\n\nRecursion\n\n\n\n\n\n\n\n\n\n\nArrays\n\n\n\n\n\n\n\n\n\n\nCharacters and C-Style Strings\n\n\n\n\n\n\n\n\n\n\nParallel and Multi-Dimensional Arrays\n\n\n\n\n\n\n\n\n\n\nPointers\n\n\n\n\n\n\n\n\n\n\nSTL and Vectors\n\n\n\n\n\n\n\n\n\n\nInput and Output\n\n\n\n\n\n\n\n\n\n\nSearching and Sorting\n\n\n\n\n\n\n\n\n\n\nStructures\n\n\n\n\n\n\n\n\n\n\nBinary Files and Random Access\n\n\n\n\n\n\n\n\n\n\nDynamic Memory\n\n\n\n\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\n\n\n\n\nClasses and Objects\n\n\n\n\n\n\n\n\n\n\nAggregation\n\n\n\n\n\n\n\n\n\n\nAssignment, Copy Constructor\n\n\n\n\n\n\n\n\n\n\nOperator Overloading\n\n\n\n\n\n\n\n\n\n\nLinked Lists\n\n\n\n\n\n\n\n\n\n\nStacks, Queues, and Circular Lists\n\n\n\n\n\n\n\n\n\n\nTemplates and Generic Programming\n\n\n\n\n\n\n\n\n\n\nInheritance\n\n\n\n\n\n\n\n\n\n\nVirtual Methods and Polymorphism\n\n\n\n\n\n\n\n\n\n\nSparse Tables\n\n\n\n\n\n\n\n\n\n\nSkip Lists\n\n\n\n\n\n\n\n\n\n\nSelf-Organizing Lists\n\n\n\n\n\n\n\n\n\n\nTrees - Binary Search Trees\n\n\n\n\n\n\n\n\n\n\nBalancing Trees - AVL Trees\n\n\n\n\n\n\n\n\n\n\nHeaps and HeapSort\n\n\n\n\n\n\n\n\n\n\nMultiway Trees (m-Trees)\n\n\n\n\n\n\n\n\n\n\nGraphs\n\n\n\n\n\n\n\n\n\n\nDecision Trees\n\n\n\n\n\n\n\n\n\n\nEfficient Sorting\n\n\n\n\n\n\n\n\n\n\nHashing\n\n\n\n\n\n\n\n\n\n\nSupplement: cmath and Epsilon Comparison\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#variables-operators-common-errors",
    "href": "content/02_Variables_Operators_Errors.html#variables-operators-common-errors",
    "title": "Variables, Operators, Common Errors",
    "section": "Variables, Operators, Common Errors",
    "text": "Variables, Operators, Common Errors\nGaddis (Ch. 2)"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#the-big-picture",
    "href": "content/02_Variables_Operators_Errors.html#the-big-picture",
    "title": "Variables, Operators, Common Errors",
    "section": "The Big Picture",
    "text": "The Big Picture\nAll programming languages must provide certain functionality:\n\nTemporary data storage and retrieval.\n\nHow is data stored in RAM?\n\nOperators that can be applied to the data.\n\nWhat can I do to manipulate the data, and how?\n\nInput and Output\n\nWhere does the data come from, and how?\n\nControl Structures\n\nConditional execution and repetition.\n\n\nTo learn a language, figure these things out first."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#where-to-start",
    "href": "content/02_Variables_Operators_Errors.html#where-to-start",
    "title": "Variables, Operators, Common Errors",
    "section": "Where to Start?",
    "text": "Where to Start?\nWe will begin by examining the way C++ provides for temporary data storage and retrieval.\n\nAll non-trivial programs act by storing and manipulating data.\nData is stored in the computer’s RAM (Random Access Memory) while a program is using it.\n\nRAM is volatile (it only works when the machine is on)."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#computer-memory",
    "href": "content/02_Variables_Operators_Errors.html#computer-memory",
    "title": "Variables, Operators, Common Errors",
    "section": "Computer Memory",
    "text": "Computer Memory\n\nThe smallest division of memory is a byte (8-bits). All storage sizes are specified in bytes.\n\nEach byte of memory has a number associated with it, called its memory address.\nThis address is what the machine uses to refer to data.\n\nPhysical memory is limited, but logical memory (our view of memory as programmers) is usually treated as if it were unlimited.\n\n\nLogical Memory"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#variables",
    "href": "content/02_Variables_Operators_Errors.html#variables",
    "title": "Variables, Operators, Common Errors",
    "section": "Variables",
    "text": "Variables\nSince humans are not good with numbers (like memory addresses), C++ provides us with a way to use names instead.\n\nvariable : a named storage location for data within a program\nvariable declaration : a statement used to tell the compiler that a new variable should be created; contains the identifier and type for the variable.\n\nint temperature;\nThe declaration statement above tells the compiler to create a variable named temperature that will store an integer."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#data-types",
    "href": "content/02_Variables_Operators_Errors.html#data-types",
    "title": "Variables, Operators, Common Errors",
    "section": "Data Types",
    "text": "Data Types\nSo what types of things can we store in variables?\n\n\n\nType Name\nDescription\nLiteral Examples\n\n\n\n\nint\nInteger value\n96, -33\n\n\ndouble\nFloating-point (Real number) value\n3.14, -1.0\n\n\nchar\nSingle character\n'a', '4'\n\n\nbool\nBoolean value\ntrue, false\n\n\nstd::string\nString value\n\"Hello\", \"ocean\""
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#identifiers",
    "href": "content/02_Variables_Operators_Errors.html#identifiers",
    "title": "Variables, Operators, Common Errors",
    "section": "Identifiers",
    "text": "Identifiers\nAn identifier is a name that is permissible for variables, classes, functions, etc. in C++.\n\nYou must obey the following 3 Rules For Identifiers:\n\nIdentifiers may not begin with a digit.\nIdentifiers must consist only of letters, digits, and underscores.\nAn identifier must not be a keyword.\n\n  Additional Info: Identifers (and everything else) in C++ are case sensitive"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#keywords",
    "href": "content/02_Variables_Operators_Errors.html#keywords",
    "title": "Variables, Operators, Common Errors",
    "section": "Keywords",
    "text": "Keywords\nA keyword is a word that has a specific, reserved meaning in a programming language. Also known as reserved words in some texts.\n\nC++ Consists of all of the keywords from the C language, plus new ones that are related to C++’s object-oriented focus.\n\nThere are 92 keywords in C++ (as of the C++20 standard). C++98 had 74."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#declaration",
    "href": "content/02_Variables_Operators_Errors.html#declaration",
    "title": "Variables, Operators, Common Errors",
    "section": "Declaration",
    "text": "Declaration\nDeclaring a variable allows the compiler to reserve memory for the data, as well as managing the association between the data’s memory address and the identifier chosen to represent the variable in the program.\nint temperature;\nThe declaration above produces the situation in memory shown below:\n\nVariable Declaration"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#declaration-1",
    "href": "content/02_Variables_Operators_Errors.html#declaration-1",
    "title": "Variables, Operators, Common Errors",
    "section": "Declaration",
    "text": "Declaration\n\nDeclaring a variable tells the compiler the name and type of the data.\n\nThe compiler now also knows the amount of memory required.\nYou can find out with the sizeof() operator:\n\ncout &lt;&lt; sizeof(temperature); Will produce “4”…\n\n\nDeclaring a variable does not specify what value the variable will contain!\n\nThe variable will contain whatever value happened to be in that location in memory.\n\nMemory is constantly recycled, so this is essentially garbage."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#initialization",
    "href": "content/02_Variables_Operators_Errors.html#initialization",
    "title": "Variables, Operators, Common Errors",
    "section": "Initialization",
    "text": "Initialization\nInitialization refers to storing a value in a variable for the first time.\n\nVariables always begin in an uninitialized state.\n\nExample:\nint temperature = 82;\nThe statement above declares a variable named temperature and initializes temperature to contain the value 82."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#the-auto-keyword",
    "href": "content/02_Variables_Operators_Errors.html#the-auto-keyword",
    "title": "Variables, Operators, Common Errors",
    "section": "The auto Keyword",
    "text": "The auto Keyword\n\nC++11 added the ability for a variable declaration to get its type information automatically based on its initialization value.\n\nThe auto keyword may be used in place of the variable’s type when this behavior is desired.\n\n\nExample\nauto interestRate = 12.75;\nauto stockCode    = 'C';\nHere, interestRate will be of type double and stockCode will be type char — the compiler can determine this by examining the type of the literals used to initialize the variables."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#when-to-use-auto",
    "href": "content/02_Variables_Operators_Errors.html#when-to-use-auto",
    "title": "Variables, Operators, Common Errors",
    "section": "When to use auto",
    "text": "When to use auto\n\nThe auto keyword is intended to simplify declaration of intermediate variables that have very complex types.\n\nIn general, do not use auto to declare variables whose lifetime is more than a few lines.\nIn general, do not use auto to declare variables whose type is “simple” (a built-in or primitive type).\n\nGoal: Use auto whenever it increases the readability of the code, avoid it when it decreases the code’s readability."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#variable-lifetime",
    "href": "content/02_Variables_Operators_Errors.html#variable-lifetime",
    "title": "Variables, Operators, Common Errors",
    "section": "Variable Lifetime",
    "text": "Variable Lifetime\nVariable names (and all other names as well) have a “life span” within the context of the program code.\n\n\nscope - an identifier’s scope refers to the section of the program in which the identifier is defined.\nC++ has six kinds of scope:\n\nglobal scope - globally-scoped identifiers are known from the point at which they are declared until the end of the program.\n\nThese are defined outside any function (outside any block).\n\nlocal scope - locally-scoped identifiers are known from the point at which they are declared until the end of the block in which they are declared.\n\nAlmost all variables we use will be local.\n\nstatement scope - Names declared in a for, if, while, or switch statement are visible until the end of the statement block.\n\nThis behaves like a special case of local scope.\n\nclass scope - Names of class members have class scope, which extends throughout the class definition regardless of the point of declaration. Class member accessibility is further controlled by the public, private, and protected keywords.\nnamespace scope - A name that is declared within a namespace, outside of any class or enum definition or function block, is visible from its point of declaration to the end of the namespace.\nfunction scope - A label has function scope, which means it is visible throughout a function body even before its point of declaration."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#assignment",
    "href": "content/02_Variables_Operators_Errors.html#assignment",
    "title": "Variables, Operators, Common Errors",
    "section": "Assignment",
    "text": "Assignment\n\nVariables may be re-used by changing their value.\nThe C++ assignment operator is =\n\nIt should always be read as “assigned” or “is assigned”.\nIt should never be read as “equals”!\n\n\nExample:\nint temperature = 82;\nstd::cout &lt;&lt; \"Initial temperature: \" &lt;&lt; temperature &lt;&lt; \"\\n\";\ntemperature = 75; // change the value of temperature to 75\nstd::cout &lt;&lt; \"Temperature now: \"     &lt;&lt; temperature &lt;&lt; \"\\n\";\nThe third line should be read as “temperature is assigned 75”."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#operators",
    "href": "content/02_Variables_Operators_Errors.html#operators",
    "title": "Variables, Operators, Common Errors",
    "section": "Operators",
    "text": "Operators\n\nC++ Operators can be divided into the following families:\n\nAssignment Operators\nMathematical Operators\nRelational Operators\nLogical Operators\nStream Operators\nOther Operators\n\nWe have seen the basic assignment operator (=) and the stream insertion operator (&lt;&lt;).\nNow, let’s look at the stream extraction operator…"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#stream-extraction",
    "href": "content/02_Variables_Operators_Errors.html#stream-extraction",
    "title": "Variables, Operators, Common Errors",
    "section": "Stream Extraction",
    "text": "Stream Extraction\n\nThe &gt;&gt; operator is the C++ stream extraction operator.\nIt takes a value from the stream on the left (often we use std::cin) and places it into the variable on the right:\n\nint x;                                   // declare x\nstd::cout &lt;&lt; \"Enter an integer value: \"; // prompt\nstd::cin  &gt;&gt; x;                          // read x\n\nNotice that the stream extraction operation works like assignment, except that the new value comes from a stream.\nstd::cin is the standard input stream (usually attached to the keyboard)\nNow let’s visit the mathematical operators…"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#c-mathematical-operators",
    "href": "content/02_Variables_Operators_Errors.html#c-mathematical-operators",
    "title": "Variables, Operators, Common Errors",
    "section": "C++ Mathematical Operators",
    "text": "C++ Mathematical Operators\n Operator    Meaning               Expression  Result\n------------------------------------------------------\n +           Addition                 3 + 4      7\n -           Subtraction              4 - 6      -2\n -           Negation (unary -)      -3 + 1      -2\n *           Multiplication           3 * 5      15\n /           Division                 8 / 2      4\n %           Modulus (remainder)      7 % 4      3\nBeware of the division operator!\n\n3 / 4 evaluates to 0!\n\nIf / is operating on integers, it performs integer division.\n\n3.0 / 4.0 yields 0.75, as expected.\n\nIf either the dividend or divisor is a floating-point type, the answer will be as well."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#expressions",
    "href": "content/02_Variables_Operators_Errors.html#expressions",
    "title": "Variables, Operators, Common Errors",
    "section": "Expressions",
    "text": "Expressions\nAn expression may consist of one or more operations on data, and will evaluate to a result whose type is the most precise type involved in the expression. (This is highly simplified… but is true most of the time.)\nExample:\nstd::cout &lt;&lt; 3 + 5 * 7 - 2 &lt;&lt; \"\\n\"; // produces 36\nint x = 5;\nint y = 3 * x / 2;\nstd::cout &lt;&lt; y &lt;&lt; \"\\n\";             // produces 7\ndouble z = 4.0;\nstd::cout &lt;&lt; y / z &lt;&lt; \"\\n\";         // produces 1.75"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#the-const-modifier",
    "href": "content/02_Variables_Operators_Errors.html#the-const-modifier",
    "title": "Variables, Operators, Common Errors",
    "section": "The const Modifier",
    "text": "The const Modifier\nA type modifier is a C++ keyword that is used in conjunction with a type name to change that type’s properties in some way.\nThe const type modifier changes a declaration statement from a variable declaration to a constant declaration.\nThe value of a constant can never be changed once it has been initialized."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#comments",
    "href": "content/02_Variables_Operators_Errors.html#comments",
    "title": "Variables, Operators, Common Errors",
    "section": "Comments",
    "text": "Comments\n\nMost of a developer’s time is spent maintaining or improving code.\n\nYou cannot maintain or improve code that you can’t read and understand!\n\n\n\nAny line beginning with // is a single-line comment in C++. The compiler will simply ignore the // and any code following it until the end of the line.\n\n/* and */ create block comments in C++. Anything between a /* and its corresponding */ will be ignored. Block comments may span multiple lines."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#documentation",
    "href": "content/02_Variables_Operators_Errors.html#documentation",
    "title": "Variables, Operators, Common Errors",
    "section": "Documentation",
    "text": "Documentation\nIn addition to comments in the code, the program itself should have documentation to explain the “big picture”.\n\nEach development team/company will have its own standards for documentation. We have developed a set of standards that are similar to industry practice.\n See the documentation guidelines that your code must meet on the course website."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#programming-errors",
    "href": "content/02_Variables_Operators_Errors.html#programming-errors",
    "title": "Variables, Operators, Common Errors",
    "section": "Programming Errors",
    "text": "Programming Errors\nProgrammers are human. [citation needed]\nErrors are unavoidable. Learning to expect, detect, and fix those errors is a key component of learning to program.\n\n\nTypes of Errors\n\nSyntax Errors\n\nCaused by incorrect syntax: rules of spelling, grammar, and punctuation for a language.\nthe compiler often detects these easily.\n\nSemantic Errors\n\nSemantic errors caused by mis-using the language in some way; these are not caught by the compiler, and must be detected at runtime.\n\nLogical Errors\n\nLogical errors like semantic errors, but error is in the logic, not the implementation."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#tips-and-tricks",
    "href": "content/02_Variables_Operators_Errors.html#tips-and-tricks",
    "title": "Variables, Operators, Common Errors",
    "section": "Tips and Tricks",
    "text": "Tips and Tricks\n\nCompile early, compile often.\n\nWrite small amounts, then compile/test/continue.\n\nThe first error is the only one that matters!\n\nAlways fix the first error before moving on to other errors.\nRe-compile after fixing the error, then repeat the process.\n\nPay attention to line numbers.\n\nThe compiler will tell you which line it was examining when it found the error.\n\nThe line containing the error will either be that line or a line above that point in the program.\n\nStart with the flagged line, work your way upward a line at a time.\n\n\n\n\n\n\n\n\n\n\n\n \n\n\nVariables, Operators, Common Errors"
  },
  {
    "objectID": "content/04_Repetition.html#first-some-helpful-new-operators",
    "href": "content/04_Repetition.html#first-some-helpful-new-operators",
    "title": "Repetition",
    "section": "First, some helpful new operators…",
    "text": "First, some helpful new operators…\n\nShortcut Assignment Operators\n\nMake modifying an existing value easy.\n\nIncrement and Decrement Operators\n\nMake counting up and down easy."
  },
  {
    "objectID": "content/04_Repetition.html#repetition-loops",
    "href": "content/04_Repetition.html#repetition-loops",
    "title": "Repetition",
    "section": "Repetition (loops)",
    "text": "Repetition (loops)\nRepeating code is accomplished with the help of a control structure called a loop. C++ provides three loop constructs (four if you count the modern C++ range-based version of for):\n\nwhile\nfor\n\nRange-based for\n\ndo-while\n\nBut before we get into the specifics of the code, let’s examine some terms and theory related to looping in general."
  },
  {
    "objectID": "content/04_Repetition.html#terms",
    "href": "content/04_Repetition.html#terms",
    "title": "Repetition",
    "section": "Terms",
    "text": "Terms\n\nLoop Control Variable : a variable whose value is tested in order to determine whether the loop body should execute.\nLoop Condition : a Boolean expression whose result determines whether the loop body will execute (true causes the loop to execute).\nUpdate step : a modification that is made to the loop control variable within the scope of the loop body."
  },
  {
    "objectID": "content/04_Repetition.html#three-parts-of-a-loop",
    "href": "content/04_Repetition.html#three-parts-of-a-loop",
    "title": "Repetition",
    "section": "Three Parts of a Loop",
    "text": "Three Parts of a Loop\n\n\n\n\nSet up the Loop Control Variable (LCV) in preparation for the loop.\nA proper loop condition must be created to test the LCV.\nThe value of the LCV must be changed within the body of the loop."
  },
  {
    "objectID": "content/04_Repetition.html#types-of-loops-by-method-of-control",
    "href": "content/04_Repetition.html#types-of-loops-by-method-of-control",
    "title": "Repetition",
    "section": "Types of Loops (by method of control)",
    "text": "Types of Loops (by method of control)\n\nIterative Loop (AKA “Counting Loop”) : a loop that repeats a specific number of times, or for a specific range of values.\nEvent-Controlled Loop : a loop that repeats until a specific event occurs. 3 sub-types:\n\nSentinel Controlled Loop : a loop that repeats until a specified data value is encountered (this value is called the sentinel)\nFlag Controlled Loop : a loop that repeats until the truth value of a Boolean flag is flipped.\nEnd-Of-File Controlled Loop : a loop that repeats (based on a stream) until the End Of File marker is read."
  },
  {
    "objectID": "content/04_Repetition.html#types-of-loops-by-timing-of-the-test",
    "href": "content/04_Repetition.html#types-of-loops-by-timing-of-the-test",
    "title": "Repetition",
    "section": "Types of Loops (by timing of the test)",
    "text": "Types of Loops (by timing of the test)\nLoops can also be classified by the timing of when they test their loop condition:\n\npre-test loop : a loop that tests the loop condition before loop entry (at the beginning of each loop)\npost-test loop : a loop that tests the loop condition at loop exit (at the end of each loop)"
  },
  {
    "objectID": "content/04_Repetition.html#the-while-loop",
    "href": "content/04_Repetition.html#the-while-loop",
    "title": "Repetition",
    "section": "The while Loop",
    "text": "The while Loop\nwhile is a pre-test loop.\n\n\nSyntax:\n\nwhile( loop_condition )\n    statement_to_repeat;\n\n\nUsing a Block\n\nwhile( loop_condition ) {\n    statement_1;\n    […]\n    statement_n;\n}"
  },
  {
    "objectID": "content/04_Repetition.html#the-for-loop",
    "href": "content/04_Repetition.html#the-for-loop",
    "title": "Repetition",
    "section": "The for Loop",
    "text": "The for Loop\nfor is a pre-test loop.\n\n\nSyntax:\n\nfor( initializer ; test ; update )\n     statement_to_repeat;\n\n\nUsing a Block\n\nfor( initializer ; test ; update ) {\n     statement_1;\n     […]\n     statement_n;\n}"
  },
  {
    "objectID": "content/04_Repetition.html#the-range-based-for-loop",
    "href": "content/04_Repetition.html#the-range-based-for-loop",
    "title": "Repetition",
    "section": "The Range-Based for Loop",
    "text": "The Range-Based for Loop\nC++11 added the ability for a for loop to iterate over all elements of a sequence container using a more concise syntax:\nSyntax\n\nfor( item_declaration : container )\n     statement_to_repeat;\n\n\nor more generally:\n\n\n\nfor( item_declaration : container ) {\n     statement_1;\n     […]\n     statement_n;\n}"
  },
  {
    "objectID": "content/04_Repetition.html#the-do-while-loop",
    "href": "content/04_Repetition.html#the-do-while-loop",
    "title": "Repetition",
    "section": "The do-while Loop",
    "text": "The do-while Loop\ndo-while is a post-test loop.\n\nSyntax:\n\ndo {\n     statement_1;\n     […]\n     statement_n;\n} while( loop_condition );\n\n\n\nNotice the semicolon at the end!\nThe do-while is the only C++ control structure that ends with a semicolon."
  },
  {
    "objectID": "content/04_Repetition.html#which-loop-to-choose",
    "href": "content/04_Repetition.html#which-loop-to-choose",
    "title": "Repetition",
    "section": "Which Loop to Choose?",
    "text": "Which Loop to Choose?\n\nwhile\n\npre-test loop\nwell suited to Event Controlled Loops\n\nfor\n\npre-test loop\nwell suited to Iterative Loops\nrange-based for is great for containers\n\ndo-while\n\npost-test loop\nwell suited to Event Controlled Loops used for validation\n\n\n\n\n\n\n\n\n\n \n\n\nRepetition"
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#review-pass-by-value",
    "href": "content/06_Functions_Reference_Parameters.html#review-pass-by-value",
    "title": "Functions and Reference Parameters",
    "section": "Review: Pass by Value",
    "text": "Review: Pass by Value\n\nIn pass by value, the value of the actual parameter is copied into the formal parameter.\nPass by value is the default method by which data is moved into a function for primitive types, structured types and object types.\n\nChanges to the formal parameter cannot affect the actual parameter."
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#pass-by-reference",
    "href": "content/06_Functions_Reference_Parameters.html#pass-by-reference",
    "title": "Functions and Reference Parameters",
    "section": "Pass by Reference",
    "text": "Pass by Reference\n\nIn pass by reference, no copy is made.\nThe formal parameter simply becomes an alias for the actual parameter.\nAny changes made to the formal parameter inside the function will be reflected in the actual parameter following the call.\n\nDanger! You can damage the actual parameter!\n\nC++ arrays are passed by reference by default."
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#passing-by-reference",
    "href": "content/06_Functions_Reference_Parameters.html#passing-by-reference",
    "title": "Functions and Reference Parameters",
    "section": "Passing by Reference",
    "text": "Passing by Reference\n\nA reference parameter is a formal parameter that is an alias for the actual parameter.\nCreated by adding the reference type modifier in the formal parameter declaration.\n\nThe reference type modifier is the ampersand (&):  void readXY( int& x, int& y );"
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#why",
    "href": "content/06_Functions_Reference_Parameters.html#why",
    "title": "Functions and Reference Parameters",
    "section": "Why?",
    "text": "Why?\n\nPassing by reference avoids making a copy.\n\nSmaller memory footprint.\n\nPassing by reference allows a function to make changes to the actual parameter (argument) directly.\n\nAllows the programmer to move multiple values out of a function.\nThis is a double-edged sword!\n\nYou can use const to prevent the argument from being modified.\n\n\n\n\n\nconst reference parameters\n\n\nThese can give you the “best of both worlds”. You can efficiently pass a parameter without the risk of the function changing it."
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#function-calls",
    "href": "content/06_Functions_Reference_Parameters.html#function-calls",
    "title": "Functions and Reference Parameters",
    "section": "Function Calls",
    "text": "Function Calls\n\nNo additional syntax is needed to call a function that uses reference parameters.\n\nThis is part of the reason that there is a danger!\n\nYou cannot pass literals or constants by reference unless the formal parameter is a const reference."
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#function-overloading",
    "href": "content/06_Functions_Reference_Parameters.html#function-overloading",
    "title": "Functions and Reference Parameters",
    "section": "Function Overloading",
    "text": "Function Overloading\n\nTwo (or more) functions that have the same name but different parameter lists are said to be overloaded.\nThe correct function to call is determined by the compiler by matching the number and type of arguments to the formal parameter lists.\n\nThis happens at compile-time.\n\nParameter lists must be unique for each function.\n\nAmbiguities will be flagged as errors."
  },
  {
    "objectID": "content/08_Arrays.html#the-c-array",
    "href": "content/08_Arrays.html#the-c-array",
    "title": "Arrays",
    "section": "The C++ Array",
    "text": "The C++ Array\nAn array is a data structure consisting of multiple values of the same type stored contiguously in memory and accessed by an integer index representing the offset of the desired element from the beginning of the array.\nArrays allow programmers to store multiple related values of the same type.\n\nValues are stored sequentially in memory.\nDeclaration syntax:  type arrayname[ size_declarator ];\n\nExample Declarations\nint    a[100]; // Declares an array of 100 integers.\ndouble b[50];  // Declares an array of 50 doubles."
  },
  {
    "objectID": "content/08_Arrays.html#array-memory-layout",
    "href": "content/08_Arrays.html#array-memory-layout",
    "title": "Arrays",
    "section": "Array Memory Layout",
    "text": "Array Memory Layout\nThe declaration:\nint tests[5];\nallocates the following memory:\n\nArray elements are contiguous boxes in memory.\nArrays are a reference type.\n\nThe array variable does not refer to the array as a whole, only to the location of the first element."
  },
  {
    "objectID": "content/08_Arrays.html#terminology",
    "href": "content/08_Arrays.html#terminology",
    "title": "Arrays",
    "section": "Terminology",
    "text": "Terminology\nIn the declaration:  int tests[5];\n\nint is the data type of all elements in the array.\ntests is the name of the array.\n5 (in [5]) is the size declarator. It specifies the number of elements.\n\nThe storage size of the array is \\(N \\times S\\) where \\(N\\) is the number of elements and \\(S\\) is the size (in bytes) of each element.\nThe size declarator must be either a literal or constant."
  },
  {
    "objectID": "content/08_Arrays.html#size-declarators",
    "href": "content/08_Arrays.html#size-declarators",
    "title": "Arrays",
    "section": "Size Declarators",
    "text": "Size Declarators\nNamed constants are often used as size declarators.\nconst int class_size = 5;\nint       tests[class_size];\n\nMakes maintenance easier if size needs to change.\nAvoids creating “magic numbers”.\n\nmagic numbers are literal numeric values that appear repeatedly for reasons that are non-obvious by the context."
  },
  {
    "objectID": "content/08_Arrays.html#indexes-and-elements",
    "href": "content/08_Arrays.html#indexes-and-elements",
    "title": "Arrays",
    "section": "Indexes and Elements",
    "text": "Indexes and Elements\nEach individual data item in an array is referred to as an array element.\n\n\n\n\nArray elements are contiguous boxes in memory.\n\n\nElements are identified by an integer index, starting from 0.\n\n\n\n\nArray elements are identified by integer indices."
  },
  {
    "objectID": "content/08_Arrays.html#initial-values",
    "href": "content/08_Arrays.html#initial-values",
    "title": "Arrays",
    "section": "Initial Values",
    "text": "Initial Values\nArray elements start out uninitialized if their base types do (primitive types, for example).\n\n\n\nArray elements are uninitialized.\n\n\nUse the element’s index number and array index syntax to access individual elements:\ntests[0] = 88;\n\n\n\nArray with first value initialized."
  },
  {
    "objectID": "content/08_Arrays.html#generate-indices-with-a-loop",
    "href": "content/08_Arrays.html#generate-indices-with-a-loop",
    "title": "Arrays",
    "section": "Generate Indices with a Loop",
    "text": "Generate Indices with a Loop\nThe array index may be specified by a literal, variable, or integer expression.\n\n\n// Assume \"tests\" has been initialized as shown previously...\n\n// Display tests from tests array to standard output:\nfor(int i = 0; i &lt; 5; i++){\n    std::cout &lt;&lt; tests[i] &lt;&lt; \"\\n\";\n}"
  },
  {
    "objectID": "content/08_Arrays.html#uniform-initialization-syntax",
    "href": "content/08_Arrays.html#uniform-initialization-syntax",
    "title": "Arrays",
    "section": "Uniform Initialization Syntax",
    "text": "Uniform Initialization Syntax\nint tests[] { 88, 92, 76, 85, 63 };\nProduces: \n\nSize declarator is optional here, since the compiler can count.\nThis is only useful if you know all of the values that will be stored at the time you are writing the program.\n\nThat is rarely the case.\n\nLoops are generally the best option.\n\n\n\nThe old way to do this was called “array initializer syntax”. It looks similar, but uses the assignment operator:\nint tests[] = { 88, 92, 76, 85, 63 };\nWe prefer the modern version using Uniform Initialization Syntax."
  },
  {
    "objectID": "content/08_Arrays.html#array-assignment",
    "href": "content/08_Arrays.html#array-assignment",
    "title": "Arrays",
    "section": "Array Assignment",
    "text": "Array Assignment\n\n\n\n\n\nYou cannot directly assign one array to another:\ncopy_of_tests = tests;  // WILL NOT WORK!!!\n\n\n\n\n\nCorrect way - Assign element-by-element:\nfor(int i = 0; i &lt; 5; i++){\n    copy_of_tests[i] = tests[i];\n}"
  },
  {
    "objectID": "content/08_Arrays.html#arrays-as-parameters",
    "href": "content/08_Arrays.html#arrays-as-parameters",
    "title": "Arrays",
    "section": "Arrays as Parameters",
    "text": "Arrays as Parameters\n\n\nArrays may be passed to functions:\nvoid print_tests(int tests[], int size){\n    for(int i = 0; i &lt; size; i++){\n        std::cout &lt;&lt; tests[i] &lt;&lt; \"\\n\";\n    }\n}\n\n\nNotice that the array’s size must also be passed.\n\nArrays do not “know their own size”.\n\n\n\n\n\nNotice the empty size declarator in the formal parameter.\n\nThe first dimension does not require (or allow) a size declarator in a formal parameter declaration.\n\n\n\n\n\nArrays are always passed by reference."
  },
  {
    "objectID": "content/08_Arrays.html#d-arrays-key-points-summary",
    "href": "content/08_Arrays.html#d-arrays-key-points-summary",
    "title": "Arrays",
    "section": "1-D Arrays Key Points Summary",
    "text": "1-D Arrays Key Points Summary\n\nSize declarator must be a literal or constant.\nC++ provides no bounds-checking for indices.\nArray elements start out uninitialized if their base types do.\n\nThey are default constructed if the base type is a structured or object type.\n\nArrays cannot be directly assigned.\nArrays are always passed by reference to functions.\nArrays do not “know” their own size.\n\n\n\n\n\n\n\n\n \n\n\nArrays"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#parallel-arrays",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#parallel-arrays",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Parallel Arrays",
    "text": "Parallel Arrays\n\nParallel Arrays: Two or more arrays containing related data such that the elements at corresponding indexes are related.\n\nAll elements at index i the parallel arrays make up a single record i.\n\n\nExample\nconst int   N_CONTESTANTS = 5;\nstd::string names[N_CONTESTANTS];\nint         votes[N_CONTESTANTS];\n// Each contestant has a name and a vote count.\nfor(int i = 0; i &lt; N_CONTESTANTS; i++){\n    std::cout &lt;&lt; \"Contestant \" &lt;&lt; (i+1) &lt;&lt; \" name: \";\n    std::cin  &gt;&gt; names[i];\n    std::cout &lt;&lt; \"# of votes for \" &lt;&lt; names[i] &lt;&lt; \": \";\n    std::cin  &gt;&gt; votes[i];\n}"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#parallel-arrays-1",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#parallel-arrays-1",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Parallel Arrays",
    "text": "Parallel Arrays\n\nSince the parallel arrays are separate, they may be of mixed type.\nAny operation that updates one of the parallel arrays must update all others to maintain the parallel property.\nAll arrays must be passed to functions separately (although one “size” parameter is usually sufficient)."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#dimensional-arrays",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#dimensional-arrays",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "2-Dimensional Arrays",
    "text": "2-Dimensional Arrays\nC++ allows multiple dimensions for arrays. This is achieved by simply adding additional size declarators:\nint votes[5][3]; // create array with 5 rows and 3 columns\n\nNotice that two sets of square brackets are needed for a 2-D array.\nSame rules apply for size declarators here. (constants or literals only)"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#layout-logical",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#layout-logical",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Layout (Logical)",
    "text": "Layout (Logical)\nint votes[5][3]; // create array with 5 rows and 3 columns\n\n2-D Array of integers."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#layout-physical",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#layout-physical",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Layout (Physical)",
    "text": "Layout (Physical)\nint votes[5][3]; // create array with 5 rows and 3 columns\nIn reality, all physical memory is 1-dimensional.\nRows are sequential!\n\n2-D Array of integers."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#using-constants-for-size",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#using-constants-for-size",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Using Constants for Size",
    "text": "Using Constants for Size\nAvoid “magic numbers” by using named constants for size declarators:\nconst int N_CONTESTANTS = 5; // # of contestants\nconst int N_DAYS        = 3; // contest length\n\n// [...]\n\nint votes[N_CONTESTANTS][N_DAYS]; // table of contest votes\n\n\n\nIt can sometimes be useful to allow these constants to be global in some cases (as we will see shortly)."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#working-with-2-d-arrays",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#working-with-2-d-arrays",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Working with 2-D Arrays",
    "text": "Working with 2-D Arrays\nAlmost all operations on 2-D arrays will require nested loops.\nThink “for each row, for each column, do some operation”.\n// Initialize \"votes\" array:\nfor(int i = 0; i &lt; N_CONTESTANTS; i++){\n    for(int j = 0; j &lt; N_DAYS; j++){\n        votes[i][j] = 0;\n    }\n}"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#d-arrays-as-formal-parameters",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#d-arrays-as-formal-parameters",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "2-D Arrays as Formal Parameters",
    "text": "2-D Arrays as Formal Parameters\nBecause of the reality of the physical (1-D) layout of the array, C++ requires that you specify a size declarator for every dimension except the first when listing arrays in formal parameter lists.\nvoid print_matrix( int matrix[][4], int n_rows ){\n    for(int i = 0; i &lt; n_rows; i++){\n        for(int j = 0; j &lt; 4; j++){\n            std::cout &lt;&lt; matrix[i][j] &lt;&lt; \"\\t\";\n        }\n        std::cout &lt;&lt; \"\\n\";\n    }\n}\nThe number of rows can still be a parameter, allowing it to vary."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#d-arrays-as-formal-parameters-1",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#d-arrays-as-formal-parameters-1",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "2-D Arrays as Formal Parameters",
    "text": "2-D Arrays as Formal Parameters\nAgain, to avoid “magic numbers”, we often set up global constants for the sizes of each dimension after the first:\nconst int N_COLS = 4; // GLOBAL constant, defined at top.\n\n// [ ... ]\n\nvoid print_matrix( int matrix[][N_COLS], int n_rows ){\n    for(int i = 0; i &lt; n_rows; i++){\n        for(int j = 0; j &lt; N_COLS; j++){\n            std::cout &lt;&lt; matrix[i][j] &lt;&lt; \"\\t\";\n        }\n        std::cout &lt;&lt; \"\\n\";\n    }\n}"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#arrays-of-higher-dimension",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#arrays-of-higher-dimension",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Arrays of Higher Dimension",
    "text": "Arrays of Higher Dimension\nThere is no (practical) limit on the number of dimensions an array can have.\nHigher-dimensional arrays require substantial memory resources.\n\n\nExample: 3-D Array\nconst int ROWS  = 8;\nconst int COLS  = 8;\nconst int MOVES = 100; // Number of replay steps\n// [...]\nint game_board_over_time[MOVES][ROWS][COLS];\nRequires 8 * 8 * 100 * sizeof(int) =&gt; 25600 bytes (25 KB)."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#arrays-of-higher-dimension-1",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#arrays-of-higher-dimension-1",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Arrays of Higher Dimension",
    "text": "Arrays of Higher Dimension\nOperations just require more nested loops (one for each dimension):\n\n\nfor(int move = 0; move &lt; MOVES; move++){\n    for(int r = 0; r &lt; ROWS; r++){\n        for(int c = 0; c &lt; COLUMNS; c++){\n            cout &lt;&lt; game_board_over_time[move][r][c]\n                 &lt;&lt; \"\\t\";\n        }\n        cout &lt;&lt; \"\\n\";\n    }\n}\n\n\n\n\n\n\n\n \n\n\nParallel and Multi-Dimensional Arrays"
  },
  {
    "objectID": "content/12_vector.html#the-c-standard-template-library",
    "href": "content/12_vector.html#the-c-standard-template-library",
    "title": "STL and Vectors",
    "section": "The C++ Standard Template Library",
    "text": "The C++ Standard Template Library\n\nWhat is STL?\nWhy use STL?\nOverview of STL Features and Concepts\nContainers\nIterators\nAlgorithms\nReferences for more information on STL"
  },
  {
    "objectID": "content/12_vector.html#what-is-stl",
    "href": "content/12_vector.html#what-is-stl",
    "title": "STL and Vectors",
    "section": "What is STL?",
    "text": "What is STL?\n\n“The Standard Template Library provides a set of well structured generic C++ components that work together in a seamless way.”\n- Alexander Stepanov & Meng Lee, The Standard Template Library\n\n\nDesigned to provide a common, familiar interface.\nDesigned to meet specific performance/complexity goals.\nKeeps programmers from “re-inventing the wheel”."
  },
  {
    "objectID": "content/12_vector.html#why-use-stl",
    "href": "content/12_vector.html#why-use-stl",
    "title": "STL and Vectors",
    "section": "Why Use STL?",
    "text": "Why Use STL?\n\nReuse: “Write less, do more”\n\nSTL hides complex, error-prone details.\nAllows you to focus on the problem.\nType-safe compatibility between components.\n\nFlexibility\n\nIterators decouple algorithms from containers.\nUnanticipated combinations easily supported.\n\nEfficiency\n\nTemplates avoid virtual function overhead.\nStrict attention to time and/or space complexity of algorithms."
  },
  {
    "objectID": "content/12_vector.html#stl-features-and-concepts",
    "href": "content/12_vector.html#stl-features-and-concepts",
    "title": "STL and Vectors",
    "section": "STL Features and Concepts",
    "text": "STL Features and Concepts\n\nContainers\n\nSequence: vector, list, deque\nAssociative: set, multiset, map, multimap\n\nAdapters: stack, queue, priority_queue\nIterators\n\nUsed to access elements in containers\nInput, output, forward, bidirectional, & random access\nEach container declares a trait for the type of iterator it provides\n\nGeneric Algorithms\n\nMutating, non-mutating, sorting, numeric"
  },
  {
    "objectID": "content/12_vector.html#stl-containers",
    "href": "content/12_vector.html#stl-containers",
    "title": "STL and Vectors",
    "section": "STL Containers",
    "text": "STL Containers\n\nSTL Containers are Abstract Data Types (ADTs)\nAll containers are parameterized by the type(s) they contain.\nAll declare traits :\n\ne.g. iterator, const_iterator, value_type, etc."
  },
  {
    "objectID": "content/12_vector.html#container-types",
    "href": "content/12_vector.html#container-types",
    "title": "STL and Vectors",
    "section": "Container Types",
    "text": "Container Types\n\nSequence\n\nProvide efficient linear access to data\nElement order is not related to value\nThink arrays and linked lists\n\nAssociative\n\nProvide efficient access to data stored as a key/value pair\nKeys can be ordered by operator&lt;\nImplemented as balanced binary trees\n\nAdapters\n\nProvide alternative ways to access sequence and associative containers\ne.g. stack, queue, priority_queue"
  },
  {
    "objectID": "content/12_vector.html#stdvector-example",
    "href": "content/12_vector.html#stdvector-example",
    "title": "STL and Vectors",
    "section": "std::vector Example",
    "text": "std::vector Example\nusing std::vector;\nusing std::string;\n// [...]\nvector&lt;string&gt; v;                   // create vector\n\nv.push_back(\"The number is 10\");    // push some values\nv.push_back(\"The number is 20\");    // into it...\nv.push_back(\"The number is 30\");\n\ncout &lt;&lt; \"Loop by index:\" &lt;&lt; endl;\n\nfor(vector&lt;string&gt;::size_type i=0;  // size type is unsigned\n    i &lt; v.size();                   // vector knows its size!\n    i++){                           // print values by\n   cout &lt;&lt; v[i] &lt;&lt; endl;            // indexing the\n}                                   // vector like an array\n\n\n\nHINT: Use v.at(i) instead of v[i] to enable bounds-checking!"
  },
  {
    "objectID": "content/12_vector.html#stdvector-example-2",
    "href": "content/12_vector.html#stdvector-example-2",
    "title": "STL and Vectors",
    "section": "std::vector Example 2",
    "text": "std::vector Example 2\nstd::vector&lt;std::string&gt; v;         // create vector\n\nv.push_back(\"The number is 10\");    // push some values\nv.push_back(\"The number is 20\");    // into it...\nv.push_back(\"The number is 30\");\n\ncout &lt;&lt; \"Loop by range using iterators:\" &lt;&lt; endl;\n\nfor(auto it = v.begin();            // iterator\n    it != v.end();                  // runs from begin()\n    ++it)                           // to end(), one at a time\n{                                   // and is\n   cout &lt;&lt; *it &lt;&lt; endl;             // dereferenced to\n}                                   // print the value\n\nThink of an iterator as an arrow pointing to a value in the container.\nThe dereference operator (*) is used to “follow the arrow” to get the value an iterator is pointing to."
  },
  {
    "objectID": "content/12_vector.html#stdvector-example-3",
    "href": "content/12_vector.html#stdvector-example-3",
    "title": "STL and Vectors",
    "section": "std::vector Example 3",
    "text": "std::vector Example 3\nstd::vector&lt;std::string&gt; v;         // create vector\n\nv.push_back(\"The number is 10\");    // push some values\nv.push_back(\"The number is 20\");    // into it...\nv.push_back(\"The number is 30\");\n\ncout &lt;&lt; \"Loop by range-based `for`:\" &lt;&lt; endl;\n\nfor( auto item : v ){               // for each item in v\n   cout &lt;&lt; item &lt;&lt; endl;            // print the item\n}"
  },
  {
    "objectID": "content/12_vector.html#stdvector-example-4",
    "href": "content/12_vector.html#stdvector-example-4",
    "title": "STL and Vectors",
    "section": "std::vector Example 4",
    "text": "std::vector Example 4\nauto v = std::vector&lt;std::string&gt;{3};    // pre-size to 3\n\nint  n = 1;\nfor( auto& item : v){                    // each item (by ref.)\n    item = std::string{\"The number is \"} // generate message\n         + std::to_string(10 * n++);     // and store in item\n}\n\ncout &lt;&lt; \"Loop by range:\" &lt;&lt; endl;\n\nfor( auto item : v ){                    // for each item\n   cout &lt;&lt; item &lt;&lt; endl;                 // print the item\n}\nstd::to_string() is contained in &lt;std::string&gt;\n\n\n\nThe “pre-size” declaration will only work with non-integer vector types. To pre-size an analogous vector&lt;int&gt;, you would do:\nstd::vector&lt;int&gt; v;\nv.resize(3);"
  },
  {
    "objectID": "content/12_vector.html#iterators",
    "href": "content/12_vector.html#iterators",
    "title": "STL and Vectors",
    "section": "Iterators",
    "text": "Iterators\nIterators are a generalization of pointers.\n\nUsed to access information in containers, regardless of the internal layout\nFour types:\n\nForward (uses ++)\nBidirectional (uses ++ and --)\nRandom-access (behave like normal pointers)\nInput (can be used with input streams)\nOutput (can be used with output streams)"
  },
  {
    "objectID": "content/12_vector.html#iterator-example",
    "href": "content/12_vector.html#iterator-example",
    "title": "STL and Vectors",
    "section": "Iterator Example",
    "text": "Iterator Example\nstd::vector&lt;int&gt; scores{3};  // pre-size to 3\n\nscores.at(0) = 88;\nscores.at(1) = 92;\nscores.at(2) = 76;\n\nfor(auto it = scores.begin(); it != grade_list.end(); it++){\n    std::cout &lt;&lt; *it &lt;&lt; '\\t';\n}\nstd::cout &lt;&lt; '\\n';"
  },
  {
    "objectID": "content/12_vector.html#vector-modifiers",
    "href": "content/12_vector.html#vector-modifiers",
    "title": "STL and Vectors",
    "section": "vector Modifiers",
    "text": "vector Modifiers\nThese are algorithms that vectors know how to apply to themselves:\nclear()     : clears all contents (empties the container)\nerase()     : erase one element, given an iterator to it\ninsert()    : inserts element before a position (given an iterator)\npop_back()  : removes the last element\npush_back() : adds a new element at the end\nresize()    : changes the size of the vector\n[...] There are others not shown here"
  },
  {
    "objectID": "content/12_vector.html#passing-vectors-to-functions",
    "href": "content/12_vector.html#passing-vectors-to-functions",
    "title": "STL and Vectors",
    "section": "Passing vectors to functions",
    "text": "Passing vectors to functions\nstd::vector is an object type, meaning that it is passed by value by default! This means that even though it “looks and feels” like an array, the argument-to-parameter communication mechanism is quite different.\nLet’s look at an example…"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#linear-search",
    "href": "content/14_Searching_Sorting.html#linear-search",
    "title": "Searching and Sorting",
    "section": "Linear Search",
    "text": "Linear Search\nLinear search is a simple, brute-force approach:\n\n\nTo find a value V in array A:\n\n* For each index i in A,\n    - compare value at A[i] to V ...\n        + If they match, save i in I.\n        + otherwise, keep looking\n* After loop, either I contains the index where V \n  was found, or all elements have been examined \n  and V was not found.\n* Return the location I, \n  or an indication that V was not found."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#linear-search-discussion",
    "href": "content/14_Searching_Sorting.html#linear-search-discussion",
    "title": "Searching and Sorting",
    "section": "Linear Search Discussion",
    "text": "Linear Search Discussion\n\n\nAdvantages\n\nSimple to understand\nAlways finds the target value (if it is present)\nPlaces no requirement on the ordering of the array\n\n\n\n\n\nDisadvantage\n\nSlow\n\nBest, average, worst performance?"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#can-we-do-better",
    "href": "content/14_Searching_Sorting.html#can-we-do-better",
    "title": "Searching and Sorting",
    "section": "Can we do better?",
    "text": "Can we do better?\nIf you had a (paper) dictionary, how would you look up a word?\n\n\nWould you open to page 1 and start “scanning” each page?\n\n\n\n\nOr, would you use a divide-and-conquer approach?"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#binary-search",
    "href": "content/14_Searching_Sorting.html#binary-search",
    "title": "Searching and Sorting",
    "section": "Binary Search",
    "text": "Binary Search\nIf the values in your array are ordered, Binary Search is a fast approach to the search problem:\nTo find value V in ascending-ordered array ‘A’:\n\n* Mark the ends of the array, left and right.\n* While the array between left and right is non-empty,\n    - Calculate the index of the middle element (mid)\n    - if A[mid] matches V, save mid (in I) and \n    you are done.\n    - Otherwise, if A[mid] &lt; V, move left so that you \n    examine the right half of the array on next pass.\n    - Otherwise, move right to that the left half of \n    the array will be examined.\n* At end of loop, either index of V is saved, \nor V was not in the array.\n* Return I or an indication that V was not found."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#binary-search-discussion",
    "href": "content/14_Searching_Sorting.html#binary-search-discussion",
    "title": "Searching and Sorting",
    "section": "Binary Search Discussion",
    "text": "Binary Search Discussion\n\n\nAdvantage\n\nFast\n\nBest, average, worst performance?\n\n\n\n\n\n\nDisadvantage\n\nRequires array to be ordered\n\nWhat is the cost of sorting the array?\n\n\n\n\nHow do you choose between Binary Search and Linear Search?"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#search-summary",
    "href": "content/14_Searching_Sorting.html#search-summary",
    "title": "Searching and Sorting",
    "section": "Search Summary",
    "text": "Search Summary\n\n\n\n\nLinear search is slow ( \\(O(n)\\) ), but does not require ordered values.\n\n\n\n\nBinary search is fast ( \\(O(log_2(n))\\) ), but requires that the array is ordered."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#bubble-sort",
    "href": "content/14_Searching_Sorting.html#bubble-sort",
    "title": "Searching and Sorting",
    "section": "Bubble Sort",
    "text": "Bubble Sort\nTo get an array A into ascending order:\n\n\ncontinue the following until the array is sorted:\n\nfor each pair of elements in the array,\n\ncompare the pair to see if they are in order\n\nIf not, swap the values and make note that the array still isn’t fully sorted."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#bubble-sort-discussion",
    "href": "content/14_Searching_Sorting.html#bubble-sort-discussion",
    "title": "Searching and Sorting",
    "section": "Bubble Sort Discussion",
    "text": "Bubble Sort Discussion\n\n\nAdvantage:\n\nBubble Sort is an easy-to-understand algorithm.\n\nAlso, easy to implement.\n\n\n\n\n\n\nDisadvantage:\n\nSlow!\n\nBest, worst, average complexity?"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#selection-sort",
    "href": "content/14_Searching_Sorting.html#selection-sort",
    "title": "Searching and Sorting",
    "section": "Selection Sort",
    "text": "Selection Sort\nTo get an array A into ascending order:\n\n* for each index i in A:\n    - Find the index of the smallest element in the rest\n      of A (the sub-array from A[i+1] through A[size-1])\n      - call it min\n    - Swap A[i] with A[min]."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#selection-sort-discussion",
    "href": "content/14_Searching_Sorting.html#selection-sort-discussion",
    "title": "Searching and Sorting",
    "section": "Selection Sort Discussion",
    "text": "Selection Sort Discussion\n\n\nAdvantage\n\nVery easy to understand and implement.\n\n\n\n\n\nDisadvantage\n\nSlow!\n\nBest, worst, average complexity?"
  },
  {
    "objectID": "content/16_random_access.html#files-review-1",
    "href": "content/16_random_access.html#files-review-1",
    "title": "Binary Files and Random Access",
    "section": "Files – Review",
    "text": "Files – Review\n\nRequires the fstream header file.\nifstream objects are specialized for input\nofstream object are specialized for output\nfstream objects are more general – can do both input and output.\nOperators &lt;&lt; and &gt;&gt; work with file streams.\nget() and getline() also work with file streams."
  },
  {
    "objectID": "content/16_random_access.html#fstream-object",
    "href": "content/16_random_access.html#fstream-object",
    "title": "Binary Files and Random Access",
    "section": "fstream Object",
    "text": "fstream Object\n\nCan be used for input and/or output.\nMust specify the mode when opening the file.\n\nios::in – input\nios::out – output\nios::app – append\nThere are others…\n\nModes may be combined with bitwise OR:\n\nios::in | ios::out - gives input and output."
  },
  {
    "objectID": "content/16_random_access.html#binary-files-1",
    "href": "content/16_random_access.html#binary-files-1",
    "title": "Binary Files and Random Access",
    "section": "Binary Files",
    "text": "Binary Files\nTo read/write non-character data, you must cast using:\nreinterpret_cast&lt;char*&gt;( address_of_object )\n\n\nReason: The read() and write() methods are designed to input/output raw bytes of data. char is a convenient “package” for raw bytes.\n\n\nreinterpret_cast forces the compiler to treat a pointer/address of one type as if it were another.\n\n\nHere are the prototypes for read() and write():\nistream& read (char* s, streamsize n);\nostream& write (char* s, streamsize n);"
  },
  {
    "objectID": "content/16_random_access.html#random-access",
    "href": "content/16_random_access.html#random-access",
    "title": "Binary Files and Random Access",
    "section": "Random Access",
    "text": "Random Access\nThe idea is to create an “array-in-a-file” that can be accessed at any arbitrary location (index or offset) easily.\n\nShould probably be called “arbitrary access files”.\nEach item in the file (called a record) must be the same size.\nStructures and classes are both perfect for this.\n\n(provided they are constant-sized)"
  },
  {
    "objectID": "content/16_random_access.html#random-access-1",
    "href": "content/16_random_access.html#random-access-1",
    "title": "Binary Files and Random Access",
    "section": "Random Access",
    "text": "Random Access\n\nOpen the file for both input and output.\n\nWhile not always necessary, it often is.\n\nOpen file in binary mode\n\nASCII-encoding would be undesirable\n\nMove to desired location (seek)\n\nYou can seek the read and write position independently.*\n\nRead or write a record (or records).\n\nMust be done as a series of bytes (chars).\n\n\n\n* In theory, anyway. In reality, this is OS dependent."
  },
  {
    "objectID": "content/16_random_access.html#positioning",
    "href": "content/16_random_access.html#positioning",
    "title": "Binary Files and Random Access",
    "section": "Positioning",
    "text": "Positioning\nseekg() : “seek get” – move the “read cursor”\nseekp() : “seek put” – move the “write cursor”.\n\nCan be used to go to any location in a file.\nMath similar to pointer-based array access is used.\n\nSyntax:\nstream.seekg(offset,mode)\nstream.seekp(offset,mode)\nWhere stream is the file stream, offset_ is distance to seek (bytes), mode is where to start from (mathematically).\n// seek 25 bytes from the beginning of stream `fin`\nfin.seekg(25L, ios::beg);"
  },
  {
    "objectID": "content/16_random_access.html#useful-ios-methods",
    "href": "content/16_random_access.html#useful-ios-methods",
    "title": "Binary Files and Random Access",
    "section": "Useful ios Methods",
    "text": "Useful ios Methods\n\n\nstream.seekg() : seek “get” to an offset in stream\nstream.seekp() : seek “put” to an offset in stream\nstream.read() : read raw bytes from stream\nstream.write() : write raw bytes to stream\nstream.clear() : clear stream’s state flags\nstream.tellg() : where is the “get” cursor?\nstream.tellp() : where is the “put” cursor?"
  },
  {
    "objectID": "content/16_random_access.html#keep-records-simple",
    "href": "content/16_random_access.html#keep-records-simple",
    "title": "Binary Files and Random Access",
    "section": "Keep records simple",
    "text": "Keep records simple\nEvery record in a (simple) random-access file needs to be the same size (in bytes).\n\nAvoid using any attributes that are pointers.\nAvoid using any attribute type that is not trivially copyable:\n\nhttp://en.cppreference.com/w/cpp/types/is_trivially_copyable\n\n\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n//[...]\n// Let class A be the class you are interested in...\nstd::cout &lt;&lt; std::boolalpha;\nstd::cout &lt;&lt; std::is_trivially_copyable&lt;A&gt;::value &lt;&lt; '\\n';\n// if the output is 'false' then A is not trivially copyable."
  },
  {
    "objectID": "content/16_random_access.html#zero-memory-quickly",
    "href": "content/16_random_access.html#zero-memory-quickly",
    "title": "Binary Files and Random Access",
    "section": "Zero Memory Quickly",
    "text": "Zero Memory Quickly\nFor security, it is often desirable to clear all bytes associated with an object’s memory allocation. This can be done efficiently with memset():\nmemset() : (not a method) – useful for clearing memory within a record.\n\nmemset is defined in the &lt;cstring&gt; header file.\n\nSyntax:\nmemset(start,value,size)\n\n\n// zero all bytes contained in `myObj`:\nmemset(&myObj, 0, sizeof(myObj));\n// IMPORTANT:  Don't try this if your object contains non-primitive\n//             attributes or is a derived class!\n\n\n\n\n\n\n\n \n\n\nBinary Files and Random Access"
  },
  {
    "objectID": "content/18_Exceptions.html#exceptions",
    "href": "content/18_Exceptions.html#exceptions",
    "title": "Exceptions",
    "section": "Exceptions",
    "text": "Exceptions\n(When Everything Goes Wrong)\n\n\n\nUsed to communicate that something unexpected has occurred.\nAllows the programmer to deal with unexpected situations in a controlled manner.\nMay be as simple or as complex as desired (depending on usage in the program)\nIn C++, any data value can be used as an exception!"
  },
  {
    "objectID": "content/18_Exceptions.html#key-words",
    "href": "content/18_Exceptions.html#key-words",
    "title": "Exceptions",
    "section": "Key Words",
    "text": "Key Words\n\n\nthrow - Used to generate an exception and “throw” it up the call stack.\n\ntry – Used to enclose a block of code in which an exception might occur (allowing the programmer to handle it if it does).\n\ncatch – Used to detect and handle a specific type of exception, if it actually occurred during execution of a try block."
  },
  {
    "objectID": "content/18_Exceptions.html#exceptions-are-about-communication",
    "href": "content/18_Exceptions.html#exceptions-are-about-communication",
    "title": "Exceptions",
    "section": "Exceptions are about Communication",
    "text": "Exceptions are about Communication\n\n\nWhen something goes very wrong in a way that you cannot fix in the local context, exceptions give you a way to communicate that problem to a higher level in the program structure."
  },
  {
    "objectID": "content/18_Exceptions.html#flow-of-control",
    "href": "content/18_Exceptions.html#flow-of-control",
    "title": "Exceptions",
    "section": "Flow of Control",
    "text": "Flow of Control\n\n\nWhen something unexpected happens, a function may choose to throw an exception.\n\n\n\nAt this point, execution leaves the function immediately!\nException moved up the call stack until a try with a matching catch clause is found.\n\nExecution resumes with the first line of the catch block (if found).\n\nIf not caught, the exception eventually makes it up to the OS, which will shut down the process."
  },
  {
    "objectID": "content/18_Exceptions.html#what-happens",
    "href": "content/18_Exceptions.html#what-happens",
    "title": "Exceptions",
    "section": "What Happens?",
    "text": "What Happens?\n\ntry block is entered. totalDays() function is called.\nIf 1st parameter is between 0 and 7, calculate the number of days and return as usual (no exception).\nIf 1st parameter is out of range, exception of type const char* is thrown: Execution leaves the function immediately.\ntry block execution is halted, execution jumps to first catch block, looking for a  catch(const char*) \nSince the type matches, execution resumes in the catch block."
  },
  {
    "objectID": "content/18_Exceptions.html#notes",
    "href": "content/18_Exceptions.html#notes",
    "title": "Exceptions",
    "section": "Notes",
    "text": "Notes\n\nMany catch blocks may follow a single try (but there must be at least one).\nYou cannot catch without try, or try without catch.\ncatch blocks are scanned until one matches the type of the exception thrown.\ncatch blocks may or may not have formal parameter name (depending on whether the exception value itself will be needed inside the block)."
  },
  {
    "objectID": "content/18_Exceptions.html#missed-exceptions",
    "href": "content/18_Exceptions.html#missed-exceptions",
    "title": "Exceptions",
    "section": "Missed Exceptions",
    "text": "Missed Exceptions\n\nFailure to catch an exception just means it continues “flying” up the call stack.\nIf it gets all the way out of main() without being caught, the program will be terminated by the OS.\nIt is possible to define a “catch-all” catch block (although it is often considered sloppy to do so): catch( ... ) \n\nIf you define a “catch-all”, it should be the last catch in the chain."
  },
  {
    "objectID": "content/18_Exceptions.html#exception-classesobjects",
    "href": "content/18_Exceptions.html#exception-classesobjects",
    "title": "Exceptions",
    "section": "Exception Classes/Objects",
    "text": "Exception Classes/Objects\n\nAny type may be thrown. Even custom objects.\nWe can define objects specifically for this purpose.\nException classes are useful to put a meaningful name on the type (so that catch blocks are easy to understand).\n\nExample\ncatch( NullPointerException )\nis better than\ncatch( int )"
  },
  {
    "objectID": "content/18_Exceptions.html#exception-classes",
    "href": "content/18_Exceptions.html#exception-classes",
    "title": "Exceptions",
    "section": "Exception Classes",
    "text": "Exception Classes\n\nDon’t necessarily need members\n\nUnless they do: if the added functionality is useful, add it!\n\n\nExample\nclass NullPointerException{ };  // empty\nOr:\nclass NullPointerException{\n    public:\n        string msg;            // with attribute\n};"
  },
  {
    "objectID": "content/18_Exceptions.html#standard-exceptions",
    "href": "content/18_Exceptions.html#standard-exceptions",
    "title": "Exceptions",
    "section": "Standard Exceptions",
    "text": "Standard Exceptions\nThe C++ Standard Library defines an exception base class in the &lt;exception&gt; header.\n\nUseful (later) to make our own exceptions with nice common behaviors.\n\n#include&lt;exception&gt;\nusing std::exception;\n\nclass NullPointerException : public exception{\n    public:\n        virtual const char* what()const {\n            return “A null pointer was encountered.”;\n        }\n};"
  },
  {
    "objectID": "content/18_Exceptions.html#standard-exceptions-1",
    "href": "content/18_Exceptions.html#standard-exceptions-1",
    "title": "Exceptions",
    "section": "Standard Exceptions",
    "text": "Standard Exceptions\nAlso, Polymorphism!\ntry{\n    [...] \n}\ncatch(exception& e){   \n    // catches _any_ standard exception!\n    cout &lt;&lt; e.what()  &lt;&lt; endl;\n}"
  },
  {
    "objectID": "content/18_Exceptions.html#documentation-guidelines",
    "href": "content/18_Exceptions.html#documentation-guidelines",
    "title": "Exceptions",
    "section": "Documentation Guidelines",
    "text": "Documentation Guidelines\n\nExceptions require some new documentation… Here’s an example:\n\n\n/**\n * converts a numerical ranking in {1,2,3} to the corresponding \n * medal color from {\"gold\",\"silver\",\"bronze\"}\n * \n * @param  rank  integer numerical ranking; should be in {1,2,3}\n * @return the corresponding metal color for `rank` is returned \n *         from the set {\"gold\", \"silver\", \"bronze\"}.\n * @throw  std::invalid_argument is thrown if `rank` is not one\n *         of {1,2,3}.\n */\n\nNotice the @throw Doxygen tag – it should be used once for each type of exception your function may throw.\nBe sure to describe the exception type, as well as when/why it would be thrown.\n\n\n\n\n\n\n\n\n \n\n\nExceptions"
  },
  {
    "objectID": "content/22_Operator_Overloading.html#operators-are-functions",
    "href": "content/22_Operator_Overloading.html#operators-are-functions",
    "title": "Operator Overloading",
    "section": "Operators are Functions",
    "text": "Operators are Functions\nOperators in C++ are actually just symbolic shorthand for function calls.\n\n\nExample Expression:\narea = pi * r * r;\n\nConsider just the first operator that will be applied:\npi * r\n\n\nThis expression will actually result in the following function call:\noperator* (pi, r)\n\n\nThe entire expression could be written as:\noperator= ( operator*( operator*( pi, r ), r ));"
  },
  {
    "objectID": "content/22_Operator_Overloading.html#overloading-operators",
    "href": "content/22_Operator_Overloading.html#overloading-operators",
    "title": "Operator Overloading",
    "section": "Overloading Operators",
    "text": "Overloading Operators\nSince operators are really just function calls in disguise, if we know the right prototypes for the function calls, we can overload them.\n\nMost operators in C++ can be overloaded.*\nCorresponding functions are always named operator followed by the symbol for the operator.\n\n\n* The ones that cannot are:     ?:,    ::,    .,    .*,   sizeof,    typeid"
  },
  {
    "objectID": "content/22_Operator_Overloading.html#operator-prototypes",
    "href": "content/22_Operator_Overloading.html#operator-prototypes",
    "title": "Operator Overloading",
    "section": "Operator Prototypes",
    "text": "Operator Prototypes\nOperator function prototypes follow the following patterns, depending on the number of operands:\n\n\n\nBinary operators (2 operands):\n\nreturntype  operator &lt;SYMBOL&gt;(left_operand, right_operand)\n\n\n\n\n\nUnary operators (1 operand):\n\nreturntype  operator &lt;SYMBOL&gt;(right_operand)"
  },
  {
    "objectID": "content/22_Operator_Overloading.html#multiple-overloads-needed",
    "href": "content/22_Operator_Overloading.html#multiple-overloads-needed",
    "title": "Operator Overloading",
    "section": "Multiple Overloads Needed",
    "text": "Multiple Overloads Needed\nFraction operator* (const Fraction& lhs, const Fraction& rhs);\n\nThis prototype only covers a Fraction * Fraction expression.\n\nConsider int * Fraction, ** Fraction * int** , etc…\n\nMore overloaded functions are needed to support all desirable interfaces.\n\nOverload only when the operator makes sense for the new type being created!"
  },
  {
    "objectID": "content/22_Operator_Overloading.html#stream-operators-and",
    "href": "content/22_Operator_Overloading.html#stream-operators-and",
    "title": "Operator Overloading",
    "section": "Stream Operators << and >>",
    "text": "Stream Operators &lt;&lt; and &gt;&gt;\n\nBinary operators\nLeft-hand operand is the stream, and should be passed by reference.\n\n(Don’t make copies of streams.)\n\nRight-hand operand is the “thing” you are reading/writing.\nReturn type should be the stream, by reference.\n\nExample\nstd::ostream& operator&lt;&lt; (std::ostream&   strm, const Fraction& rhs);"
  },
  {
    "objectID": "content/22_Operator_Overloading.html#and---",
    "href": "content/22_Operator_Overloading.html#and---",
    "title": "Operator Overloading",
    "section": "++ and --",
    "text": "++ and --\n\n\nPrefix (++x or --x) \ntype& operator++ (type& rhs);\ntype& operator-- (type& rhs);\n\n\nPostfix (x++ or x--) \ntype operator++(type& lhs, int);\ntype operator--(type& lhs, int);\n\nNotice the “phantom” int second parameter — this is used only so that the compiler can tell the prefix and postfix versions apart.\nAlso note that a copy of lhs (with its previous value) is returned.\n\n\n\n\n\n\n\n\n \n\n\nOperator Overloading"
  },
  {
    "objectID": "content/24_Stack_Queue_CircularList.html#stacks",
    "href": "content/24_Stack_Queue_CircularList.html#stacks",
    "title": "Stacks, Queues, and Circular Lists",
    "section": "Stacks",
    "text": "Stacks\nA stack is a data structure optimized for addition and removal only at one end. It focuses on the last-in, first-out access pattern.\nStack Operations: Primary stack operations are:\n\npush : Add a value at the “top” of the stack.\npop : Remove the value at the “top” of the stack.\ntop : Access the value at the “top” of the stack, but do not remove it.\nOperations such as “write”, “clear”, etc. are also possible.\n\nStacks can easily be implemented as a singly-linked list where access is restricted to the “front”.\n\nadd_front() becomes push()\nremove_front() becomes pop()"
  },
  {
    "objectID": "content/24_Stack_Queue_CircularList.html#queues",
    "href": "content/24_Stack_Queue_CircularList.html#queues",
    "title": "Stacks, Queues, and Circular Lists",
    "section": "Queues",
    "text": "Queues\nA queue is a data structure optimized for addition at one end and removal at the other. It focuses on the first-in, first-out access pattern.\nQueue Operations: Primary queue operations are:\n\nenqueue : Add a value at the “end” of the queue.\ndequeue : Remove the value at the “front” of the queue.\nfront : Access the value at the “front” of the queue.\nOperations such as “write”, “clear”, etc. are also possible.\n\nQueues can easily be implemented as a singly-linked list where additions occur at the tail and removals are from the head (for efficiency):\n\nenqueue() becomes add_back()\ndequeue() becomes remove_front()"
  },
  {
    "objectID": "content/24_Stack_Queue_CircularList.html#priority-queue",
    "href": "content/24_Stack_Queue_CircularList.html#priority-queue",
    "title": "Stacks, Queues, and Circular Lists",
    "section": "Priority Queue",
    "text": "Priority Queue\nA priority queue is a data structure optimized to allow items to be added, then removed in an order according to some priority.\nEssentially, the enqueue operation is an “add in order” operation, inserting the item in the queue according to some pre-selected priority. For example, “larger first”.\nPriority Queue Operations: Primary queue operations are:\n\nenqueue : Add a value “in order” according to priority.\ndequeue : Remove the value at the “front” of the queue.\nfront : Access the value at the “front” of the queue.\nOperations such as “write”, “clear”, etc. are also possible."
  },
  {
    "objectID": "content/24_Stack_Queue_CircularList.html#priority-queue-1",
    "href": "content/24_Stack_Queue_CircularList.html#priority-queue-1",
    "title": "Stacks, Queues, and Circular Lists",
    "section": "Priority Queue",
    "text": "Priority Queue\nPriority queues can easily be implemented as a singly-linked list with in-order additions and removal from the head:\n\nenqueue() is the same as add_in_order()\ndequeue() is the same as remove_front()"
  },
  {
    "objectID": "content/24_Stack_Queue_CircularList.html#circular-list",
    "href": "content/24_Stack_Queue_CircularList.html#circular-list",
    "title": "Stacks, Queues, and Circular Lists",
    "section": "Circular List",
    "text": "Circular List\nA circular list is a list in which following the “next” pointer from the end of the list will place you back at the beginning of the list.\nUseful for tasks that need to be repeated.\nThe underlying list may be a singly-linked list or a doubly-linked list. You can also use an array as the underlying data structure.\n\n\n\nCircular Singly-Linked List\n\n\n\n\n\nCircular Doubly-Linked List\n\n\n\n\n\n\n\n\n\n \n\n\nStacks, Queues, and Circular Lists"
  },
  {
    "objectID": "content/26_Inheritance.html#inheritance",
    "href": "content/26_Inheritance.html#inheritance",
    "title": "Inheritance",
    "section": "Inheritance",
    "text": "Inheritance\nEstablishes an “is-a” relationship:\n\nA flower is a plant.\nAn ale is a beer.\nA lager is a beer.\nA truck is a vehicle.\n\nA dump truck is a truck.\n\nA mammal is a(n) animal.\n\nA dog is a mammal.\n\nA poodle is a dog.\n\n\n\n… Infinite examples: The real world works this way!"
  },
  {
    "objectID": "content/26_Inheritance.html#terminology-and-notation",
    "href": "content/26_Inheritance.html#terminology-and-notation",
    "title": "Inheritance",
    "section": "Terminology and Notation",
    "text": "Terminology and Notation\n\nBase class (or parent): the more general class… the “starting point”.\nDerived class (or child): more specialized, derived from base class.\nNotation:\n\n\nBase and derived class headers."
  },
  {
    "objectID": "content/26_Inheritance.html#how-is-a-works",
    "href": "content/26_Inheritance.html#how-is-a-works",
    "title": "Inheritance",
    "section": "How “is-a” Works",
    "text": "How “is-a” Works\nThe derived class object “is a(n)” object of the base class.\n\n\n\nHas all characteristics of base class!\n\nAll members defined in base class.\nPlus all members defined in derived class.\n\n\n\n\n\nDerived class objects can “use” (access):\n\nAll public or protected members of base class.\nAll members of derived class."
  },
  {
    "objectID": "content/26_Inheritance.html#how-is-a-works-1",
    "href": "content/26_Inheritance.html#how-is-a-works-1",
    "title": "Inheritance",
    "section": "How “is-a” Works",
    "text": "How “is-a” Works\n\n\n\nBase and derived class.\n\n\nThe physical object for a derived class object includes all parts of the base class, even though the private base class members are not directly accessible to derived class methods.\n\n\nWe define the logical object as the object as we perceive it to be, which may be different from the physical object. In particular, the logical object may rely on resources that are external to the physical object, but we perceive them as being a part of the “thing” we are interacting with.\nAn example of this is the std::string, in which the contents of the string itself is not a part of the physical object, even though we think of it as being a part of the “string” we are interacting with."
  },
  {
    "objectID": "content/26_Inheritance.html#wait-protected",
    "href": "content/26_Inheritance.html#wait-protected",
    "title": "Inheritance",
    "section": "Wait… protected?",
    "text": "Wait… protected?\n\nprotected : access specifier, similar to private\n\nExcept: protected members can be accessed by derived classes!\nUseful when you know you are writing a base class.\n\n\n\n\n\nprivate data from base class is part of derived class, but cannot be accessed."
  },
  {
    "objectID": "content/26_Inheritance.html#class-access-specifiers",
    "href": "content/26_Inheritance.html#class-access-specifiers",
    "title": "Inheritance",
    "section": "Class Access Specifiers",
    "text": "Class Access Specifiers\nYou may also inherit with a selected maximum level of access:\n\npublic\n\nTrue “is-a” relationship.\nDoes not change any member’s downstream access level.\n\n\nprotected\n\npublic items from base class become protected in derived class.\n\n\nprivate\n\npublic and protected items from base class become private in derived class.\nDerived class object cannot be treated as an object of the base class."
  },
  {
    "objectID": "content/26_Inheritance.html#class-access-specifiers-1",
    "href": "content/26_Inheritance.html#class-access-specifiers-1",
    "title": "Inheritance",
    "section": "Class Access Specifiers",
    "text": "Class Access Specifiers\n\nDiagram of effect of access specifiers."
  },
  {
    "objectID": "content/26_Inheritance.html#building-and-tearing-down",
    "href": "content/26_Inheritance.html#building-and-tearing-down",
    "title": "Inheritance",
    "section": "Building and Tearing-Down",
    "text": "Building and Tearing-Down\n\nBase class must be constructed before derived class.\nDerived class must be destructed before the base class.\nDerived class may pass arguments to base class constructor:\n\n    Square::Square(int s) : Rectangle{s, s} { }\nYou must use the constructor’s member initialization list for this."
  },
  {
    "objectID": "content/28_Sparse_Tables.html#possible-solution-using-linked-lists.",
    "href": "content/28_Sparse_Tables.html#possible-solution-using-linked-lists.",
    "title": "Sparse Tables",
    "section": "Possible solution using linked lists.",
    "text": "Possible solution using linked lists.\nImagine that we keep a linked list for each user, containing the information:\n\nWhich movie did the user rate?\nWhat was the rating for the movie?\n\nWe could use a 1-D array of these linked lists. (You could implement this as a 1-D array of head pointers as well, if you were writing the data structure from scratch for this purpose.)"
  },
  {
    "objectID": "content/32_AVL_Trees.html#keep-your-balance",
    "href": "content/32_AVL_Trees.html#keep-your-balance",
    "title": "Balancing Trees - AVL Trees",
    "section": "Keep your Balance",
    "text": "Keep your Balance\nAn AVL Tree is a tree where the height of the left and right subtrees always differ by at most one.\n\nEach node has an associated balance factor\n\nbalance = height(right) - height(left)\n\nThe AVL property states that the balance factor at all nodes must be in the range \\([-1,1]\\)."
  },
  {
    "objectID": "content/32_AVL_Trees.html#balance",
    "href": "content/32_AVL_Trees.html#balance",
    "title": "Balancing Trees - AVL Trees",
    "section": "Balance",
    "text": "Balance\nIf the magnitude of any node’s balance factor becomes \\(&gt;1\\), the tree must be balanced.\n\n4 cases (but 2 are symmetrical):\n\n“Heavy” on left subtree of left child.\n“Heavy” on right subtree of left child.\n“Heavy” on right subtree of right child.\n“Heavy” on left subtree of right child."
  },
  {
    "objectID": "content/32_AVL_Trees.html#fixing-the-balance",
    "href": "content/32_AVL_Trees.html#fixing-the-balance",
    "title": "Balancing Trees - AVL Trees",
    "section": "Fixing the Balance",
    "text": "Fixing the Balance\n\n\nWhen the balance factor rule is broken, we must correct the balance. That can be done by applying a transformation to the tree’s shape called a rotation. The rotation can be performed either in a clockwise (right) direction, or counter-clockwise (left) direction.\n\n\nA single rotation will have the effect of shifting some of the “weight” from one side of the node about which we are rotating (we call this node the pivot node) to the other."
  },
  {
    "objectID": "content/32_AVL_Trees.html#visualizations",
    "href": "content/32_AVL_Trees.html#visualizations",
    "title": "Balancing Trees - AVL Trees",
    "section": "Visualizations",
    "text": "Visualizations\n\n\nhttps://www.cs.usfca.edu/~galles/visualization/AVLtree.html\n\n\n\n\n\n\n\n \n\n\nBalancing Trees - AVL Trees"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#definition",
    "href": "content/34_Multiway_Trees.html#definition",
    "title": "Multiway Trees (m-Trees)",
    "section": "Definition",
    "text": "Definition\n\nA multiway tree of order \\(m\\) is a generalized tree in which each node may have up to \\(m\\) children (each of which may also be trees).\nA multiway search tree of order \\(m\\) is a multiway tree in which:\n\nEach node has \\(m\\) children and \\(m-1\\) keys.\nThe keys in each node are in ascending order\nThe keys in the first \\(i\\) children are less than the \\(i\\)th key.\nThe keys in the last \\(m-i\\) children are greater than the \\(i\\)th key."
  },
  {
    "objectID": "content/34_Multiway_Trees.html#b-trees",
    "href": "content/34_Multiway_Trees.html#b-trees",
    "title": "Multiway Trees (m-Trees)",
    "section": "B-Trees",
    "text": "B-Trees\n\nWhen storing data on secondary storage (such as a spinning-platter hard disk), the basic unit of storage is a block.\nBlocks tend to be rather large (in comparison to individual data values in memory).\nIt is inefficient to access the hard disk, so a data structure that makes efficient use of the disk block is desirable."
  },
  {
    "objectID": "content/34_Multiway_Trees.html#b-trees-1",
    "href": "content/34_Multiway_Trees.html#b-trees-1",
    "title": "Multiway Trees (m-Trees)",
    "section": "B-Trees",
    "text": "B-Trees\n\nIn a B-Tree, the node size is designed the same as a disk block.\nB-Trees (of order \\(m\\)) follow these rules:\n\nThe root has at least two subtrees unless it is a leaf.\nEach non-root and non-leaf node holds \\(k-1\\) keys and \\(k\\) pointers to subtrees where \\(k\\) is between ceil(m/2) and \\(m\\).\nEach leaf node holds \\(k-1\\) keys where \\(k\\) is between ceil(m/2) and \\(m\\).\nAll leaves are on the same level."
  },
  {
    "objectID": "content/34_Multiway_Trees.html#b-trees-2",
    "href": "content/34_Multiway_Trees.html#b-trees-2",
    "title": "Multiway Trees (m-Trees)",
    "section": "B-Trees",
    "text": "B-Trees\n\n\nExample of a B-tree of order 5:\n\n\n\nB-TreeDrozdek Figure 7.7"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#searching-a-b-tree",
    "href": "content/34_Multiway_Trees.html#searching-a-b-tree",
    "title": "Multiway Trees (m-Trees)",
    "section": "Searching a B-Tree",
    "text": "Searching a B-Tree\nBTNode* BTree::search(keyType k, BTNode* subroot=root) const {\n    int     i   = 0;\n    BTNode* ans = nullptr;\n    if(subroot){\n        while(i &lt; subroot-&gt;key_count && subroot-&gt;keys[i] &lt; k){\n            ++i;   // Do nothing, except increment i\n        }\n        if(i &gt;= subroot-&gt;key_count || subroot-&gt;keys[i] &gt; k){\n            ans = search(k, subroot-&gt;pointers[i]);\n        }\n        else{\n            ans = subroot;\n        }\n    }\n    return ans;\n}\n\nDrozdek Figure 7.7"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#insert-into-a-b-tree",
    "href": "content/34_Multiway_Trees.html#insert-into-a-b-tree",
    "title": "Multiway Trees (m-Trees)",
    "section": "Insert into a B-Tree",
    "text": "Insert into a B-Tree\n\nInserts occur at the leaf level (search down to where the value should appear, and insert in that leaf).\nIf the leaf is not full, the insert is finished.\nIf the leaf is full, it must be split into two leaves, with half of the values from the full leaf in each.\nThe middle value is chosen to move “up” to the parent node\nIf the parent node is also full, it too must split (and so on).\nSee Drozdek pg. 315-319"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#insert-key-into-a-b-tree-example",
    "href": "content/34_Multiway_Trees.html#insert-key-into-a-b-tree-example",
    "title": "Multiway Trees (m-Trees)",
    "section": "Insert key into a B-Tree : Example",
    "text": "Insert key into a B-Tree : Example\n\nB-TreeDrozdek Figure 7.8"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#insert-key-into-a-b-tree-example-1",
    "href": "content/34_Multiway_Trees.html#insert-key-into-a-b-tree-example-1",
    "title": "Multiway Trees (m-Trees)",
    "section": "Insert key into a B-Tree : Example",
    "text": "Insert key into a B-Tree : Example\n\nB-TreeDrozdek Figure 7.8"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#insert-key-into-a-b-tree-example-2",
    "href": "content/34_Multiway_Trees.html#insert-key-into-a-b-tree-example-2",
    "title": "Multiway Trees (m-Trees)",
    "section": "Insert key into a B-Tree : Example",
    "text": "Insert key into a B-Tree : Example\n\nB-TreeDrozdek Figure 7.8"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#delete-from-a-b-tree",
    "href": "content/34_Multiway_Trees.html#delete-from-a-b-tree",
    "title": "Multiway Trees (m-Trees)",
    "section": "Delete from a B-Tree",
    "text": "Delete from a B-Tree\n\nCare must be taken to always keep nodes at least half full.\nDeleting from a leaf:\n\nIf the leaf is left half-full (or more), done.\nIf the leaf is less than half-full:\n\nIf there is a left or right sibling that is over half-full, the keys are redistributed by moving the separator key from the parent down, then picking a new separator as the middle value from both nodes.\nIf all siblings are only exactly half-full, then the leaf is merged with a sibling, and the separating value from the parent is moved down to the new node (deleting it from the parent).\n\nThis may cause a chain-reaction if the parent underflows.\n\nA special case exists if the parent is the root with only one key. The nodes are merged into the parent’s location and the two leaf nodes are discarded. (height decreases one level)."
  },
  {
    "objectID": "content/34_Multiway_Trees.html#delete-from-a-b-tree-1",
    "href": "content/34_Multiway_Trees.html#delete-from-a-b-tree-1",
    "title": "Multiway Trees (m-Trees)",
    "section": "Delete from a B-Tree",
    "text": "Delete from a B-Tree\n\nDeleting from a non-leaf:\nCould cause problems with the organization of the tree, so it is avoided by reducing to deleting from a leaf\n\nFind the leaf with the immediate predecessor (or successor) of the value you are deleting.\nCopy the value of the predecessor to the target’s location.\nDelete the predecessor from the leaf.\n\nSee Drozdek pg. 319-321"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#delete-key-from-a-b-tree-example",
    "href": "content/34_Multiway_Trees.html#delete-key-from-a-b-tree-example",
    "title": "Multiway Trees (m-Trees)",
    "section": "Delete key from a B-Tree : Example",
    "text": "Delete key from a B-Tree : Example\n\nB-TreeDrozdek Figure 7.9"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#delete-key-from-a-b-tree-example-1",
    "href": "content/34_Multiway_Trees.html#delete-key-from-a-b-tree-example-1",
    "title": "Multiway Trees (m-Trees)",
    "section": "Delete key from a B-Tree : Example",
    "text": "Delete key from a B-Tree : Example\n\nB-TreeDrozdek Figure 7.9"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#delete-key-from-a-b-tree-example-2",
    "href": "content/34_Multiway_Trees.html#delete-key-from-a-b-tree-example-2",
    "title": "Multiway Trees (m-Trees)",
    "section": "Delete key from a B-Tree : Example",
    "text": "Delete key from a B-Tree : Example\n\nB-TreeDrozdek Figure 7.9"
  },
  {
    "objectID": "content/34_Multiway_Trees.html#b-b-r-trees",
    "href": "content/34_Multiway_Trees.html#b-b-r-trees",
    "title": "Multiway Trees (m-Trees)",
    "section": "B*, B+, R Trees",
    "text": "B*, B+, R Trees\n\nB* trees work like B-tree, except that nodes must remain 2/3 full at all times. (Average utilization becomes 81%.)\nB+ trees try to optimize traversals with respect to secondary storage by only storing data at the leaves, and using internal nodes as an “index”.\n\nEssentially they are just B-trees (indexes) with a linked-list “added” at the leaf-level.\nIn-order traversal can be performed at the leaf level only (it is a linked list!)\n\nR-trees represent spatial (2-D or 3-D) data."
  },
  {
    "objectID": "content/34_Multiway_Trees.html#vh-trees-or-red-black-trees",
    "href": "content/34_Multiway_Trees.html#vh-trees-or-red-black-trees",
    "title": "Multiway Trees (m-Trees)",
    "section": "V/H Trees (or Red-Black Trees)",
    "text": "V/H Trees (or Red-Black Trees)\n\nIf you restrict a B tree so that the order is small, it can be used for efficient search trees in memory.\n\nOrder 4 trees are often used (called 2-3-4 trees).\n\nDue to the overhead of the unused storage in each node, you might want to eliminate it and use a strict binary tree.\nWe can do both.\nRed-black trees (or vertical-horizontal trees) do this by maintaining two kinds of links (designated by a flag).\nOne kind links to children, the other links to other node elements within the same logical B-tree node.\nSee Drozdek 337-352."
  },
  {
    "objectID": "content/34_Multiway_Trees.html#tries",
    "href": "content/34_Multiway_Trees.html#tries",
    "title": "Multiway Trees (m-Trees)",
    "section": "Tries",
    "text": "Tries\n\nPronounced “try”, but comes from the word “retrieval”. 🤷‍♂️\nEach node contains only a part of the key being searched.\n\nOften, the keys are “words” (sequences of letters); each node contains a single letter.\nNodes are either leaf nodes (containing a word or the suffix or a word), or non-leaf nodes (with an array of pointers to sub-tries).\nVery fast for things like spell checkers, etc.\nTrie height depends on the length of common prefixes.\nSee Drozdek 364-372"
  },
  {
    "objectID": "content/36_Decision_Trees.html#decision-trees",
    "href": "content/36_Decision_Trees.html#decision-trees",
    "title": "Decision Trees",
    "section": "Decision Trees",
    "text": "Decision Trees\nA decision tree is a special form of tree with the following properties:\n\nEvery node has either zero or two children.\n\ni.e. they are strict binary trees.\n\nNodes represent a decision, which is a condition or query on some value in a dataset of interest. The decision must evaluate to a Boolean result.\nEdges represent the value of the result from the originating node: either True or False.\n\n(or “yes/no”, or other binary synonym)\n\nLeaf nodes contain a result, which is the value selected by the sequence of decisions represented by the path followed from the root to arrive at the leaf."
  },
  {
    "objectID": "content/36_Decision_Trees.html#decision-trees-uses",
    "href": "content/36_Decision_Trees.html#decision-trees-uses",
    "title": "Decision Trees",
    "section": "Decision Trees: Uses",
    "text": "Decision Trees: Uses\nThere are many uses for decision trees as a logical representation. Any problem where a sequence of “questions” or “queries” leads to a final result can be represented as a decision tree. Drozdek (Ch. 9.2) uses the example of a decision tree representing a sorting algorithm.\n\n\nEvaluating a decision tree is functionally equivalent to executing an “if-else chain” control structure, where each control path is required to eventually produce a value (which may be e.g. “None”) and is not allowed to perform any additional computation beyond the conditional expressions themselves (but these can be arbitrarily complex).\n\n\nApplication areas: Machine learning, data mining, financial analysis, artificial intelligence, business process control, personnel management, … (your imagination is the limit)"
  },
  {
    "objectID": "content/36_Decision_Trees.html#example-determine-letter-grade-given-a-score",
    "href": "content/36_Decision_Trees.html#example-determine-letter-grade-given-a-score",
    "title": "Decision Trees",
    "section": "Example: Determine letter grade given a score:",
    "text": "Example: Determine letter grade given a score:\n\n\n\n\nCode\n// Assume `score` is an integer, \n// for simplicity.\n// Assume `grade` is a character \n// variable that will hold\n// our result.\n\nif( score &gt;= 90 )\n    grade = 'A';\nelse if( score &gt;= 80 )\n    grade = 'B';\nelse if( score &gt;= 70 )\n    grade = 'C';\nelse if( score &gt;= 60 )\n    grade = 'D';\nelse\n    grade = 'F';\n\nDecision Tree\n\n\n\nA decision tree for a grading scale."
  },
  {
    "objectID": "content/36_Decision_Trees.html#example-determine-letter-grade-given-a-score-1",
    "href": "content/36_Decision_Trees.html#example-determine-letter-grade-given-a-score-1",
    "title": "Decision Trees",
    "section": "Example: Determine letter grade given a score:",
    "text": "Example: Determine letter grade given a score:\n\n\nNotice that we could optimize the tree a bit. Here is an alternate version (and corresponding code):\n\n\nDecision Tree\n\n\n\nA decision tree for a grading scale.\n\n\n\nCode\nif( score &gt;= 70 )\n    if(score &gt;= 80 )\n        if(score &gt;= 90)\n            grade = 'A';\n        else\n            grade = 'B';\n    else\n        grade = 'C'\nelse if( score &gt;= 60 )\n    grade = 'D';\nelse\n    grade = 'F';"
  },
  {
    "objectID": "content/36_Decision_Trees.html#sorting-visualized-as-a-dt",
    "href": "content/36_Decision_Trees.html#sorting-visualized-as-a-dt",
    "title": "Decision Trees",
    "section": "Sorting visualized as a DT",
    "text": "Sorting visualized as a DT\nIn the book, Drozdek uses the relationship between decision trees and search algorithms for an illustration of theoretical optimal search complexity.\nHere is “insertion sort” as one possible decision tree (sorting three values in variables a, b, and c):\n\nInsertion sort as a DT.Ref: Drozdek, Figure 9.4"
  },
  {
    "objectID": "content/36_Decision_Trees.html#how-many-leaves",
    "href": "content/36_Decision_Trees.html#how-many-leaves",
    "title": "Decision Trees",
    "section": "How many leaves?",
    "text": "How many leaves?\n\n\nIn general for an array of \\(n\\) elements, there are \\(n!\\) possible orderings.\nThat corresponds to at least \\(n!\\) leaf nodes in the decision tree! There could be more…"
  },
  {
    "objectID": "content/38_Hashing.html#what-is-hashing",
    "href": "content/38_Hashing.html#what-is-hashing",
    "title": "Hashing",
    "section": "What is Hashing?",
    "text": "What is Hashing?\nSearching often involves looking for a key, which is a way of uniquely identifying a record.\nIf the key is known, a hash table can be created using the value of the key as the only indication of position.\n\n\nSearching is then a \\(O(1)\\) operation…\n\n\nIf you know the key, you can go directly to the correct record in the table.\nIn practice, we can never perfectly achieve this, but we can get close."
  },
  {
    "objectID": "content/38_Hashing.html#you-may-have-seen-this-before.",
    "href": "content/38_Hashing.html#you-may-have-seen-this-before.",
    "title": "Hashing",
    "section": "You may have seen this before.",
    "text": "You may have seen this before.\nIf you have ever used dictionaries in Python, you are familiar with the concept of looking up a value in a collection by using a key that is not restricted to being an integer.\nMany languages have a concept of an associative array - that is just another name for this same kind of collection.\nIn C++ we have the std::map and std::multimap STL containers that provide this kind of collection.\nThe generic term is a key-value store.\nNote that none of these container types necessarily implies the underlying implementation is a hash table, but they all allow the kind of access that a hash table is designed to optimize."
  },
  {
    "objectID": "content/38_Hashing.html#terminology",
    "href": "content/38_Hashing.html#terminology",
    "title": "Hashing",
    "section": "Terminology",
    "text": "Terminology\nThe simplest possible example of a hash table is the C++ array.  The key is the index into the array.\nFor any more complex data than non-negative integers, we must somehow convert the non-integer key to a value we can use as an index.\nWe call a function that does this a hash function.1 \\[\nh(k) \\rightarrow i\n\\]\nA hash function that perfectly transforms all different keys into different numbers is called a perfect hash function.\n\\[\nh(k_n) \\rightarrow i_n,  \\;  \\textrm{s.t.} \\;  i_n \\neq i_m \\; \\forall \\; n \\neq m\n\\]\nThe term hash function is also used to describe the family of cryptographic hash functions, whose job is to provide a unique but unpredictable one-way mapping from an input data blob to an output signature representation. Cryptographic hash functions are different from the hash functions described here, and have very different operating characteristics."
  },
  {
    "objectID": "content/38_Hashing.html#terminology-1",
    "href": "content/38_Hashing.html#terminology-1",
    "title": "Hashing",
    "section": "Terminology",
    "text": "Terminology\nSo, a hash table must be large enough to accommodate all unique keys to be stored…\nIdeally, a function must be found that will convert all possible unique keys to unique table indices.\n\n\nThis is often difficult to achieve.\n\n\nAn imperfect hash function is one that produces the same number for two or more different keys.\nTwo keys that hash to the same value result in a collision."
  },
  {
    "objectID": "content/38_Hashing.html#example",
    "href": "content/38_Hashing.html#example",
    "title": "Hashing",
    "section": "Example",
    "text": "Example\nHash strings by adding up the integer (ASCII) values of each character in the string.\n\n\n“abc” would hash to 294  (97 + 98 + 99)\n\\[h( \\text{ abc } ) \\; \\rightarrow \\; 294\\]"
  },
  {
    "objectID": "content/38_Hashing.html#example-1",
    "href": "content/38_Hashing.html#example-1",
    "title": "Hashing",
    "section": "Example",
    "text": "Example\nHash strings by adding up the integer (ASCII) values of each character in the string.\n\n\n“abc” would hash to 294  (97 + 98 + 99)\n\\[h( \\text{ abc } ) \\; \\rightarrow \\; 294\\]\nProblem:  So would “cba” or “bac” or “bca” or “acb” or “cab”!"
  },
  {
    "objectID": "content/38_Hashing.html#example-2",
    "href": "content/38_Hashing.html#example-2",
    "title": "Hashing",
    "section": "Example",
    "text": "Example\nHash strings by adding up the integer (ASCII) values of each character in the string.\n\n\n“abc” would hash to 294  (97 + 98 + 99)\n\\[h( \\text{ abc } ) \\; \\rightarrow \\; 294\\]\nProblem:  So would “cba” or “bac” or “bca” or “acb” or “cab”!\nA good hash function must try to avoid collisions, while still being as efficient as possible.\nFor the lookup to be fast, the hash function must be fast!1\nThis is a sharp contrast to cryptographic hash functions, where speed is not always a desirable feature."
  },
  {
    "objectID": "content/38_Hashing.html#how-many-hash-functions-are-there",
    "href": "content/38_Hashing.html#how-many-hash-functions-are-there",
    "title": "Hashing",
    "section": "How Many Hash Functions Are There?",
    "text": "How Many Hash Functions Are There?\n\n\nTo assign positions to \\(n\\) items in a table of \\(m\\) positions (with \\(n \\leq m\\)), there are \\(m^n\\) possible hash functions.\n\n\nThe number of perfect hash functions is \\(\\frac{m!}{(m-n)!}\\). This is the number of placements of the items in the table.\n\n\nFor 50 elements in a 100-element table,  there are \\(100^{50}\\) = \\(10^{100}\\) hash functions, of which only \\(10^{94}\\) are perfect.\n\n\nSounds like it would be easy to find one… right?"
  },
  {
    "objectID": "content/38_Hashing.html#hash-table-size",
    "href": "content/38_Hashing.html#hash-table-size",
    "title": "Hashing",
    "section": "Hash Table Size",
    "text": "Hash Table Size\nA larger hash table can reduce the number of collisions…\n\n\nBut only if your hash function produces unique-enough addresses to take advantage of the increase in table size.\n\n\nExample:  If you are hashing based on the ASCII value of the first letter of a string, the value will be in the integer range \\([0,127]\\).\n\n\nMaking a hash table larger than 128 would just waste space."
  },
  {
    "objectID": "content/38_Hashing.html#handling-collisions",
    "href": "content/38_Hashing.html#handling-collisions",
    "title": "Hashing",
    "section": "Handling Collisions",
    "text": "Handling Collisions\nIn many cases, a perfect hash function cannot be found, or is impractical (too difficult or too computationally complex).\n\n\nSome method of dealing with collisions must be found."
  },
  {
    "objectID": "content/38_Hashing.html#hash-table-deletion",
    "href": "content/38_Hashing.html#hash-table-deletion",
    "title": "Hashing",
    "section": "Hash Table Deletion",
    "text": "Hash Table Deletion\nSimply remove the data – unless there was a collision…\n\n\nIn open addressing, deleting may break the pattern of probes…\n\n\nYou could leave a marker indicating that an element in position \\(i\\) with key \\(K\\) has been deleted, but that probing for other keys should continue.\n\nInserting new keys would overwrite a space-filler entry if possible.\nTable can become overloaded with “deleted entry” markers, making searches take longer than desired.\n\nTo avoid this, occasionally shift existing elements “up” the table to fill the deleted locations.  (The book calls this “purging” the table of deletion markers.)"
  },
  {
    "objectID": "content/38_Hashing.html#perfect-hash-functions",
    "href": "content/38_Hashing.html#perfect-hash-functions",
    "title": "Hashing",
    "section": "Perfect Hash Functions",
    "text": "Perfect Hash Functions\nUnless the set of possible keys is known in advance, it is usually not possible to find a perfect hash function…\n\n\nHowever, if the keys are known, a perfect hash function can be computed.\n\n\nExample:  A lookup table for the reserved words for a programming language.\n\n\nA perfect hash function that also requires only as many cells in the table as the number of data items is called a minimal perfect hash."
  },
  {
    "objectID": "content/38_Hashing.html#perfect-hash-functions-1",
    "href": "content/38_Hashing.html#perfect-hash-functions-1",
    "title": "Hashing",
    "section": "Perfect Hash Functions",
    "text": "Perfect Hash Functions\nMinimal perfect hash functions avoid both wasted time (for collision resolution) and space (for empty table cells).\n\n\nAlgorithms for choosing perfect hash functions are usually tedious.\n\n\nFor 50 elements in a 100 element table, only 1 in a million of the possible hash functions are perfect."
  },
  {
    "objectID": "content/38_Hashing.html#perfect-hash-functions-cichellis-method",
    "href": "content/38_Hashing.html#perfect-hash-functions-cichellis-method",
    "title": "Hashing",
    "section": "Perfect Hash Functions : Cichelli’s Method",
    "text": "Perfect Hash Functions : Cichelli’s Method\nDesigned for hashing a relatively small number of reserved words:\nh(word) = (length(word) \n            + g(firstletter(word))\n            + g(lastletter(word))\n          ) mod Tsize\nWhere \\(g\\) is the function to be constructed.\n\\(g\\) assigns values to letters so that the resulting hash function returns a unique hash for all words in a predefined language (set of words).\n\n\nThe values assigned by \\(g\\) to specific letters do not have to be unique.\n\n\nCichelli’s Algorithm is given in the book on pg. 539-540."
  },
  {
    "objectID": "content/38_Hashing.html#perfect-hash-functions-fhcd-algorithm",
    "href": "content/38_Hashing.html#perfect-hash-functions-fhcd-algorithm",
    "title": "Hashing",
    "section": "Perfect Hash Functions : FHCD Algorithm",
    "text": "Perfect Hash Functions : FHCD Algorithm\nAn extension of Cichilli’s Algorithm.\n\n\nHash is of the form\nh(word) = (h0(word) \n            + g(h1(word))\n            + g(h2(word))\n          ) mod Tsize\n\n\nProduces a table of g-values that must be stored in memory during operation (to make hashing efficient).\n\n\nSee section 10.4.2 in the textbook."
  },
  {
    "objectID": "content/38_Hashing.html#extendable-hashing",
    "href": "content/38_Hashing.html#extendable-hashing",
    "title": "Hashing",
    "section": "Extendable Hashing",
    "text": "Extendable Hashing\n\n\nIf the size of the hash table may change, additional complexity is added to the hashing algorithms.\n\n\nSee the book pgs. 571-573.\n\n\n\n\n\n\n\n \n\n\nHashing"
  }
]