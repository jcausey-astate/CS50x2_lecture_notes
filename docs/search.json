[
  {
    "objectID": "content/18_Exceptions.html#exceptions",
    "href": "content/18_Exceptions.html#exceptions",
    "title": "Exceptions",
    "section": "Exceptions",
    "text": "Exceptions\n(When Everything Goes Wrong)\n\n\n\nUsed to communicate that something unexpected has occurred.\nAllows the programmer to deal with unexpected situations in a controlled manner.\nMay be as simple or as complex as desired (depending on usage in the program)\nIn C++, any data value can be used as an exception!"
  },
  {
    "objectID": "content/18_Exceptions.html#key-words",
    "href": "content/18_Exceptions.html#key-words",
    "title": "Exceptions",
    "section": "Key Words",
    "text": "Key Words\n\n\nthrow - Used to generate an exception and “throw” it up the call stack.\n\ntry – Used to enclose a block of code in which an exception might occur (allowing the programmer to handle it if it does).\n\ncatch – Used to detect and handle a specific type of exception, if it actually occurred during execution of a try block."
  },
  {
    "objectID": "content/18_Exceptions.html#exceptions-are-about-communication",
    "href": "content/18_Exceptions.html#exceptions-are-about-communication",
    "title": "Exceptions",
    "section": "Exceptions are about Communication",
    "text": "Exceptions are about Communication\n\n\nWhen something goes very wrong in a way that you cannot fix in the local context, exceptions give you a way to communicate that problem to a higher level in the program structure."
  },
  {
    "objectID": "content/18_Exceptions.html#flow-of-control",
    "href": "content/18_Exceptions.html#flow-of-control",
    "title": "Exceptions",
    "section": "Flow of Control",
    "text": "Flow of Control\n\n\nWhen something unexpected happens, a function may choose to throw an exception.\n\n\n\nAt this point, execution leaves the function immediately!\nException moved up the call stack until a try with a matching catch clause is found.\n\nExecution resumes with the first line of the catch block (if found).\n\nIf not caught, the exception eventually makes it up to the OS, which will shut down the process."
  },
  {
    "objectID": "content/18_Exceptions.html#what-happens",
    "href": "content/18_Exceptions.html#what-happens",
    "title": "Exceptions",
    "section": "What Happens?",
    "text": "What Happens?\n\ntry block is entered. totalDays() function is called.\nIf 1st parameter is between 0 and 7, calculate the number of days and return as usual (no exception).\nIf 1st parameter is out of range, exception of type const char* is thrown: Execution leaves the function immediately.\ntry block execution is halted, execution jumps to first catch block, looking for a  catch(const char*) \nSince the type matches, execution resumes in the catch block."
  },
  {
    "objectID": "content/18_Exceptions.html#notes",
    "href": "content/18_Exceptions.html#notes",
    "title": "Exceptions",
    "section": "Notes",
    "text": "Notes\n\nMany catch blocks may follow a single try (but there must be at least one).\nYou cannot catch without try, or try without catch.\ncatch blocks are scanned until one matches the type of the exception thrown.\ncatch blocks may or may not have formal parameter name (depending on whether the exception value itself will be needed inside the block)."
  },
  {
    "objectID": "content/18_Exceptions.html#missed-exceptions",
    "href": "content/18_Exceptions.html#missed-exceptions",
    "title": "Exceptions",
    "section": "Missed Exceptions",
    "text": "Missed Exceptions\n\nFailure to catch an exception just means it continues “flying” up the call stack.\nIf it gets all the way out of main() without being caught, the program will be terminated by the OS.\nIt is possible to define a “catch-all” catch block (although it is often considered sloppy to do so): catch( ... ) \n\nIf you define a “catch-all”, it should be the last catch in the chain."
  },
  {
    "objectID": "content/18_Exceptions.html#exception-classesobjects",
    "href": "content/18_Exceptions.html#exception-classesobjects",
    "title": "Exceptions",
    "section": "Exception Classes/Objects",
    "text": "Exception Classes/Objects\n\nAny type may be thrown. Even custom objects.\nWe can define objects specifically for this purpose.\nException classes are useful to put a meaningful name on the type (so that catch blocks are easy to understand).\n\nExample\ncatch( NullPointerException )\nis better than\ncatch( int )"
  },
  {
    "objectID": "content/18_Exceptions.html#exception-classes",
    "href": "content/18_Exceptions.html#exception-classes",
    "title": "Exceptions",
    "section": "Exception Classes",
    "text": "Exception Classes\n\nDon’t necessarily need members\n\nUnless they do: if the added functionality is useful, add it!\n\n\nExample\nclass NullPointerException{ };  // empty\nOr:\nclass NullPointerException{\n    public:\n        string msg;            // with attribute\n};"
  },
  {
    "objectID": "content/18_Exceptions.html#standard-exceptions",
    "href": "content/18_Exceptions.html#standard-exceptions",
    "title": "Exceptions",
    "section": "Standard Exceptions",
    "text": "Standard Exceptions\nThe C++ Standard Library defines an exception base class in the &lt;exception&gt; header.\n\nUseful (later) to make our own exceptions with nice common behaviors.\n\n#include&lt;exception&gt;\nusing std::exception;\n\nclass NullPointerException : public exception{\n    public:\n        virtual const char* what()const {\n            return “A null pointer was encountered.”;\n        }\n};"
  },
  {
    "objectID": "content/18_Exceptions.html#standard-exceptions-1",
    "href": "content/18_Exceptions.html#standard-exceptions-1",
    "title": "Exceptions",
    "section": "Standard Exceptions",
    "text": "Standard Exceptions\nAlso, Polymorphism!\ntry{\n    [...] \n}\ncatch(exception& e){   \n    // catches _any_ standard exception!\n    cout &lt;&lt; e.what()  &lt;&lt; endl;\n}"
  },
  {
    "objectID": "content/18_Exceptions.html#documentation-guidelines",
    "href": "content/18_Exceptions.html#documentation-guidelines",
    "title": "Exceptions",
    "section": "Documentation Guidelines",
    "text": "Documentation Guidelines\n\nExceptions require some new documentation… Here’s an example:\n\n\n/**\n * converts a numerical ranking in {1,2,3} to the corresponding \n * medal color from {\"gold\",\"silver\",\"bronze\"}\n * \n * @param  rank  integer numerical ranking; should be in {1,2,3}\n * @return the corresponding metal color for `rank` is returned \n *         from the set {\"gold\", \"silver\", \"bronze\"}.\n * @throw  std::invalid_argument is thrown if `rank` is not one\n *         of {1,2,3}.\n */\n\nNotice the @throw Doxygen tag – it should be used once for each type of exception your function may throw.\nBe sure to describe the exception type, as well as when/why it would be thrown.\n\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nExceptions"
  },
  {
    "objectID": "content/16_random_access.html#files-review-1",
    "href": "content/16_random_access.html#files-review-1",
    "title": "Binary Files and Random Access",
    "section": "Files – Review",
    "text": "Files – Review\n\nRequires the fstream header file.\nifstream objects are specialized for input\nofstream object are specialized for output\nfstream objects are more general – can do both input and output.\nOperators &lt;&lt; and &gt;&gt; work with file streams.\nget() and getline() also work with file streams."
  },
  {
    "objectID": "content/16_random_access.html#fstream-object",
    "href": "content/16_random_access.html#fstream-object",
    "title": "Binary Files and Random Access",
    "section": "fstream Object",
    "text": "fstream Object\n\nCan be used for input and/or output.\nMust specify the mode when opening the file.\n\nios::in – input\nios::out – output\nios::app – append\nThere are others…\n\nModes may be combined with bitwise OR:\n\nios::in | ios::out - gives input and output."
  },
  {
    "objectID": "content/16_random_access.html#binary-files-1",
    "href": "content/16_random_access.html#binary-files-1",
    "title": "Binary Files and Random Access",
    "section": "Binary Files",
    "text": "Binary Files\nTo read/write non-character data, you must cast using:\nreinterpret_cast&lt;char*&gt;( address_of_object )\n\n\nReason: The read() and write() methods are designed to input/output raw bytes of data. char is a convenient “package” for raw bytes.\n\n\nreinterpret_cast forces the compiler to treat a pointer/address of one type as if it were another.\n\n\nHere are the prototypes for read() and write():\nistream& read (char* s, streamsize n);\nostream& write (char* s, streamsize n);"
  },
  {
    "objectID": "content/16_random_access.html#random-access",
    "href": "content/16_random_access.html#random-access",
    "title": "Binary Files and Random Access",
    "section": "Random Access",
    "text": "Random Access\nThe idea is to create an “array-in-a-file” that can be accessed at any arbitrary location (index or offset) easily.\n\nShould probably be called “arbitrary access files”.\nEach item in the file (called a record) must be the same size.\nStructures and classes are both perfect for this.\n\n(provided they are constant-sized)"
  },
  {
    "objectID": "content/16_random_access.html#random-access-1",
    "href": "content/16_random_access.html#random-access-1",
    "title": "Binary Files and Random Access",
    "section": "Random Access",
    "text": "Random Access\n\nOpen the file for both input and output.\n\nWhile not always necessary, it often is.\n\nOpen file in binary mode\n\nASCII-encoding would be undesirable\n\nMove to desired location (seek)\n\nYou can seek the read and write position independently.*\n\nRead or write a record (or records).\n\nMust be done as a series of bytes (chars).\n\n\n\n* In theory, anyway. In reality, this is OS dependent."
  },
  {
    "objectID": "content/16_random_access.html#positioning",
    "href": "content/16_random_access.html#positioning",
    "title": "Binary Files and Random Access",
    "section": "Positioning",
    "text": "Positioning\nseekg() : “seek get” – move the “read cursor”\nseekp() : “seek put” – move the “write cursor”.\n\nCan be used to go to any location in a file.\nMath similar to pointer-based array access is used.\n\nSyntax:\nstream.seekg(offset,mode)\nstream.seekp(offset,mode)\nWhere stream is the file stream, offset_ is distance to seek (bytes), mode is where to start from (mathematically).\n// seek 25 bytes from the beginning of stream `fin`\nfin.seekg(25L, ios::beg);"
  },
  {
    "objectID": "content/16_random_access.html#useful-ios-methods",
    "href": "content/16_random_access.html#useful-ios-methods",
    "title": "Binary Files and Random Access",
    "section": "Useful ios Methods",
    "text": "Useful ios Methods\n\n\nstream.seekg() : seek “get” to an offset in stream\nstream.seekp() : seek “put” to an offset in stream\nstream.read() : read raw bytes from stream\nstream.write() : write raw bytes to stream\nstream.clear() : clear stream’s state flags\nstream.tellg() : where is the “get” cursor?\nstream.tellp() : where is the “put” cursor?"
  },
  {
    "objectID": "content/16_random_access.html#keep-records-simple",
    "href": "content/16_random_access.html#keep-records-simple",
    "title": "Binary Files and Random Access",
    "section": "Keep records simple",
    "text": "Keep records simple\nEvery record in a (simple) random-access file needs to be the same size (in bytes).\n\nAvoid using any attributes that are pointers.\nAvoid using any attribute type that is not trivially copyable:\n\nhttp://en.cppreference.com/w/cpp/types/is_trivially_copyable\n\n\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n//[...]\n// Let class A be the class you are interested in...\nstd::cout &lt;&lt; std::boolalpha;\nstd::cout &lt;&lt; std::is_trivially_copyable&lt;A&gt;::value &lt;&lt; '\\n';\n// if the output is 'false' then A is not trivially copyable."
  },
  {
    "objectID": "content/16_random_access.html#zero-memory-quickly",
    "href": "content/16_random_access.html#zero-memory-quickly",
    "title": "Binary Files and Random Access",
    "section": "Zero Memory Quickly",
    "text": "Zero Memory Quickly\nFor security, it is often desirable to clear all bytes associated with an object’s memory allocation. This can be done efficiently with memset():\nmemset() : (not a method) – useful for clearing memory within a record.\n\nmemset is defined in the &lt;cstring&gt; header file.\n\nSyntax:\nmemset(start,value,size)\n\n\n// zero all bytes contained in `myObj`:\nmemset(&myObj, 0, sizeof(myObj));\n// IMPORTANT:  Don't try this if your object contains non-primitive\n//             attributes or is a derived class!\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nBinary Files and Random Access"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#linear-search",
    "href": "content/14_Searching_Sorting.html#linear-search",
    "title": "Searching and Sorting",
    "section": "Linear Search",
    "text": "Linear Search\nLinear search is a simple, brute-force approach:\n\n\nTo find a value V in array A:\n\n* For each index i in A,\n    - compare value at A[i] to V ...\n        + If they match, save i in I.\n        + otherwise, keep looking\n* After loop, either I contains the index where V \n  was found, or all elements have been examined \n  and V was not found.\n* Return the location I, \n  or an indication that V was not found."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#linear-search-discussion",
    "href": "content/14_Searching_Sorting.html#linear-search-discussion",
    "title": "Searching and Sorting",
    "section": "Linear Search Discussion",
    "text": "Linear Search Discussion\n\n\nAdvantages\n\nSimple to understand\nAlways finds the target value (if it is present)\nPlaces no requirement on the ordering of the array\n\n\n\n\n\nDisadvantage\n\nSlow\n\nBest, average, worst performance?"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#can-we-do-better",
    "href": "content/14_Searching_Sorting.html#can-we-do-better",
    "title": "Searching and Sorting",
    "section": "Can we do better?",
    "text": "Can we do better?\nIf you had a (paper) dictionary, how would you look up a word?\n\n\nWould you open to page 1 and start “scanning” each page?\n\n\n\n\nOr, would you use a divide-and-conquer approach?"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#binary-search",
    "href": "content/14_Searching_Sorting.html#binary-search",
    "title": "Searching and Sorting",
    "section": "Binary Search",
    "text": "Binary Search\nIf the values in your array are ordered, Binary Search is a fast approach to the search problem:\nTo find value V in ascending-ordered array ‘A’:\n\n* Mark the ends of the array, left and right.\n* While the array between left and right is non-empty,\n    - Calculate the index of the middle element (mid)\n    - if A[mid] matches V, save mid (in I) and \n    you are done.\n    - Otherwise, if A[mid] &lt; V, move left so that you \n    examine the right half of the array on next pass.\n    - Otherwise, move right to that the left half of \n    the array will be examined.\n* At end of loop, either index of V is saved, \nor V was not in the array.\n* Return I or an indication that V was not found."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#binary-search-discussion",
    "href": "content/14_Searching_Sorting.html#binary-search-discussion",
    "title": "Searching and Sorting",
    "section": "Binary Search Discussion",
    "text": "Binary Search Discussion\n\n\nAdvantage\n\nFast\n\nBest, average, worst performance?\n\n\n\n\n\n\nDisadvantage\n\nRequires array to be ordered\n\nWhat is the cost of sorting the array?\n\n\n\n\nHow do you choose between Binary Search and Linear Search?"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#search-summary",
    "href": "content/14_Searching_Sorting.html#search-summary",
    "title": "Searching and Sorting",
    "section": "Search Summary",
    "text": "Search Summary\n\n\n\n\nLinear search is slow ( \\(O(n)\\) ), but does not require ordered values.\n\n\n\n\nBinary search is fast ( \\(O(log_2(n))\\) ), but requires that the array is ordered."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#bubble-sort",
    "href": "content/14_Searching_Sorting.html#bubble-sort",
    "title": "Searching and Sorting",
    "section": "Bubble Sort",
    "text": "Bubble Sort\nTo get an array A into ascending order:\n\n\ncontinue the following until the array is sorted:\n\nfor each pair of elements in the array,\n\ncompare the pair to see if they are in order\n\nIf not, swap the values and make note that the array still isn’t fully sorted."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#bubble-sort-discussion",
    "href": "content/14_Searching_Sorting.html#bubble-sort-discussion",
    "title": "Searching and Sorting",
    "section": "Bubble Sort Discussion",
    "text": "Bubble Sort Discussion\n\n\nAdvantage:\n\nBubble Sort is an easy-to-understand algorithm.\n\nAlso, easy to implement.\n\n\n\n\n\n\nDisadvantage:\n\nSlow!\n\nBest, worst, average complexity?"
  },
  {
    "objectID": "content/14_Searching_Sorting.html#selection-sort",
    "href": "content/14_Searching_Sorting.html#selection-sort",
    "title": "Searching and Sorting",
    "section": "Selection Sort",
    "text": "Selection Sort\nTo get an array A into ascending order:\n\n* for each index i in A:\n    - Find the index of the smallest element in the rest\n      of A (the sub-array from A[i+1] through A[size-1])\n      - call it min\n    - Swap A[i] with A[min]."
  },
  {
    "objectID": "content/14_Searching_Sorting.html#selection-sort-discussion",
    "href": "content/14_Searching_Sorting.html#selection-sort-discussion",
    "title": "Searching and Sorting",
    "section": "Selection Sort Discussion",
    "text": "Selection Sort Discussion\n\n\nAdvantage\n\nVery easy to understand and implement.\n\n\n\n\n\nDisadvantage\n\nSlow!\n\nBest, worst, average complexity?"
  },
  {
    "objectID": "content/12_vector.html#the-c-standard-template-library",
    "href": "content/12_vector.html#the-c-standard-template-library",
    "title": "STL and Vectors",
    "section": "The C++ Standard Template Library",
    "text": "The C++ Standard Template Library\n\nWhat is STL?\nWhy use STL?\nOverview of STL Features and Concepts\nContainers\nIterators\nAlgorithms\nReferences for more information on STL"
  },
  {
    "objectID": "content/12_vector.html#what-is-stl",
    "href": "content/12_vector.html#what-is-stl",
    "title": "STL and Vectors",
    "section": "What is STL?",
    "text": "What is STL?\n\n“The Standard Template Library provides a set of well structured generic C++ components that work together in a seamless way.”\n- Alexander Stepanov & Meng Lee, The Standard Template Library\n\n\nDesigned to provide a common, familiar interface.\nDesigned to meet specific performance/complexity goals.\nKeeps programmers from “re-inventing the wheel”."
  },
  {
    "objectID": "content/12_vector.html#why-use-stl",
    "href": "content/12_vector.html#why-use-stl",
    "title": "STL and Vectors",
    "section": "Why Use STL?",
    "text": "Why Use STL?\n\nReuse: “Write less, do more”\n\nSTL hides complex, error-prone details.\nAllows you to focus on the problem.\nType-safe compatibility between components.\n\nFlexibility\n\nIterators decouple algorithms from containers.\nUnanticipated combinations easily supported.\n\nEfficiency\n\nTemplates avoid virtual function overhead.\nStrict attention to time and/or space complexity of algorithms."
  },
  {
    "objectID": "content/12_vector.html#stl-features-and-concepts",
    "href": "content/12_vector.html#stl-features-and-concepts",
    "title": "STL and Vectors",
    "section": "STL Features and Concepts",
    "text": "STL Features and Concepts\n\nContainers\n\nSequence: vector, list, deque\nAssociative: set, multiset, map, multimap\n\nAdapters: stack, queue, priority_queue\nIterators\n\nUsed to access elements in containers\nInput, output, forward, bidirectional, & random access\nEach container declares a trait for the type of iterator it provides\n\nGeneric Algorithms\n\nMutating, non-mutating, sorting, numeric"
  },
  {
    "objectID": "content/12_vector.html#stl-containers",
    "href": "content/12_vector.html#stl-containers",
    "title": "STL and Vectors",
    "section": "STL Containers",
    "text": "STL Containers\n\nSTL Containers are Abstract Data Types (ADTs)\nAll containers are parameterized by the type(s) they contain.\nAll declare traits :\n\ne.g. iterator, const_iterator, value_type, etc."
  },
  {
    "objectID": "content/12_vector.html#container-types",
    "href": "content/12_vector.html#container-types",
    "title": "STL and Vectors",
    "section": "Container Types",
    "text": "Container Types\n\nSequence\n\nProvide efficient linear access to data\nElement order is not related to value\nThink arrays and linked lists\n\nAssociative\n\nProvide efficient access to data stored as a key/value pair\nKeys can be ordered by operator&lt;\nImplemented as balanced binary trees\n\nAdapters\n\nProvide alternative ways to access sequence and associative containers\ne.g. stack, queue, priority_queue"
  },
  {
    "objectID": "content/12_vector.html#stdvector-example",
    "href": "content/12_vector.html#stdvector-example",
    "title": "STL and Vectors",
    "section": "std::vector Example",
    "text": "std::vector Example\nusing std::vector;\nusing std::string;\n// [...]\nvector&lt;string&gt; v;                   // create vector\n\nv.push_back(\"The number is 10\");    // push some values\nv.push_back(\"The number is 20\");    // into it...\nv.push_back(\"The number is 30\");\n\ncout &lt;&lt; \"Loop by index:\" &lt;&lt; endl;\n\nfor(vector&lt;string&gt;::size_type i=0;  // size type is unsigned\n    i &lt; v.size();                   // vector knows its size!\n    i++){                           // print values by\n   cout &lt;&lt; v[i] &lt;&lt; endl;            // indexing the\n}                                   // vector like an array\n\n\n\n\n\n\nHINT: Use v.at(i) instead of v[i] to enable bounds-checking!"
  },
  {
    "objectID": "content/12_vector.html#stdvector-example-2",
    "href": "content/12_vector.html#stdvector-example-2",
    "title": "STL and Vectors",
    "section": "std::vector Example 2",
    "text": "std::vector Example 2\nstd::vector&lt;std::string&gt; v;         // create vector\n\nv.push_back(\"The number is 10\");    // push some values\nv.push_back(\"The number is 20\");    // into it...\nv.push_back(\"The number is 30\");\n\ncout &lt;&lt; \"Loop by range using iterators:\" &lt;&lt; endl;\n\nfor(auto it = v.begin();            // iterator\n    it != v.end();                  // runs from begin()\n    ++it)                           // to end(), one at a time\n{                                   // and is\n   cout &lt;&lt; *it &lt;&lt; endl;             // dereferenced to\n}                                   // print the value\n\nThink of an iterator as an arrow pointing to a value in the container.\nThe dereference operator (*) is used to “follow the arrow” to get the value an iterator is pointing to."
  },
  {
    "objectID": "content/12_vector.html#stdvector-example-3",
    "href": "content/12_vector.html#stdvector-example-3",
    "title": "STL and Vectors",
    "section": "std::vector Example 3",
    "text": "std::vector Example 3\nstd::vector&lt;std::string&gt; v;         // create vector\n\nv.push_back(\"The number is 10\");    // push some values\nv.push_back(\"The number is 20\");    // into it...\nv.push_back(\"The number is 30\");\n\ncout &lt;&lt; \"Loop by range-based `for`:\" &lt;&lt; endl;\n\nfor( auto item : v ){               // for each item in v\n   cout &lt;&lt; item &lt;&lt; endl;            // print the item\n}"
  },
  {
    "objectID": "content/12_vector.html#stdvector-example-4",
    "href": "content/12_vector.html#stdvector-example-4",
    "title": "STL and Vectors",
    "section": "std::vector Example 4",
    "text": "std::vector Example 4\nauto v = std::vector&lt;std::string&gt;{3};    // pre-size to 3\n\nint  n = 1;\nfor( auto& item : v){                    // each item (by ref.)\n    item = std::string{\"The number is \"} // generate message\n         + std::to_string(10 * n++);     // and store in item\n}\n\ncout &lt;&lt; \"Loop by range:\" &lt;&lt; endl;\n\nfor( auto item : v ){                    // for each item\n   cout &lt;&lt; item &lt;&lt; endl;                 // print the item\n}\nstd::to_string() is contained in &lt;std::string&gt;"
  },
  {
    "objectID": "content/12_vector.html#iterators",
    "href": "content/12_vector.html#iterators",
    "title": "STL and Vectors",
    "section": "Iterators",
    "text": "Iterators\nIterators are a generalization of pointers.\n\nUsed to access information in containers, regardless of the internal layout\nFour types:\n\nForward (uses ++)\nBidirectional (uses ++ and --)\nRandom-access (behave like normal pointers)\nInput (can be used with input streams)\nOutput (can be used with output streams)"
  },
  {
    "objectID": "content/12_vector.html#iterator-example",
    "href": "content/12_vector.html#iterator-example",
    "title": "STL and Vectors",
    "section": "Iterator Example",
    "text": "Iterator Example\nstd::vector&lt;int&gt; scores{3};  // pre-size to 3\n\nscores.at(0) = 88;\nscores.at(1) = 92;\nscores.at(2) = 76;\n\nfor(auto it = scores.begin(); it != grade_list.end(); it++){\n    std::cout &lt;&lt; *it &lt;&lt; '\\t';\n}\nstd::cout &lt;&lt; '\\n';"
  },
  {
    "objectID": "content/12_vector.html#vector-modifiers",
    "href": "content/12_vector.html#vector-modifiers",
    "title": "STL and Vectors",
    "section": "vector Modifiers",
    "text": "vector Modifiers\nThese are algorithms that vectors know how to apply to themselves:\nclear()     : clears all contents (empties the container)\nerase()     : erase one element, given an iterator to it\ninsert()    : inserts element before a position (given an iterator)\npop_back()  : removes the last element\npush_back() : adds a new element at the end\nresize()    : changes the size of the vector\n[...] There are others not shown here"
  },
  {
    "objectID": "content/12_vector.html#passing-vectors-to-functions",
    "href": "content/12_vector.html#passing-vectors-to-functions",
    "title": "STL and Vectors",
    "section": "Passing vectors to functions",
    "text": "Passing vectors to functions\nstd::vector is an object type, meaning that it is passed by value by default! This means that even though it “looks and feels” like an array, the argument-to-parameter communication mechanism is quite different.\nLet’s look at an example…"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#parallel-arrays",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#parallel-arrays",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Parallel Arrays",
    "text": "Parallel Arrays\n\nParallel Arrays: Two or more arrays containing related data such that the elements at corresponding indexes are related.\n\nAll elements at index i the parallel arrays make up a single record i.\n\n\nExample\nconst int   N_CONTESTANTS = 5;\nstd::string names[N_CONTESTANTS];\nint         votes[N_CONTESTANTS];\n// Each contestant has a name and a vote count.\nfor(int i = 0; i &lt; N_CONTESTANTS; i++){\n    std::cout &lt;&lt; \"Contestant \" &lt;&lt; (i+1) &lt;&lt; \" name: \";\n    std::cin  &gt;&gt; names[i];\n    std::cout &lt;&lt; \"# of votes for \" &lt;&lt; names[i] &lt;&lt; \": \";\n    std::cin  &gt;&gt; votes[i];\n}"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#parallel-arrays-1",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#parallel-arrays-1",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Parallel Arrays",
    "text": "Parallel Arrays\n\nSince the parallel arrays are separate, they may be of mixed type.\nAny operation that updates one of the parallel arrays must update all others to maintain the parallel property.\nAll arrays must be passed to functions separately (although one “size” parameter is usually sufficient)."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#dimensional-arrays",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#dimensional-arrays",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "2-Dimensional Arrays",
    "text": "2-Dimensional Arrays\nC++ allows multiple dimensions for arrays. This is achieved by simply adding additional size declarators:\nint votes[5][3]; // create array with 5 rows and 3 columns\n\nNotice that two sets of square brackets are needed for a 2-D array.\nSame rules apply for size declarators here. (constants or literals only)"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#layout-logical",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#layout-logical",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Layout (Logical)",
    "text": "Layout (Logical)\nint votes[5][3]; // create array with 5 rows and 3 columns\n\n2-D Array of integers."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#layout-physical",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#layout-physical",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Layout (Physical)",
    "text": "Layout (Physical)\nint votes[5][3]; // create array with 5 rows and 3 columns\nIn reality, all physical memory is 1-dimensional.\nRows are sequential!\n\n2-D Array of integers."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#using-constants-for-size",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#using-constants-for-size",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Using Constants for Size",
    "text": "Using Constants for Size\nAvoid “magic numbers” by using named constants for size declarators:\nconst int N_CONTESTANTS = 5; // # of contestants\nconst int N_DAYS        = 3; // contest length\n\n// [...]\n\nint votes[N_CONTESTANTS][N_DAYS]; // table of contest votes\n\n\n\n\n\n\nIt can sometimes be useful to allow these constants to be global in some cases (as we will see shortly)."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#working-with-2-d-arrays",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#working-with-2-d-arrays",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Working with 2-D Arrays",
    "text": "Working with 2-D Arrays\nAlmost all operations on 2-D arrays will require nested loops.\nThink “for each row, for each column, do some operation”.\n// Initialize \"votes\" array:\nfor(int i = 0; i &lt; N_CONTESTANTS; i++){\n    for(int j = 0; j &lt; N_DAYS; j++){\n        votes[i][j] = 0;\n    }\n}"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#d-arrays-as-formal-parameters",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#d-arrays-as-formal-parameters",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "2-D Arrays as Formal Parameters",
    "text": "2-D Arrays as Formal Parameters\nBecause of the reality of the physical (1-D) layout of the array, C++ requires that you specify a size declarator for every dimension except the first when listing arrays in formal parameter lists.\nvoid print_matrix( int matrix[][4], int n_rows ){\n    for(int i = 0; i &lt; n_rows; i++){\n        for(int j = 0; j &lt; 4; j++){\n            std::cout &lt;&lt; matrix[i][j] &lt;&lt; \"\\t\";\n        }\n        std::cout &lt;&lt; \"\\n\";\n    }\n}\nThe number of rows can still be a parameter, allowing it to vary."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#d-arrays-as-formal-parameters-1",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#d-arrays-as-formal-parameters-1",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "2-D Arrays as Formal Parameters",
    "text": "2-D Arrays as Formal Parameters\nAgain, to avoid “magic numbers”, we often set up global constants for the sizes of each dimension after the first:\nconst int N_COLS = 4; // GLOBAL constant, defined at top.\n\n// [ ... ]\n\nvoid print_matrix( int matrix[][N_COLS], int n_rows ){\n    for(int i = 0; i &lt; n_rows; i++){\n        for(int j = 0; j &lt; N_COLS; j++){\n            std::cout &lt;&lt; matrix[i][j] &lt;&lt; \"\\t\";\n        }\n        std::cout &lt;&lt; \"\\n\";\n    }\n}"
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#arrays-of-higher-dimension",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#arrays-of-higher-dimension",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Arrays of Higher Dimension",
    "text": "Arrays of Higher Dimension\nThere is no (practical) limit on the number of dimensions an array can have.\nHigher-dimensional arrays require substantial memory resources.\n\n\nExample: 3-D Array\nconst int ROWS  = 8;\nconst int COLS  = 8;\nconst int MOVES = 100; // Number of replay steps\n// [...]\nint game_board_over_time[MOVES][ROWS][COLS];\nRequires 8 * 8 * 100 * sizeof(int) =&gt; 25600 bytes (25 KB)."
  },
  {
    "objectID": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#arrays-of-higher-dimension-1",
    "href": "content/10_Parallel_and_Multi-Dimensional_Arrays.html#arrays-of-higher-dimension-1",
    "title": "Parallel and Multi-Dimensional Arrays",
    "section": "Arrays of Higher Dimension",
    "text": "Arrays of Higher Dimension\nOperations just require more nested loops (one for each dimension):\n\n\nfor(int move = 0; move &lt; MOVES; move++){\n    for(int r = 0; r &lt; ROWS; r++){\n        for(int c = 0; c &lt; COLUMNS; c++){\n            cout &lt;&lt; game_board_over_time[move][r][c]\n                 &lt;&lt; \"\\t\";\n        }\n        cout &lt;&lt; \"\\n\";\n    }\n}\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nParallel and Multi-Dimensional Arrays"
  },
  {
    "objectID": "content/08_Arrays.html#the-c-array",
    "href": "content/08_Arrays.html#the-c-array",
    "title": "Arrays",
    "section": "The C++ Array",
    "text": "The C++ Array\nAn array is a data structure consisting of multiple values of the same type stored contiguously in memory and accessed by an integer index representing the offset of the desired element from the beginning of the array.\nArrays allow programmers to store multiple related values of the same type.\n\nValues are stored sequentially in memory.\nDeclaration syntax:  type arrayname[ size_declarator ];\n\nExample Declarations\nint    a[100]; // Declares an array of 100 integers.\ndouble b[50];  // Declares an array of 50 doubles."
  },
  {
    "objectID": "content/08_Arrays.html#array-memory-layout",
    "href": "content/08_Arrays.html#array-memory-layout",
    "title": "Arrays",
    "section": "Array Memory Layout",
    "text": "Array Memory Layout\nThe declaration:\nint tests[5];\nallocates the following memory:\n\nArray elements are contiguous boxes in memory.\nArrays are a reference type.\n\nThe array variable does not refer to the array as a whole, only to the location of the first element."
  },
  {
    "objectID": "content/08_Arrays.html#terminology",
    "href": "content/08_Arrays.html#terminology",
    "title": "Arrays",
    "section": "Terminology",
    "text": "Terminology\nIn the declaration:  int tests[5];\n\nint is the data type of all elements in the array.\ntests is the name of the array.\n5 (in [5]) is the size declarator. It specifies the number of elements.\n\nThe storage size of the array is \\(N \\times S\\) where \\(N\\) is the number of elements and \\(S\\) is the size (in bytes) of each element.\nThe size declarator must be either a literal or constant."
  },
  {
    "objectID": "content/08_Arrays.html#size-declarators",
    "href": "content/08_Arrays.html#size-declarators",
    "title": "Arrays",
    "section": "Size Declarators",
    "text": "Size Declarators\nNamed constants are often used as size declarators.\nconst int class_size = 5;\nint       tests[class_size];\n\nMakes maintenance easier if size needs to change.\nAvoids creating “magic numbers”.\n\nmagic numbers are literal numeric values that appear repeatedly for reasons that are non-obvious by the context."
  },
  {
    "objectID": "content/08_Arrays.html#indexes-and-elements",
    "href": "content/08_Arrays.html#indexes-and-elements",
    "title": "Arrays",
    "section": "Indexes and Elements",
    "text": "Indexes and Elements\nEach individual data item in an array is referred to as an array element.\n\n\n\n\nArray elements are contiguous boxes in memory.\n\n\nElements are identified by an integer index, starting from 0.\n\n\n\n\nArray elements are identified by integer indices."
  },
  {
    "objectID": "content/08_Arrays.html#initial-values",
    "href": "content/08_Arrays.html#initial-values",
    "title": "Arrays",
    "section": "Initial Values",
    "text": "Initial Values\nArray elements start out uninitialized if their base types do (primitive types, for example).\n\n\n\nArray elements are uninitialized.\n\n\nUse the element’s index number and array index syntax to access individual elements:\ntests[0] = 88;\n\n\n\nArray with first value initialized."
  },
  {
    "objectID": "content/08_Arrays.html#generate-indices-with-a-loop",
    "href": "content/08_Arrays.html#generate-indices-with-a-loop",
    "title": "Arrays",
    "section": "Generate Indices with a Loop",
    "text": "Generate Indices with a Loop\nThe array index may be specified by a literal, variable, or integer expression.\n\n\n// Assume \"tests\" has been initialized as shown previously...\n\n// Display tests from tests array to standard output:\nfor(int i = 0; i &lt; 5; i++){\n    std::cout &lt;&lt; tests[i] &lt;&lt; \"\\n\";\n}"
  },
  {
    "objectID": "content/08_Arrays.html#uniform-initialization-syntax",
    "href": "content/08_Arrays.html#uniform-initialization-syntax",
    "title": "Arrays",
    "section": "Uniform Initialization Syntax",
    "text": "Uniform Initialization Syntax\nint tests[] { 88, 92, 76, 85, 63 };\nProduces: \n\nSize declarator is optional here, since the compiler can count.\nThis is only useful if you know all of the values that will be stored at the time you are writing the program.\n\nThat is rarely the case.\n\nLoops are generally the best option.\n\n\n\nThe old way to do this was called “array initializer syntax”. It looks similar, but uses the assignment operator:\nint tests[] = { 88, 92, 76, 85, 63 };\nWe prefer the modern version using Uniform Initialization Syntax."
  },
  {
    "objectID": "content/08_Arrays.html#array-assignment",
    "href": "content/08_Arrays.html#array-assignment",
    "title": "Arrays",
    "section": "Array Assignment",
    "text": "Array Assignment\n\n\n\n\n\n\n\n\nYou cannot directly assign one array to another:\ncopy_of_tests = tests;  // WILL NOT WORK!!!\n\n\n\n\n\nCorrect way - Assign element-by-element:\nfor(int i = 0; i &lt; 5; i++){\n    copy_of_tests[i] = tests[i];\n}"
  },
  {
    "objectID": "content/08_Arrays.html#arrays-as-parameters",
    "href": "content/08_Arrays.html#arrays-as-parameters",
    "title": "Arrays",
    "section": "Arrays as Parameters",
    "text": "Arrays as Parameters\n\n\nArrays may be passed to functions:\nvoid print_tests(int tests[], int size){\n    for(int i = 0; i &lt; size; i++){\n        std::cout &lt;&lt; tests[i] &lt;&lt; \"\\n\";\n    }\n}\n\n\nNotice that the array’s size must also be passed.\n\nArrays do not “know their own size”.\n\n\n\n\n\nNotice the empty size declarator in the formal parameter.\n\nThe first dimension does not require (or allow) a size declarator in a formal parameter declaration.\n\n\n\n\n\nArrays are always passed by reference."
  },
  {
    "objectID": "content/08_Arrays.html#d-arrays-key-points-summary",
    "href": "content/08_Arrays.html#d-arrays-key-points-summary",
    "title": "Arrays",
    "section": "1-D Arrays Key Points Summary",
    "text": "1-D Arrays Key Points Summary\n\nSize declarator must be a literal or constant.\nC++ provides no bounds-checking for indices.\nArray elements start out uninitialized if their base types do.\n\nThey are default constructed if the base type is a structured or object type.\n\nArrays cannot be directly assigned.\nArrays are always passed by reference to functions.\nArrays do not “know” their own size.\n\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nArrays"
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#review-pass-by-value",
    "href": "content/06_Functions_Reference_Parameters.html#review-pass-by-value",
    "title": "Functions and Reference Parameters",
    "section": "Review: Pass by Value",
    "text": "Review: Pass by Value\n\nIn pass by value, the value of the actual parameter is copied into the formal parameter.\nPass by value is the default method by which data is moved into a function for primitive types, structured types and object types.\n\nChanges to the formal parameter cannot affect the actual parameter."
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#pass-by-reference",
    "href": "content/06_Functions_Reference_Parameters.html#pass-by-reference",
    "title": "Functions and Reference Parameters",
    "section": "Pass by Reference",
    "text": "Pass by Reference\n\nIn pass by reference, no copy is made.\nThe formal parameter simply becomes an alias for the actual parameter.\nAny changes made to the formal parameter inside the function will be reflected in the actual parameter following the call.\n\nDanger! You can damage the actual parameter!\n\nC++ arrays are passed by reference by default."
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#passing-by-reference",
    "href": "content/06_Functions_Reference_Parameters.html#passing-by-reference",
    "title": "Functions and Reference Parameters",
    "section": "Passing by Reference",
    "text": "Passing by Reference\n\nA reference parameter is a formal parameter that is an alias for the actual parameter.\nCreated by adding the reference type modifier in the formal parameter declaration.\n\nThe reference type modifier is the ampersand (&):  void readXY( int& x, int& y );"
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#why",
    "href": "content/06_Functions_Reference_Parameters.html#why",
    "title": "Functions and Reference Parameters",
    "section": "Why?",
    "text": "Why?\n\nPassing by reference avoids making a copy.\n\nSmaller memory footprint.\n\nPassing by reference allows a function to make changes to the actual parameter (argument) directly.\n\nAllows the programmer to move multiple values out of a function.\nThis is a double-edged sword!\n\nYou can use const to prevent the argument from being modified.\n\n\n\n\n\nconst reference parameters\n\n\nThese can give you the “best of both worlds”. You can efficiently pass a parameter without the risk of the function changing it."
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#function-calls",
    "href": "content/06_Functions_Reference_Parameters.html#function-calls",
    "title": "Functions and Reference Parameters",
    "section": "Function Calls",
    "text": "Function Calls\n\nNo additional syntax is needed to call a function that uses reference parameters.\n\nThis is part of the reason that there is a danger!\n\nYou cannot pass literals or constants by reference unless the formal parameter is a const reference."
  },
  {
    "objectID": "content/06_Functions_Reference_Parameters.html#function-overloading",
    "href": "content/06_Functions_Reference_Parameters.html#function-overloading",
    "title": "Functions and Reference Parameters",
    "section": "Function Overloading",
    "text": "Function Overloading\n\nTwo (or more) functions that have the same name but different parameter lists are said to be overloaded.\nThe correct function to call is determined by the compiler by matching the number and type of arguments to the formal parameter lists.\n\nThis happens at compile-time.\n\nParameter lists must be unique for each function.\n\nAmbiguities will be flagged as errors."
  },
  {
    "objectID": "content/04_Repetition.html#first-some-helpful-new-operators",
    "href": "content/04_Repetition.html#first-some-helpful-new-operators",
    "title": "Repetition",
    "section": "First, some helpful new operators…",
    "text": "First, some helpful new operators…\n\nShortcut Assignment Operators\n\nMake modifying an existing value easy.\n\nIncrement and Decrement Operators\n\nMake counting up and down easy."
  },
  {
    "objectID": "content/04_Repetition.html#repetition-loops",
    "href": "content/04_Repetition.html#repetition-loops",
    "title": "Repetition",
    "section": "Repetition (loops)",
    "text": "Repetition (loops)\nRepeating code is accomplished with the help of a control structure called a loop. C++ provides three loop constructs (four if you count the modern C++ range-based version of for):\n\nwhile\nfor\n\nRange-based for\n\ndo-while\n\nBut before we get into the specifics of the code, let’s examine some terms and theory related to looping in general."
  },
  {
    "objectID": "content/04_Repetition.html#terms",
    "href": "content/04_Repetition.html#terms",
    "title": "Repetition",
    "section": "Terms",
    "text": "Terms\n\nLoop Control Variable : a variable whose value is tested in order to determine whether the loop body should execute.\nLoop Condition : a Boolean expression whose result determines whether the loop body will execute (true causes the loop to execute).\nUpdate step : a modification that is made to the loop control variable within the scope of the loop body."
  },
  {
    "objectID": "content/04_Repetition.html#three-parts-of-a-loop",
    "href": "content/04_Repetition.html#three-parts-of-a-loop",
    "title": "Repetition",
    "section": "Three Parts of a Loop",
    "text": "Three Parts of a Loop\n\n\n\n\nSet up the Loop Control Variable (LCV) in preparation for the loop.\nA proper loop condition must be created to test the LCV.\nThe value of the LCV must be changed within the body of the loop."
  },
  {
    "objectID": "content/04_Repetition.html#types-of-loops-by-method-of-control",
    "href": "content/04_Repetition.html#types-of-loops-by-method-of-control",
    "title": "Repetition",
    "section": "Types of Loops (by method of control)",
    "text": "Types of Loops (by method of control)\n\nIterative Loop (AKA “Counting Loop”) : a loop that repeats a specific number of times, or for a specific range of values.\nEvent-Controlled Loop : a loop that repeats until a specific event occurs. 3 sub-types:\n\nSentinel Controlled Loop : a loop that repeats until a specified data value is encountered (this value is called the sentinel)\nFlag Controlled Loop : a loop that repeats until the truth value of a Boolean flag is flipped.\nEnd-Of-File Controlled Loop : a loop that repeats (based on a stream) until the End Of File marker is read."
  },
  {
    "objectID": "content/04_Repetition.html#types-of-loops-by-timing-of-the-test",
    "href": "content/04_Repetition.html#types-of-loops-by-timing-of-the-test",
    "title": "Repetition",
    "section": "Types of Loops (by timing of the test)",
    "text": "Types of Loops (by timing of the test)\nLoops can also be classified by the timing of when they test their loop condition:\n\npre-test loop : a loop that tests the loop condition before loop entry (at the beginning of each loop)\npost-test loop : a loop that tests the loop condition at loop exit (at the end of each loop)"
  },
  {
    "objectID": "content/04_Repetition.html#the-while-loop",
    "href": "content/04_Repetition.html#the-while-loop",
    "title": "Repetition",
    "section": "The while Loop",
    "text": "The while Loop\nwhile is a pre-test loop.\n\n\nSyntax:\n\nwhile( loop_condition )\n    statement_to_repeat;\n\n\nUsing a Block\n\nwhile( loop_condition ) {\n    statement_1;\n    […]\n    statement_n;\n}"
  },
  {
    "objectID": "content/04_Repetition.html#the-for-loop",
    "href": "content/04_Repetition.html#the-for-loop",
    "title": "Repetition",
    "section": "The for Loop",
    "text": "The for Loop\nfor is a pre-test loop.\n\n\nSyntax:\n\nfor( initializer ; test ; update )\n     statement_to_repeat;\n\n\nUsing a Block\n\nfor( initializer ; test ; update ) {\n     statement_1;\n     […]\n     statement_n;\n}"
  },
  {
    "objectID": "content/04_Repetition.html#the-range-based-for-loop",
    "href": "content/04_Repetition.html#the-range-based-for-loop",
    "title": "Repetition",
    "section": "The Range-Based for Loop",
    "text": "The Range-Based for Loop\nC++11 added the ability for a for loop to iterate over all elements of a sequence container using a more concise syntax:\nSyntax\n\nfor( item_declaration : container )\n     statement_to_repeat;\n\n\nor more generally:\n\n\n\nfor( item_declaration : container ) {\n     statement_1;\n     […]\n     statement_n;\n}"
  },
  {
    "objectID": "content/04_Repetition.html#the-do-while-loop",
    "href": "content/04_Repetition.html#the-do-while-loop",
    "title": "Repetition",
    "section": "The do-while Loop",
    "text": "The do-while Loop\ndo-while is a post-test loop.\n\nSyntax:\n\ndo {\n     statement_1;\n     […]\n     statement_n;\n} while( loop_condition );\n\n\n\nNotice the semicolon at the end!\nThe do-while is the only C++ control structure that ends with a semicolon."
  },
  {
    "objectID": "content/04_Repetition.html#which-loop-to-choose",
    "href": "content/04_Repetition.html#which-loop-to-choose",
    "title": "Repetition",
    "section": "Which Loop to Choose?",
    "text": "Which Loop to Choose?\n\nwhile\n\npre-test loop\nwell suited to Event Controlled Loops\n\nfor\n\npre-test loop\nwell suited to Iterative Loops\nrange-based for is great for containers\n\ndo-while\n\npost-test loop\nwell suited to Event Controlled Loops used for validation\n\n\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nRepetition"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#variables-operators-common-errors",
    "href": "content/02_Variables_Operators_Errors.html#variables-operators-common-errors",
    "title": "Variables, Operators, Common Errors",
    "section": "Variables, Operators, Common Errors",
    "text": "Variables, Operators, Common Errors\nGaddis (Ch. 2)"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#the-big-picture",
    "href": "content/02_Variables_Operators_Errors.html#the-big-picture",
    "title": "Variables, Operators, Common Errors",
    "section": "The Big Picture",
    "text": "The Big Picture\nAll programming languages must provide certain functionality:\n\nTemporary data storage and retrieval.\n\nHow is data stored in RAM?\n\nOperators that can be applied to the data.\n\nWhat can I do to manipulate the data, and how?\n\nInput and Output\n\nWhere does the data come from, and how?\n\nControl Structures\n\nConditional execution and repetition.\n\n\nTo learn a language, figure these things out first."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#where-to-start",
    "href": "content/02_Variables_Operators_Errors.html#where-to-start",
    "title": "Variables, Operators, Common Errors",
    "section": "Where to Start?",
    "text": "Where to Start?\nWe will begin by examining the way C++ provides for temporary data storage and retrieval.\n\nAll non-trivial programs act by storing and manipulating data.\nData is stored in the computer’s RAM (Random Access Memory) while a program is using it.\n\nRAM is volatile (it only works when the machine is on)."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#computer-memory",
    "href": "content/02_Variables_Operators_Errors.html#computer-memory",
    "title": "Variables, Operators, Common Errors",
    "section": "Computer Memory",
    "text": "Computer Memory\n\nThe smallest division of memory is a byte (8-bits). All storage sizes are specified in bytes.\n\nEach byte of memory has a number associated with it, called its memory address.\nThis address is what the machine uses to refer to data.\n\nPhysical memory is limited, but logical memory (our view of memory as programmers) is usually treated as if it were unlimited.\n\n\nLogical Memory"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#variables",
    "href": "content/02_Variables_Operators_Errors.html#variables",
    "title": "Variables, Operators, Common Errors",
    "section": "Variables",
    "text": "Variables\nSince humans are not good with numbers (like memory addresses), C++ provides us with a way to use names instead.\n\nvariable : a named storage location for data within a program\nvariable declaration : a statement used to tell the compiler that a new variable should be created; contains the identifier and type for the variable.\n\nint temperature;\nThe declaration statement above tells the compiler to create a variable named temperature that will store an integer."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#data-types",
    "href": "content/02_Variables_Operators_Errors.html#data-types",
    "title": "Variables, Operators, Common Errors",
    "section": "Data Types",
    "text": "Data Types\nSo what types of things can we store in variables?\n\n\n\nType Name\nDescription\nLiteral Examples\n\n\n\n\nint\nInteger value\n96, -33\n\n\ndouble\nFloating-point (Real number) value\n3.14, -1.0\n\n\nchar\nSingle character\n'a', '4'\n\n\nbool\nBoolean value\ntrue, false\n\n\nstd::string\nString value\n\"Hello\", \"ocean\""
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#identifiers",
    "href": "content/02_Variables_Operators_Errors.html#identifiers",
    "title": "Variables, Operators, Common Errors",
    "section": "Identifiers",
    "text": "Identifiers\nAn identifier is a name that is permissible for variables, classes, functions, etc. in C++.\n\nYou must obey the following 3 Rules For Identifiers:\n\nIdentifiers may not begin with a digit.\nIdentifiers must consist only of letters, digits, and underscores.\nAn identifier must not be a keyword.\n\n  Additional Info: Identifers (and everything else) in C++ are case sensitive"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#keywords",
    "href": "content/02_Variables_Operators_Errors.html#keywords",
    "title": "Variables, Operators, Common Errors",
    "section": "Keywords",
    "text": "Keywords\nA keyword is a word that has a specific, reserved meaning in a programming language. Also known as reserved words in some texts.\n\nC++ Consists of all of the keywords from the C language, plus new ones that are related to C++’s object-oriented focus.\n\nThere are 92 keywords in C++ (as of the C++20 standard). C++98 had 74."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#declaration",
    "href": "content/02_Variables_Operators_Errors.html#declaration",
    "title": "Variables, Operators, Common Errors",
    "section": "Declaration",
    "text": "Declaration\nDeclaring a variable allows the compiler to reserve memory for the data, as well as managing the association between the data’s memory address and the identifier chosen to represent the variable in the program.\nint temperature;\nThe declaration above produces the situation in memory shown below:\n\nVariable Declaration"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#declaration-1",
    "href": "content/02_Variables_Operators_Errors.html#declaration-1",
    "title": "Variables, Operators, Common Errors",
    "section": "Declaration",
    "text": "Declaration\n\nDeclaring a variable tells the compiler the name and type of the data.\n\nThe compiler now also knows the amount of memory required.\nYou can find out with the sizeof() operator:\n\ncout &lt;&lt; sizeof(temperature); Will produce “4”…\n\n\nDeclaring a variable does not specify what value the variable will contain!\n\nThe variable will contain whatever value happened to be in that location in memory.\n\nMemory is constantly recycled, so this is essentially garbage."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#initialization",
    "href": "content/02_Variables_Operators_Errors.html#initialization",
    "title": "Variables, Operators, Common Errors",
    "section": "Initialization",
    "text": "Initialization\nInitialization refers to storing a value in a variable for the first time.\n\nVariables always begin in an uninitialized state.\n\nExample:\nint temperature = 82;\nThe statement above declares a variable named temperature and initializes temperature to contain the value 82."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#the-auto-keyword",
    "href": "content/02_Variables_Operators_Errors.html#the-auto-keyword",
    "title": "Variables, Operators, Common Errors",
    "section": "The auto Keyword",
    "text": "The auto Keyword\n\nC++11 added the ability for a variable declaration to get its type information automatically based on its initialization value.\n\nThe auto keyword may be used in place of the variable’s type when this behavior is desired.\n\n\nExample\nauto interestRate = 12.75;\nauto stockCode    = 'C';\nHere, interestRate will be of type double and stockCode will be type char — the compiler can determine this by examining the type of the literals used to initialize the variables."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#when-to-use-auto",
    "href": "content/02_Variables_Operators_Errors.html#when-to-use-auto",
    "title": "Variables, Operators, Common Errors",
    "section": "When to use auto",
    "text": "When to use auto\n\nThe auto keyword is intended to simplify declaration of intermediate variables that have very complex types.\n\nIn general, do not use auto to declare variables whose lifetime is more than a few lines.\nIn general, do not use auto to declare variables whose type is “simple” (a built-in or primitive type).\n\nGoal: Use auto whenever it increases the readability of the code, avoid it when it decreases the code’s readability."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#variable-lifetime",
    "href": "content/02_Variables_Operators_Errors.html#variable-lifetime",
    "title": "Variables, Operators, Common Errors",
    "section": "Variable Lifetime",
    "text": "Variable Lifetime\nVariable names (and all other names as well) have a “life span” within the context of the program code.\n\n\nscope - an identifier’s scope refers to the section of the program in which the identifier is defined.\nC++ has six kinds of scope:\n\nglobal scope - globally-scoped identifiers are known from the point at which they are declared until the end of the program.\n\nThese are defined outside any function (outside any block).\n\nlocal scope - locally-scoped identifiers are known from the point at which they are declared until the end of the block in which they are declared.\n\nAlmost all variables we use will be local.\n\nstatement scope - Names declared in a for, if, while, or switch statement are visible until the end of the statement block.\n\nThis behaves like a special case of local scope.\n\nclass scope - Names of class members have class scope, which extends throughout the class definition regardless of the point of declaration. Class member accessibility is further controlled by the public, private, and protected keywords.\nnamespace scope - A name that is declared within a namespace, outside of any class or enum definition or function block, is visible from its point of declaration to the end of the namespace.\nfunction scope - A label has function scope, which means it is visible throughout a function body even before its point of declaration."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#assignment",
    "href": "content/02_Variables_Operators_Errors.html#assignment",
    "title": "Variables, Operators, Common Errors",
    "section": "Assignment",
    "text": "Assignment\n\nVariables may be re-used by changing their value.\nThe C++ assignment operator is =\n\nIt should always be read as “assigned” or “is assigned”.\nIt should never be read as “equals”!\n\n\nExample:\nint temperature = 82;\nstd::cout &lt;&lt; \"Initial temperature: \" &lt;&lt; temperature &lt;&lt; \"\\n\";\ntemperature = 75; // change the value of temperature to 75\nstd::cout &lt;&lt; \"Temperature now: \"     &lt;&lt; temperature &lt;&lt; \"\\n\";\nThe third line should be read as “temperature is assigned 75”."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#operators",
    "href": "content/02_Variables_Operators_Errors.html#operators",
    "title": "Variables, Operators, Common Errors",
    "section": "Operators",
    "text": "Operators\n\nC++ Operators can be divided into the following families:\n\nAssignment Operators\nMathematical Operators\nRelational Operators\nLogical Operators\nStream Operators\nOther Operators\n\nWe have seen the basic assignment operator (=) and the stream insertion operator (&lt;&lt;).\nNow, let’s look at the stream extraction operator…"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#stream-extraction",
    "href": "content/02_Variables_Operators_Errors.html#stream-extraction",
    "title": "Variables, Operators, Common Errors",
    "section": "Stream Extraction",
    "text": "Stream Extraction\n\nThe &gt;&gt; operator is the C++ stream extraction operator.\nIt takes a value from the stream on the left (often we use std::cin) and places it into the variable on the right:\n\nint x;                                   // declare x\nstd::cout &lt;&lt; \"Enter an integer value: \"; // prompt\nstd::cin  &gt;&gt; x;                          // read x\n\nNotice that the stream extraction operation works like assignment, except that the new value comes from a stream.\nstd::cin is the standard input stream (usually attached to the keyboard)\nNow let’s visit the mathematical operators…"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#c-mathematical-operators",
    "href": "content/02_Variables_Operators_Errors.html#c-mathematical-operators",
    "title": "Variables, Operators, Common Errors",
    "section": "C++ Mathematical Operators",
    "text": "C++ Mathematical Operators\n Operator    Meaning               Expression  Result\n------------------------------------------------------\n +           Addition                 3 + 4      7\n -           Subtraction              4 - 6      -2\n -           Negation (unary -)      -3 + 1      -2\n *           Multiplication           3 * 5      15\n /           Division                 8 / 2      4\n %           Modulus (remainder)      7 % 4      3\nBeware of the division operator!\n\n3 / 4 evaluates to 0!\n\nIf / is operating on integers, it performs integer division.\n\n3.0 / 4.0 yields 0.75, as expected.\n\nIf either the dividend or divisor is a floating-point type, the answer will be as well."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#expressions",
    "href": "content/02_Variables_Operators_Errors.html#expressions",
    "title": "Variables, Operators, Common Errors",
    "section": "Expressions",
    "text": "Expressions\nAn expression may consist of one or more operations on data, and will evaluate to a result whose type is the most precise type involved in the expression. (This is highly simplified… but is true most of the time.)\nExample:\nstd::cout &lt;&lt; 3 + 5 * 7 - 2 &lt;&lt; \"\\n\"; // produces 36\nint x = 5;\nint y = 3 * x / 2;\nstd::cout &lt;&lt; y &lt;&lt; \"\\n\";             // produces 7\ndouble z = 4.0;\nstd::cout &lt;&lt; y / z &lt;&lt; \"\\n\";         // produces 1.75"
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#the-const-modifier",
    "href": "content/02_Variables_Operators_Errors.html#the-const-modifier",
    "title": "Variables, Operators, Common Errors",
    "section": "The const Modifier",
    "text": "The const Modifier\nA type modifier is a C++ keyword that is used in conjunction with a type name to change that type’s properties in some way.\nThe const type modifier changes a declaration statement from a variable declaration to a constant declaration.\nThe value of a constant can never be changed once it has been initialized."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#comments",
    "href": "content/02_Variables_Operators_Errors.html#comments",
    "title": "Variables, Operators, Common Errors",
    "section": "Comments",
    "text": "Comments\n\nMost of a developer’s time is spent maintaining or improving code.\n\nYou cannot maintain or improve code that you can’t read and understand!\n\n\n\nAny line beginning with // is a single-line comment in C++. The compiler will simply ignore the // and any code following it until the end of the line.\n\n/* and */ create block comments in C++. Anything between a /* and its corresponding */ will be ignored. Block comments may span multiple lines."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#documentation",
    "href": "content/02_Variables_Operators_Errors.html#documentation",
    "title": "Variables, Operators, Common Errors",
    "section": "Documentation",
    "text": "Documentation\nIn addition to comments in the code, the program itself should have documentation to explain the “big picture”.\n\nEach development team/company will have its own standards for documentation. We have developed a set of standards that are similar to industry practice.\n See the documentation guidelines that your code must meet on the course website."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#programming-errors",
    "href": "content/02_Variables_Operators_Errors.html#programming-errors",
    "title": "Variables, Operators, Common Errors",
    "section": "Programming Errors",
    "text": "Programming Errors\nProgrammers are human. [citation needed]\nErrors are unavoidable. Learning to expect, detect, and fix those errors is a key component of learning to program.\n\n\nTypes of Errors\n\nSyntax Errors\n\nCaused by incorrect syntax: rules of spelling, grammar, and punctuation for a language.\nthe compiler often detects these easily.\n\nSemantic Errors\n\nSemantic errors caused by mis-using the language in some way; these are not caught by the compiler, and must be detected at runtime.\n\nLogical Errors\n\nLogical errors like semantic errors, but error is in the logic, not the implementation."
  },
  {
    "objectID": "content/02_Variables_Operators_Errors.html#tips-and-tricks",
    "href": "content/02_Variables_Operators_Errors.html#tips-and-tricks",
    "title": "Variables, Operators, Common Errors",
    "section": "Tips and Tricks",
    "text": "Tips and Tricks\n\nCompile early, compile often.\n\nWrite small amounts, then compile/test/continue.\n\nThe first error is the only one that matters!\n\nAlways fix the first error before moving on to other errors.\nRe-compile after fixing the error, then repeat the process.\n\nPay attention to line numbers.\n\nThe compiler will tell you which line it was examining when it found the error.\n\nThe line containing the error will either be that line or a line above that point in the program.\n\nStart with the flagged line, work your way upward a line at a time.\n\n\n\n\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nVariables, Operators, Common Errors"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CS 50x2 Slides",
    "section": "",
    "text": "Structured Programming Basics\n\n\n\n\n\n\n\n\n\n\nVariables, Operators, Common Errors\n\n\n\n\n\n\n\n\n\n\nSelection\n\n\n\n\n\n\n\n\n\n\nRepetition\n\n\n\n\n\n\n\n\n\n\nFunctions and Value Parameters\n\n\n\n\n\n\n\n\n\n\nFunctions and Reference Parameters\n\n\n\n\n\n\n\n\n\n\nRecursion\n\n\n\n\n\n\n\n\n\n\nArrays\n\n\n\n\n\n\n\n\n\n\nCharacters and C-Style Strings\n\n\n\n\n\n\n\n\n\n\nParallel and Multi-Dimensional Arrays\n\n\n\n\n\n\n\n\n\n\nPointers\n\n\n\n\n\n\n\n\n\n\nSTL and Vectors\n\n\n\n\n\n\n\n\n\n\nInput and Output\n\n\n\n\n\n\n\n\n\n\nSearching and Sorting\n\n\n\n\n\n\n\n\n\n\nStructures\n\n\n\n\n\n\n\n\n\n\nBinary Files and Random Access\n\n\n\n\n\n\n\n\n\n\nDynamic Memory\n\n\n\n\n\n\n\n\n\n\nExceptions\n\n\n\n\n\n\n\n\n\n\nClasses and Objects\n\n\n\n\n\n\n\n\n\n\nAggregation\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/01_SP_Basics.html#first-principles",
    "href": "content/01_SP_Basics.html#first-principles",
    "title": "Structured Programming Basics",
    "section": "First Principles",
    "text": "First Principles\n\ncomputer - a programmable machine designed to follow instructions\n\nComputers are able to perform mathematical and logical operations at great speed.\n\nalgorithm - a precise, step-by-step plan for solving a problem\nprogram - a set of instructions expressed in a programming language that a computer follows to perform a task\nprogrammer - a person who writes a computer program\nprogramming language - any language designed specifically for use in creating computer programs"
  },
  {
    "objectID": "content/01_SP_Basics.html#computer-code",
    "href": "content/01_SP_Basics.html#computer-code",
    "title": "Structured Programming Basics",
    "section": "Computer Code",
    "text": "Computer Code\nComputers execute code that is stored in computer memory in a binary form.\n11000111 01000100 00100100 00000100 00011000 10000111 00000100\nHumans are not skilled at writing in machine language."
  },
  {
    "objectID": "content/01_SP_Basics.html#language-levels",
    "href": "content/01_SP_Basics.html#language-levels",
    "title": "Structured Programming Basics",
    "section": "Language Levels",
    "text": "Language Levels\n\nLow-Level\n\nMachine Language\n\nPure binary, but usually expressed as hexadecimal\n\nAssembly Language\n\nCorresponds more or less 1:1 with machine language (easy conversion)\nMore human-readable (for some definition of more)\n\n\nHigh-Level\n\nC, C++, Python, Swift, etc.\n\nDesigned to look like a human language\nMust be translated to machine language"
  },
  {
    "objectID": "content/01_SP_Basics.html#a-complete-c-program",
    "href": "content/01_SP_Basics.html#a-complete-c-program",
    "title": "Structured Programming Basics",
    "section": "A Complete C++ Program:",
    "text": "A Complete C++ Program:\n#include &lt;iostream&gt;\n\nint main(){\n    std::cout &lt;&lt; \"Hello, World!\\n\";\n    return 0;\n}\nNow, we will take a look at the parts of the program, and see what each part does."
  },
  {
    "objectID": "content/01_SP_Basics.html#a-complete-c-program-1",
    "href": "content/01_SP_Basics.html#a-complete-c-program-1",
    "title": "Structured Programming Basics",
    "section": "A Complete C++ Program:",
    "text": "A Complete C++ Program:\n#include &lt;iostream&gt;\n\nint main(){\n    std::cout &lt;&lt; \"Hello, World!\\n\";\n    return 0;\n}\n\n\nThis line is called a preprocessor directive.\nIt communicates with a phase of the C++ compiler called the preprocessor, telling it to include code from a file named “iostream”, which is a C++ library.\n\nThe iostream library contains code that is used for input and output activities.\n\n\n\n\nThis line is called a function header.\nIt begins the definition of a function called “main”.\nEvery C++ program must contain a main() function.\n\nThe main() function tells the computer where to begin executing.\nInstructions will be executed one at a time, starting with the first line of main.\n\n\n\n\n\nThe curly braces enclose a block of code in C++.\nblock - a set of related C++ statements that perform an action\nEvery opening curly brace must match with a closing brace.\n\nWe indent the code between the { and the }.\n\n\n\n\n\nThis statement sends the words “Hello, World” to the screen.\nstd::cout is the name of the standard output stream\n\nA stream is a one-way flow of data from the point of view of the program.\n\n&lt;&lt; is the stream insertion operator, used to place things into a stream.\n\"Hello, World!\\n\" is a string literal; a string is just a collection of characters that are treated as a single unit.\n\nString literals are always surrounded by double-quotes.\n\nliteral: A literal is a value that is typed directly into the source code, in a representation that the programming language recognizes as a value of a recognized type. Literal values must be formatted according to the syntax rules of the language.\n\n\n\n\nThis line terminates the program by causing the main() function to return the value 0 to the operating system.\n\nNo code following this line would ever be executed; this means that the return 0; line will always be the last line in main().\n\nThe operating system considers zero to be an indication that the program exited “normally”.\n\nOther values are possible, and we will use them later."
  },
  {
    "objectID": "content/01_SP_Basics.html#escape-characters",
    "href": "content/01_SP_Basics.html#escape-characters",
    "title": "Structured Programming Basics",
    "section": "Escape Characters",
    "text": "Escape Characters\n    std::cout &lt;&lt; \"Hello, World\\n\";\n\nWe often want to include control characters in our string literals, but we don’t have the ability to type these in directly. C++ allows the use of escape characters for this purpose.\n\n\nescape character - any character combination beginning with “\\”, used to represent a character that cannot otherwise be represented in a string literal.\n\nExamples:\nCode     Meaning\n-----------------\n \\n      newline (think of the &lt;ENTER&gt; key)\n \\t      tab character\n \\\"      allows a double-quote in a string literal\n \\\\      allows a backslash in a string literal\n \\r      carriage-return (used in Windows line endings: \"\\r\\n\")"
  },
  {
    "objectID": "content/01_SP_Basics.html#our-development-toolchain",
    "href": "content/01_SP_Basics.html#our-development-toolchain",
    "title": "Structured Programming Basics",
    "section": "Our Development Toolchain",
    "text": "Our Development Toolchain\n\n\nUser’s Side: Editing, running and testing.\nServer Side: Stores files, provides compiler and other tools."
  },
  {
    "objectID": "content/01_SP_Basics.html#some-linux-unix-terminal-basics",
    "href": "content/01_SP_Basics.html#some-linux-unix-terminal-basics",
    "title": "Structured Programming Basics",
    "section": "Some Linux / UNIX terminal basics",
    "text": "Some Linux / UNIX terminal basics\nhttps://towardsdatascience.com/basics-of-bash-for-beginners-92e53a4c117a\nhttps://www.educative.io/blog/bash-shell-command-cheat-sheet\nhttps://wiki.cs.astate.edu/index.php/Common_Linux_Commands (Requires VPN access.)"
  },
  {
    "objectID": "content/01_SP_Basics.html#practice-developing-and-compiling",
    "href": "content/01_SP_Basics.html#practice-developing-and-compiling",
    "title": "Structured Programming Basics",
    "section": "Practice Developing and Compiling",
    "text": "Practice Developing and Compiling\n#include &lt;iostream&gt;\n\nint main(){\n    std::cout &lt;&lt; \"Hello, World!\\n\";\n    return 0;\n}\nMake modifications to the program so that it will print out your name, favorite food, and favorite TV series.\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nStructured Programming Basics"
  },
  {
    "objectID": "content/03_Selection.html#making-decisions",
    "href": "content/03_Selection.html#making-decisions",
    "title": "Selection",
    "section": "Making Decisions",
    "text": "Making Decisions\nOne of the things computers are “good at” is determining the result of logic-based (Boolean) expressions, and using those results to make decisions quickly.\n\nChoose to whether or not to perform an operation.\n\nIf it is raining outside, take an umbrella.\n\nChoose between possible outcomes.\n\nIf you are taller than 38”, proceed to the ride, otherwise leave the line.\n\nSelect from a variety of possible choices.\n\nShow the user a menu with many options; respond to his/her choice appropriately."
  },
  {
    "objectID": "content/03_Selection.html#first-some-operators",
    "href": "content/03_Selection.html#first-some-operators",
    "title": "Selection",
    "section": "First, some operators…",
    "text": "First, some operators…\nBefore we can make decisions based on the answers to logic questions, we need to learn what kinds of questions we can ask, and how to phrase the questions.\n\nAll decisions must be based on logical tests that evaluate to a clear true or false result. (Boolean expressions)\nC++ provides a full set of relational operators for making comparisons, and logical operators for combining these comparisons into complex expressions."
  },
  {
    "objectID": "content/03_Selection.html#relational-operators",
    "href": "content/03_Selection.html#relational-operators",
    "title": "Selection",
    "section": "Relational Operators",
    "text": "Relational Operators\nRelational operators compare two values, and evaluate to a bool result based on the truthfulness of the comparison:\n\n\n\nOperator    Description     \n------------------------------------\n   &gt;        greater than    \n   &lt;        less than       \n   &gt;=       greater than or equal to\n   &lt;=       less than or equal to\n   ==       equal to \n   !=       not equal to"
  },
  {
    "objectID": "content/03_Selection.html#logical-operators",
    "href": "content/03_Selection.html#logical-operators",
    "title": "Selection",
    "section": "Logical Operators",
    "text": "Logical Operators\nLogical (or Boolean) operators are used to combine relational expressions to create a more complex test condition:\n\n\n\nOperator    Description     \n----------------------\n   &&       and\n   ||       or\n   !        not (unary)"
  },
  {
    "objectID": "content/03_Selection.html#control-structures",
    "href": "content/03_Selection.html#control-structures",
    "title": "Selection",
    "section": "Control Structures",
    "text": "Control Structures\nA control structure is a special language construct that allows a programmer to change the “natural” top-down execution order of the statements in a program.\nAlthough control structures (such as the if) are not actually statements, they are often passively referred to as such. Most do not end with a semicolon."
  },
  {
    "objectID": "content/03_Selection.html#the-if-control-structure",
    "href": "content/03_Selection.html#the-if-control-structure",
    "title": "Selection",
    "section": "The if Control Structure",
    "text": "The if Control Structure\nThe most basic form of the C++ if control structure allows us to choose whether or not to take a specific action:\nSyntax\n\nif( conditional_expression )\n    statement_executed_if_true;\n\nExample\n// Assume x is an integer whose value was entered by the user.\n\nif( x &lt; 0 )   // Check for a negative value\n    std::cout &lt;&lt; \"You entered a negative value.\\n\";"
  },
  {
    "objectID": "content/03_Selection.html#using-a-block",
    "href": "content/03_Selection.html#using-a-block",
    "title": "Selection",
    "section": "Using a Block",
    "text": "Using a Block\nSince a single statement isn’t enough to solve most problems, the body of an if may also be a block:\n// Assume x is an integer whose value was entered by the user.\n\nif( x &lt; 0 )  { // Check for a negative value\n    std::cout &lt;&lt; \"You entered a negative value.\\n\";\n    x = 0;     // Ensure that x is non-negative.\n}\nRecall that a block just means a set of statements contained within curly braces."
  },
  {
    "objectID": "content/03_Selection.html#choose-between-two-outcomes",
    "href": "content/03_Selection.html#choose-between-two-outcomes",
    "title": "Selection",
    "section": "Choose Between Two Outcomes",
    "text": "Choose Between Two Outcomes\nThe if-else construct allows us to choose between two outcomes:\nSyntax\n\nif( conditional_expression )\n    statement_executed_if_true;\nelse\n    statement_executed_if_false;\n\nExample\n// Assume x is an integer whose value was entered by the user.\n\nif( x &lt; 0 )   // Check for a negative value\n    std::cout &lt;&lt; \"You entered a negative value.\\n\";\nelse\n    std::cout &lt;&lt; x &lt;&lt; \" is non-negative.\\n\";"
  },
  {
    "objectID": "content/03_Selection.html#if-else-with-blocks",
    "href": "content/03_Selection.html#if-else-with-blocks",
    "title": "Selection",
    "section": "if-else with Blocks",
    "text": "if-else with Blocks\nThe body of both the if and else part may be blocks:\n// Assume x is an integer whose value was entered by the user,\n// and rt_x is a double that is already declared.\n\nif( x &lt; 0 )  { // Check for a negative value\n    std::cout &lt;&lt; \"You entered a negative value.\\n\";\n    x = 0;     // Ensure that x is non-negative.\n}\nelse {\n    std::cout &lt;&lt; \"Calculating root...\\n\";\n    rt_x = sqrt(x);\n}"
  },
  {
    "objectID": "content/03_Selection.html#information",
    "href": "content/03_Selection.html#information",
    "title": "Selection",
    "section": "Information",
    "text": "Information\n\nThe else part is optional - only use it if you need it.\nIt is recommended to always use blocks for the body of the if and else.\n\nWill save time debugging if more code is added later.\n\nAlways indent the body of the if and else.\n\nIndentation shows ownership (for human programmer’s benefit)\n\nAny legal C++ statement may go in the body of the if/else, including nested if constructs."
  },
  {
    "objectID": "content/03_Selection.html#selecting-from-multiple-options",
    "href": "content/03_Selection.html#selecting-from-multiple-options",
    "title": "Selection",
    "section": "Selecting from Multiple Options",
    "text": "Selecting from Multiple Options\nA clever application of nesting ifs inside elses is commonly used to select from multiple (more than 2) options. It is often referred to as the if-else chain:\n// Assume door is an integer containing 1, 2, or 3:\n\nstd::cout &lt;&lt; \"Behind door #\" &lt;&lt; door &lt;&lt; \", you see a \";\nif(door == 1) {         // door #1\n    std::cout &lt;&lt; \"trip to Hawaii!\\n\";\n}\nelse if(door == 2) {    // door #2\n    std::cout &lt;&lt; \"new car!\\n\";\n}\nelse {                  // door #3\n    std::cout &lt;&lt; \"goat!\\n\";\n}"
  },
  {
    "objectID": "content/03_Selection.html#final-details",
    "href": "content/03_Selection.html#final-details",
    "title": "Selection",
    "section": "Final Details",
    "text": "Final Details\n\nC++ control structures do not strictly require conditions to be type bool.\n\nAny non-zero value will be considered equivalent to “true”.\nAny value that compares “equal to” zero is considered equivalent to “false”.\n\nBeware of the assignment operator! See example below:\n\n// This will print \"8 is 4!\" ... Why?\nint x = 8;\n// [...]\nstd::cout &lt;&lt; x;\nif( x = 4 ) {\n    std::cout &lt;&lt; \" is 4!\";\n}\n\nx is assigned 8. So far so good…\n\n\nWe print x, which is 8 right now. Still OK.\n\n\nThe expression x = 4 assigns the value 4 to x. Then, it evaluates to 4, which is not zero, so the if considers it to be equivalent to true…\nNow we have a problem.\n\n\nWe print the string \" is 4!\", since the if condition was “true-like”.\nThe exact output is:\nx is 4!\n\n\n\n\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nSelection"
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#modular-programming",
    "href": "content/05_Functions_Value_Parameters.html#modular-programming",
    "title": "Functions and Value Parameters",
    "section": "Modular Programming",
    "text": "Modular Programming\n\nModular programming refers to the practice of designing a program so that it is broken up into small, manageable pieces called functions or modules.\nIn C++, a function is a collection of related statements that perform a single logical task, and may produce a value.\nIn Object-Oriented programming, a function that is part of an object (and defined in a class) is referred to as a method. For example, in cin.ignore(), the ignore() function is actually a method owned by the cin object."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#motivation",
    "href": "content/05_Functions_Value_Parameters.html#motivation",
    "title": "Functions and Value Parameters",
    "section": "Motivation",
    "text": "Motivation\n\nModular programs are easier to read and understand.\n\nEach logical step has its own function definition that is easily examined separately from other code.\n\nModular programs are easier to maintain.\n\nChanging an algorithm to fix or improve it involves simply re-writing the function where it is implemented.\n\nModular programs promote code re-use.\n\nIt is much easier to re-use a neatly packaged function than to try to find all the code in a monolithic program that performs a particular action."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#calls-and-definitions",
    "href": "content/05_Functions_Value_Parameters.html#calls-and-definitions",
    "title": "Functions and Value Parameters",
    "section": "Calls and Definitions",
    "text": "Calls and Definitions\n\n\n\nA function call is an expression that causes a function to be executed.\n\nEx: pow(3, 6)\nFunction calls may or may not evaluate to a result. If it does, this result is referred to as a return value.\n\n\n\nA function definition is the code that defines the actions taken by the function when it is called.\n\nThe main() function we have been writing is an example."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#types-of-functions",
    "href": "content/05_Functions_Value_Parameters.html#types-of-functions",
    "title": "Functions and Value Parameters",
    "section": "Types of Functions",
    "text": "Types of Functions\nFunctions can be generally divided into two categories:\n\nFruitful functions (or value-producing functions) are functions whose purpose is to compute and return a value.\n\nMathematical functions are the best example of this.\n\nNon-fruitful functions (or void functions) are functions that do not directly return any result.\n\nThese functions usually produce some useful side-effect.\nAn example would be the close() method of a file stream.\nSome languages (and so some programmers) refer to these as procedures."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#calling-a-function",
    "href": "content/05_Functions_Value_Parameters.html#calling-a-function",
    "title": "Functions and Value Parameters",
    "section": "Calling a Function",
    "text": "Calling a Function\n\nAny expression can contain a function call.*\n\nNon-fruitful functions are often called as a stand-alone statement.\nFruitful functions are usually called as part of a larger expression.\n\nAny function can call any other function (including itself).\nLike a variable, a function must be “declared” before it is first called. The compiler must know:\n\nfunction name\nreturn type\nnumber and type of parameters required\n\n\n\n* Assuming the function’s return type is syntactically appropriate for the expression."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#defining-a-function",
    "href": "content/05_Functions_Value_Parameters.html#defining-a-function",
    "title": "Functions and Value Parameters",
    "section": "Defining a function",
    "text": "Defining a function\nThe function definition must define the function’s interface, as well as the statements that must be executed to perform the function’s action.\n\nThe function header defines the function’s interface.\n\nname, return type, list of parameters\n\nThe function body is the block of statements that are executed when the function is called."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#formal-and-actual-parameters",
    "href": "content/05_Functions_Value_Parameters.html#formal-and-actual-parameters",
    "title": "Functions and Value Parameters",
    "section": "Formal and Actual Parameters",
    "text": "Formal and Actual Parameters\n\nFormal parameters (or parameters): The temporary placeholders declared in the function header used to receive data provided by the caller.\nActual parameters (or arguments): The data values that are actually passed to the function during a call.\n\n\n\n\n\n\n\n\nUnfortunately, the terms “parameter” and “argument” are often used nearly interchangeably in conversation. This can lead to confusion. Please take care to make a distinction between the two."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#data-flow-pass-by-value",
    "href": "content/05_Functions_Value_Parameters.html#data-flow-pass-by-value",
    "title": "Functions and Value Parameters",
    "section": "Data Flow: Pass by Value",
    "text": "Data Flow: Pass by Value\n\nIn pass by value, the value of the actual parameter is copied into the formal parameter.\nPass by value is the default method by which data is moved into a function for primitive types, structured types and object types.\n\nChanges to the formal parameter cannot affect the actual parameter."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#returning-values-from-a-function",
    "href": "content/05_Functions_Value_Parameters.html#returning-values-from-a-function",
    "title": "Functions and Value Parameters",
    "section": "Returning Values from a Function",
    "text": "Returning Values from a Function\nFruitful functions produce a value by means of a return statement in the function definition.\n\nMust define the type of the return value in the function header.\nThe value returned must match the type specified in the header.\nWhen called, the function call is “replaced” by the value that it returns.\n\nWe often say the function evaluates to the resulting value."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#scope",
    "href": "content/05_Functions_Value_Parameters.html#scope",
    "title": "Functions and Value Parameters",
    "section": "Scope",
    "text": "Scope\n\n\n\n\n\n\nA function is a like a sealed box. The only way “in” is through the parameter list or global scope. The only direct way “out” is through a return.\n\n\n\n\nFormal parameters are locally-scoped within the function definition.\nVariables declared in a function will be locally-scoped within the function definition.\nGlobal variables declared before a function definition will be available in the function definition."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#static-local-variables",
    "href": "content/05_Functions_Value_Parameters.html#static-local-variables",
    "title": "Functions and Value Parameters",
    "section": "static Local Variables",
    "text": "static Local Variables\nA static variable displays a hybrid of local and global behavior. It is used to maintain state between calls.\nvoid foo(){\n    static int count = 1;\n    std::cout &lt;&lt; \"Call # \" &lt;&lt; count &lt;&lt; \"\\n\";\n    count++;\n}\n\nThe identifier is governed by local scoping rules\nThe value is governed by global scoping rules (it doesn’t go away between calls).\n\nProvides “sticky” values that are “remembered” between calls."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#function-prototypes",
    "href": "content/05_Functions_Value_Parameters.html#function-prototypes",
    "title": "Functions and Value Parameters",
    "section": "Function Prototypes",
    "text": "Function Prototypes\nWe would prefer to define the main() function first… But the compiler requires that all other function interfaces be specified before they can be called.\n\nfunction prototype: A declaration statement for a function, providing the function’s interface but not a body.\nPlaced at the top of a program so that the function definition can be placed after main(), in any order."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#default-parameter-values",
    "href": "content/05_Functions_Value_Parameters.html#default-parameter-values",
    "title": "Functions and Value Parameters",
    "section": "Default Parameter Values",
    "text": "Default Parameter Values\nOften a parameter will always be set to a common value; in these cases, a default value can be specified for the parameter. Doing so makes the parameter optional when calling the function.\n\nDefault parameters are specified in the function prototype (if used) or header by using initialization syntax:\n\ndouble divide( double dividend, double divisor = 2.0 );\n\nIf the actual parameter corresponding to the default parameter is omitted, the default value (2.0 in this case) will be used.\n\n\n\n\n\n\n\n\nThe default value must only be specified once. If you use a prototype, the default value is specified there. Only specify the default value in the header of the definition if no prototype is used. It is an error to specify it in both places.\nRemember it this way: Place the default value in the first place the compiler will encounter it."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#default-parameter-notes",
    "href": "content/05_Functions_Value_Parameters.html#default-parameter-notes",
    "title": "Functions and Value Parameters",
    "section": "Default Parameter Notes",
    "text": "Default Parameter Notes\n\nOrder is important!\n\nOnce you give one parameter a default, all parameters to its right must also have defaults.\nIn a call, once you omit an argument, you must also omit all arguments to its right.\n\nBest practice is to place the most often customized parameters further left, and the ones for which the default is usually OK to the right.\n\nThis isn’t a rule—it’s just a usability consideration."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#documentation",
    "href": "content/05_Functions_Value_Parameters.html#documentation",
    "title": "Functions and Value Parameters",
    "section": "Documentation",
    "text": "Documentation\nAll function definitions require documentation headers describing the function, its parameters, and return value. See course Grading Guidelines.\n/**\n * Divide `dividend` by `divisor` and return the result.\n * @param   dividend    Dividend for the division \n * @param   divisor     Divisor for the division \n *                      (defaults to 2.0)\n * @return  The result of `dividend` / `divisor` is returned.\n */\ndouble divide( double dividend, double divisor ){\n    return dividend / divisor;\n}\n\nDoxygen-style documentation headers begin with /** (two stars, not just one).\nThis allows Doxygen to tell them apart from “regular” block comments.\n\n\nIf a function’s purpose is simple, just list it at the beginning of the documentation header.\nMore complex functions can use the @brief and @detailed tags to provide a short and complete description (see documentation guidelines).\n\n\nThe @param directive lets you document parameters. Give the name, then some space, then a short description of what the parameter is used for.\n\n\nThe @return directive lets you provide a short description of the value that will be returned.\n\n\n\nYou only need to create the parameter and return value documentation if your function has parameters / return value. A void function does not need a @return documentation; a function with no parameters does not need @param documentation.\nDon’t write documentation that doesn’t provide any information.\nDO try to write concise, high-quality documentation."
  },
  {
    "objectID": "content/05_Functions_Value_Parameters.html#stubs-and-drivers",
    "href": "content/05_Functions_Value_Parameters.html#stubs-and-drivers",
    "title": "Functions and Value Parameters",
    "section": "Stubs and Drivers",
    "text": "Stubs and Drivers\n\nNo need to define full functionality immediately.\n\n\n\n\n\n\n\nCompile Early, Compile Often\n\n\nLet the compiler be your helper, not your adversary.\n\n\n\n\nA valid* function body only needs an appropriate return statement.\n\nThe rest can be left “empty” until later.\n\nfunction stub: an empty function used for incremental development.\ndriver: a function used only for testing other functions by calling them.\n\n\n* “Valid” doesn’t imply correct—it just means you are syntactically valid and can compile (and maybe even run) the program to see if there are other errors."
  },
  {
    "objectID": "content/07_Recursion.html#recursion",
    "href": "content/07_Recursion.html#recursion",
    "title": "Recursion",
    "section": "Recursion",
    "text": "Recursion\nA function is said to be recursive if it contains a call to itself.\n\nRecursive definitions are often more “natural”.\n\nEmbodies a “divide-and-conquer” strategy\n\n\nvoid countDown(int timer) {   \n    if (timer == 0) {\n       std::cout &lt;&lt; \"Blastoff!\";\n    }\n    else{ \n        std::cout &lt;&lt; timer &lt;&lt; \"...\\n\";\n        countDown(timer-1); // recursive call\n    }\n}"
  },
  {
    "objectID": "content/07_Recursion.html#purpose",
    "href": "content/07_Recursion.html#purpose",
    "title": "Recursion",
    "section": "Purpose",
    "text": "Purpose\n\nRecursion is an alternative way to achieve repetition.\n\nSometimes the iterative approach (loop) isn’t obvious.\n\nRecursion allows us to reduce a difficult problem to a simpler-to-solve problem.\n\nEventually, you hope to reach a (comparatively) trivial case (called the base case).\nRecursive calls stop when the base case is reached."
  },
  {
    "objectID": "content/07_Recursion.html#two-steps-to-recursive-repetition",
    "href": "content/07_Recursion.html#two-steps-to-recursive-repetition",
    "title": "Recursion",
    "section": "Two Steps to Recursive Repetition",
    "text": "Two Steps to Recursive Repetition\nSimilarly to looping (the 3 parts of a loop), recursion has two important steps related to controlling the repetition:\n\n\n\nbase case: A trivial version of the problem in which the function can directly return a result (without calling itself).\n\n\n\n\nrecursive step: A version of the problem in which simplification through a recursive call is required. (No answer can be directly returned.)"
  },
  {
    "objectID": "content/07_Recursion.html#creating-a-recursive-solution",
    "href": "content/07_Recursion.html#creating-a-recursive-solution",
    "title": "Recursion",
    "section": "Creating a Recursive Solution",
    "text": "Creating a Recursive Solution\n\nIdentify the base case and create a condition to test for it.\n\nthis becomes your base condition.\n\n\nIdentify a way to simplify the problem so that applying the simplification repeatedly will eventually lead to the base case.\n\nthis will become the recursive step."
  },
  {
    "objectID": "content/07_Recursion.html#typical-approach",
    "href": "content/07_Recursion.html#typical-approach",
    "title": "Recursion",
    "section": "Typical Approach",
    "text": "Typical Approach\nWhen faced with a very complex problem, the following approach can be used to find a recursive solution:\n\nIdentify patterns in the problem.\n\nLook for a simpler problem that is still the same problem.\n\nThis shows how to simplify during the recursive step(s).\nSome work might be required when you simplify the problem. Pay attention to this “left-over work” - it is key to how the recursive solution performs its task.\n\n\nIdentify the simplest possible version of the (same) problem.\n\nThis is your base case; devise a base condition to test for it.\nIdeally, the base case is trivial, requiring little or no work to solve."
  },
  {
    "objectID": "content/07_Recursion.html#the-base-condition",
    "href": "content/07_Recursion.html#the-base-condition",
    "title": "Recursion",
    "section": "The Base Condition",
    "text": "The Base Condition\n\nA recursive function must contain a test to determine if the base case has been reached.\nThe base condition can always return a result directly, without a recursive call.\nFailure of the recursive step to converge to the base case will result in infinite recursion, which is recursion that continues indefinitely.\n\nInfinite recursion will lead to a program and/or system crash."
  },
  {
    "objectID": "content/07_Recursion.html#recursion-vs-iteration",
    "href": "content/07_Recursion.html#recursion-vs-iteration",
    "title": "Recursion",
    "section": "Recursion VS Iteration",
    "text": "Recursion VS Iteration\n\nFor every recursive function, an iterative solution can also be found.\n\nSometimes finding the iterative solution is difficult.\n\nRecursive solutions will always be less efficient.\nSometimes shorter development time is more important."
  },
  {
    "objectID": "content/07_Recursion.html#towers-of-hanoi",
    "href": "content/07_Recursion.html#towers-of-hanoi",
    "title": "Recursion",
    "section": "Towers of Hanoi",
    "text": "Towers of Hanoi"
  },
  {
    "objectID": "content/07_Recursion.html#towers-of-hanoi-1",
    "href": "content/07_Recursion.html#towers-of-hanoi-1",
    "title": "Recursion",
    "section": "Towers of Hanoi",
    "text": "Towers of Hanoi\n\n\nRules\n\n\n\n\nAll plates begin on one of three pegs, ordered from smallest to largest.\nThe goal is to move all plates to another of the pegs, likewise ordered.\nOnly one plate can be moved at a time.\nPlates not in motion must rest on one of the three pegs.\nA larger plate can never be placed atop a smaller plate."
  },
  {
    "objectID": "content/07_Recursion.html#towers-of-hanoi-2",
    "href": "content/07_Recursion.html#towers-of-hanoi-2",
    "title": "Recursion",
    "section": "Towers of Hanoi",
    "text": "Towers of Hanoi\n\n\nAlgorithm\n\n\n\nMove \\(n-1\\) plates from start to temp (using goal for storage).\nMove the final plate from start to goal.\nMove \\(n-1\\) plates from temp to goal (using start for storage).\n\nSpoiler Alert!"
  },
  {
    "objectID": "content/07_Recursion.html#towers-of-hanoi-3",
    "href": "content/07_Recursion.html#towers-of-hanoi-3",
    "title": "Recursion",
    "section": "Towers of Hanoi",
    "text": "Towers of Hanoi\n\n\nAlgorithm\n\n\n\nMove \\(n-1\\) plates from start to temp (using goal for storage).\nMove the final plate from start to goal.\nMove \\(n-1\\) plates from temp to goal (using start for storage).\n\nSpoiler Alert!\nvoid towers(int n, char start='A', char goal='C', char temp='B'){\n    if(n &gt; 0){\n        towers(n-1, start, temp, goal);\n        cout &lt;&lt; \"Move plate from \" &lt;&lt; start &lt;&lt; \" to \" &lt;&lt; goal &lt;&lt; \".\\n\";\n        towers(n-1, temp, goal, start);\n    }\n}"
  },
  {
    "objectID": "content/09_C-Strings.html#ascii-encoding",
    "href": "content/09_C-Strings.html#ascii-encoding",
    "title": "Characters and C-Style Strings",
    "section": "ASCII Encoding",
    "text": "ASCII Encoding\nInternally, all characters must be encoded into a numeric representation.\nThere is more than one way to do it… But C++ (by default) type char uses the ASCII encoding scheme."
  },
  {
    "objectID": "content/09_C-Strings.html#testing-characters",
    "href": "content/09_C-Strings.html#testing-characters",
    "title": "Characters and C-Style Strings",
    "section": "Testing Characters",
    "text": "Testing Characters\nThe following functions require the &lt;cctype&gt; header.\n\nCharacter testing functions."
  },
  {
    "objectID": "content/09_C-Strings.html#case-conversion",
    "href": "content/09_C-Strings.html#case-conversion",
    "title": "Characters and C-Style Strings",
    "section": "Case Conversion",
    "text": "Case Conversion\nAlso require the &lt;cctype&gt; header.\nFunctions:\n\ntoupper(char c): if c is a lowercase letter, return uppercase equivalent; otherwise, return c unchanged.\ntolower(char c): if c is an uppercase letter, return lowercase equivalent; otherwise, return c unchanged."
  },
  {
    "objectID": "content/09_C-Strings.html#case-conversion-example",
    "href": "content/09_C-Strings.html#case-conversion-example",
    "title": "Characters and C-Style Strings",
    "section": "Case Conversion Example",
    "text": "Case Conversion Example\nchar ch1 = 'H';\nchar ch2 = 'e';\nchar ch3 = '!';\n\ncout &lt;&lt; toupper(ch1);  // displays 'H’\ncout &lt;&lt; toupper(ch2);  // displays 'E’\ncout &lt;&lt; toupper(ch3);  // displays '!'\n\ncout &lt;&lt; tolower(ch1);  // displays 'h’\ncout &lt;&lt; tolower(ch2);  // displays 'e’\ncout &lt;&lt; tolower(ch3);  // displays '!'"
  },
  {
    "objectID": "content/09_C-Strings.html#c-style-strings",
    "href": "content/09_C-Strings.html#c-style-strings",
    "title": "Characters and C-Style Strings",
    "section": "C-Style Strings",
    "text": "C-Style Strings\nC++ provides support for a low-level representation of strings of characters as they were defined in the C language: as null-terminated arrays of type char. We refer to strings of this type as C-Style strings, or simply C-Strings.\n\nString literals such as \"SMITH\" are internally represented as c-strings by default.\nInternally, they look like the following:\n\n\n“SMITH” as seen in memory."
  },
  {
    "objectID": "content/09_C-Strings.html#c-string-variables",
    "href": "content/09_C-Strings.html#c-string-variables",
    "title": "Characters and C-Style Strings",
    "section": "C-String Variables",
    "text": "C-String Variables\nVariables that store c-strings are just arrays of type char:\nchar name[6] = \"SMITH\";\nProduces:\n\n\n\n“SMITH” as seen in a C-style string.\n\n\nThe trailing '\\0' is added automatically during the initialization.\n\nIMPORTANT: The assignment operator only works with c-strings in an initialization statement! You cannot assign c-strings using =!"
  },
  {
    "objectID": "content/09_C-Strings.html#c-string-input",
    "href": "content/09_C-Strings.html#c-string-input",
    "title": "Characters and C-Style Strings",
    "section": "C-String Input",
    "text": "C-String Input\n\nYou can enter c-strings using &gt;&gt; (stream extraction).\n\nInput is whitespace-terminated.\nNo bounds-checking is performed!\n\nFor input containing whitespace, and to control the amount of input, use cin.getline():\n\nSyntax:  std::cin.getline(c_str_name,max_size)\nconst int SIZE = 64;\nchar      name[SIZE];\nstd::cout &lt;&lt; \"Enter your name: \";\nstd::cin.getline(name, SIZE);"
  },
  {
    "objectID": "content/09_C-Strings.html#what-c-strings-cannot-do",
    "href": "content/09_C-Strings.html#what-c-strings-cannot-do",
    "title": "Characters and C-Style Strings",
    "section": "What C-Strings Cannot Do",
    "text": "What C-Strings Cannot Do\n\nYou cannot directly assign c-strings.\n\nWhy? They are arrays!\n\nYou cannot directly compare c-strings.\n\nWhy? They are arrays!"
  },
  {
    "objectID": "content/09_C-Strings.html#c-string-functions",
    "href": "content/09_C-Strings.html#c-string-functions",
    "title": "Characters and C-Style Strings",
    "section": "C-String Functions",
    "text": "C-String Functions\nThe &lt;cstring&gt; header file contains functions that are useful for dealing with c-style strings:\n    Function                    Description \n    ------------------------------------------------------------\n    strlen(str)                 Returns length of `str`\n\n    strcmp(str1, str2)          Compares `str1` to `str2` \n                                \"alphabetically\"\n\n    strcpy(dst, src)            Copies `src` into `dst` \n                                (no bounds check) \n\n    strncpy(dst, src, count)    Copies up to `count` \n                                characters from `src` into \n                                `dst` (no null-terminator added)\n\n    strcat(dst, src)            Concatenates `src` to the end \n                                of `dst` (no bounds check)  \n\n    strncat(dst, src, count)    Concatenates up to `count` \n                                characters from `src` to end \n                                of `dst`, plus the \n                                null-terminator"
  },
  {
    "objectID": "content/09_C-Strings.html#conversion-functions",
    "href": "content/09_C-Strings.html#conversion-functions",
    "title": "Characters and C-Style Strings",
    "section": "Conversion Functions",
    "text": "Conversion Functions\nRequire &lt;cstdlib&gt;\n    Function                   Description \n    ------------------------------------------------------------\n    atoi(str)                   Converts c-string to an int\n    atol(str)                   Converts c-string to a long\n    atof(str)                   Converts c-string to a double"
  },
  {
    "objectID": "content/11_Pointers.html#addresses-and-data",
    "href": "content/11_Pointers.html#addresses-and-data",
    "title": "Pointers",
    "section": "Addresses and Data",
    "text": "Addresses and Data\nEvery variable in a program is stored at a unique memory address.\n\n\nThe unary & is the address operator; the address operator retrieves the address of its operand:\n\n\nint x = 42;\n// Print out the address at which x is stored:\nstd::cout &lt;&lt; &x &lt;&lt; \"\\n\";\n\n\nWe don’t usually care about the address ourselves, and our users wouldn’t care either. So, printing it to the screen is only useful as a learning exercise. But what we do care about is what we can do with the address of a variable. Read on…"
  },
  {
    "objectID": "content/11_Pointers.html#pointers",
    "href": "content/11_Pointers.html#pointers",
    "title": "Pointers",
    "section": "Pointers",
    "text": "Pointers\n\nA pointer is a variable that stores a memory address.\n\nDeclare by adding the pointer type modifier ( * ) to a variable declaration.\n\nThe pointer will hold the address of a value of the specified type.\n\n\n\nExample: (pointer to an int)\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x"
  },
  {
    "objectID": "content/11_Pointers.html#why",
    "href": "content/11_Pointers.html#why",
    "title": "Pointers",
    "section": "Why?",
    "text": "Why?\n\nLow-level access.\n\nTo provide explicit, direct access (no copy) in a similar way to what we do implicity with pass by reference.\n\nIteration\n\nPointer math makes array manipulation through pointers very convenient.\nAdvanced data structures may only allow iteration through pointers.\n\nDynamic Memory Allocation\n\nMemory generated at runtime is only identified to the program through its address."
  },
  {
    "objectID": "content/11_Pointers.html#why-simplified",
    "href": "content/11_Pointers.html#why-simplified",
    "title": "Pointers",
    "section": "Why? (simplified)",
    "text": "Why? (simplified)\n\nObservation and Modification\n\nObserving Pointers: Pointers can be used to observe the contents of memory, and potentially to modify the values under observation as well.\n\n\nOwnership\n\nOwning Pointers: Pointers can be used to maintain “ownership” of dynamically-allocated memory resources."
  },
  {
    "objectID": "content/11_Pointers.html#physical-view",
    "href": "content/11_Pointers.html#physical-view",
    "title": "Pointers",
    "section": "Physical View",
    "text": "Physical View\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\nThe following figure illustrates the physical view of what a pointer actually looks like in memory. The pointer xPtr contains the address of the location where x is stored:\n\nPhysical view of pointer in memory."
  },
  {
    "objectID": "content/11_Pointers.html#logical-view",
    "href": "content/11_Pointers.html#logical-view",
    "title": "Pointers",
    "section": "Logical View",
    "text": "Logical View\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\nThe following figure illustrates the logical view of what a pointer conceptually does. The pointer xPtr points to the the variable x:\n\nConceptual view of pointer in memory."
  },
  {
    "objectID": "content/11_Pointers.html#physical-and-logical-view",
    "href": "content/11_Pointers.html#physical-and-logical-view",
    "title": "Pointers",
    "section": "Physical and Logical View",
    "text": "Physical and Logical View\nint x = 75;    // just a normal integer\n// [...]\nint* xPtr;     // declare a pointer to an int\nxPtr = &x;     // point xPtr to x\n\n\n\nPhysical view of pointer in memory.\n\n\n\n\n\nConceptual view of pointer in memory."
  },
  {
    "objectID": "content/11_Pointers.html#indirection",
    "href": "content/11_Pointers.html#indirection",
    "title": "Pointers",
    "section": "Indirection",
    "text": "Indirection\nKnowing the address of where something is stored gives a programmer low-level access to the data at that location.\n\nPointers store the addresses of other variables; they give us indirect control over the values in those variables.\nThe indirection operator (*) allows us to “follow” a pointer to the address it is storing, so that we may operate on the data stored there.\n\nThis is known as dereferencing the pointer.\nThe indirection operator is also sometimes called the dereference operator."
  },
  {
    "objectID": "content/11_Pointers.html#null-pointers",
    "href": "content/11_Pointers.html#null-pointers",
    "title": "Pointers",
    "section": "“Null” Pointers",
    "text": "“Null” Pointers\nA pointer that doesn’t point to any (legal) memory address is referred to as a “null pointer”.\n\nC++11 added a keyword to represent the literal value of a null pointer: nullptr.\n\nint* x = nullptr; // declare and initialize to nullptr\n\nSetting a pointer to nullptr guarantees that it cannot be dereferenced.\n\n(Basically, you can’t use a null pointer for anything.)"
  },
  {
    "objectID": "content/11_Pointers.html#pointers-to-arrays",
    "href": "content/11_Pointers.html#pointers-to-arrays",
    "title": "Pointers",
    "section": "Pointers to Arrays",
    "text": "Pointers to Arrays\nint a[5] = { 1, 2, 3, 4, 5 };  // normal array\nPointers can be used to access elements of an array.\nint* aPtr = a; // no need for `&`: `a` degrades to a pointer\nPointer mathematics.\nThis is why the type is important for pointers.\nstd::cout &lt;&lt; *(aPtr + 2) &lt;&lt; \"\\n\"; // prints a[2]\nPointer and array notation is interchangeable.\nstd::cout &lt;&lt; aPtr[2] &lt;&lt; \"\\n\";  // easier than \"*(aPtr + 2)\""
  },
  {
    "objectID": "content/11_Pointers.html#more-pointer-math",
    "href": "content/11_Pointers.html#more-pointer-math",
    "title": "Pointers",
    "section": "More Pointer Math",
    "text": "More Pointer Math\nPointers support the following mathematical operations:\nOperation           Example      Description\n----------------------------------------------------\n &lt;ptr&gt; + &lt;int&gt;      xPtr + 3     Add an offset\n &lt;ptr&gt; - &lt;int&gt;      xPtr - 2     Subtract an offset\n ++&lt;ptr&gt;            ++xPtr       (pre) increment\n &lt;ptr&gt;++            xPtr++       (post) increment\n --&lt;ptr&gt;            --xPtr       (pre) decrement\n &lt;ptr&gt;--            xPtr--       (post) decrement\n &lt;ptr&gt; - &lt;ptr&gt;      xPtr - yPtr  Offset distance \n                                 between two pointers"
  },
  {
    "objectID": "content/11_Pointers.html#pointers-as-iterators",
    "href": "content/11_Pointers.html#pointers-as-iterators",
    "title": "Pointers",
    "section": "Pointers as “Iterators”",
    "text": "Pointers as “Iterators”\nYou can use a pointer to “move around” in an array:\nint a[5] = { 1, 2, 3, 4, 5 };\n// [...]\nint* begin = a;               // start is first addr of a\nint* end   = a + 5;           // end is start + size\n\n// \"For each element in a\", using a pointer for movement:\nfor(int* current = begin; current != end; current++){\n    std::cout &lt;&lt; *current &lt;&lt; \"\\t\";\n}\nThis design pattern is very common in the C++ Standard Template Library."
  },
  {
    "objectID": "content/11_Pointers.html#passing-pointers-to-functions",
    "href": "content/11_Pointers.html#passing-pointers-to-functions",
    "title": "Pointers",
    "section": "Passing Pointers to Functions",
    "text": "Passing Pointers to Functions\n\nA pointer may be used as an alternative syntax for passing a 1-D array to a function.\n\nPointer notation is commonly used for c-strings, for example.\n\nPointer values behave as a primitive type.\n\nThey are passed by value, like all other primitive types.\n\nPointers may also be passed by reference if the address in the pointer itself should be changed by the function.\n\nDoing so requires adding the reference type modifier (&)to the formal parameter, just like with any other primitive data."
  },
  {
    "objectID": "content/11_Pointers.html#common-design-pattern-range-based-operations-with-pointers-to-arrays",
    "href": "content/11_Pointers.html#common-design-pattern-range-based-operations-with-pointers-to-arrays",
    "title": "Pointers",
    "section": "Common design pattern: “Range”-based operations with pointers to arrays",
    "text": "Common design pattern: “Range”-based operations with pointers to arrays\n// Assume array `a` already declared as `int a[5];`\nint* begin = a;     // \"left\" edge of array\nint* end   = a + 5; // \"right\" edge of array\n\nPointers to range in array a.Notice that end physically points to the first memory address beyond the end of the array. For this reason, it would be an error to try to dereference end. We must be careful to ensure that never happens.\nThis pattern also applies to iterators to array-like data structures."
  },
  {
    "objectID": "content/11_Pointers.html#common-design-pattern-range-based-operations-with-pointers-to-sub-arrays",
    "href": "content/11_Pointers.html#common-design-pattern-range-based-operations-with-pointers-to-sub-arrays",
    "title": "Pointers",
    "section": "Common design pattern: “Range”-based operations with pointers to sub-arrays",
    "text": "Common design pattern: “Range”-based operations with pointers to sub-arrays\n// Assume array `a` already declared as `int a[5];`\nint* first = a + 1;  // \"left\" edge of subrange\nint* last  = a + 4;  // \"right\" edge of subrange\n\nPointers to range in array a.In this usage, we are bracketing a subrange of values within the larger array. Again, notice that the last pointer points to a value outside that subrange - it should not be dereferenced.\nThis pattern also applies to iterators to array-like data structures."
  },
  {
    "objectID": "content/13_Input_and_Output.html#input-streams",
    "href": "content/13_Input_and_Output.html#input-streams",
    "title": "Input and Output",
    "section": "Input Streams",
    "text": "Input Streams\nAn input stream brings information from the outside world into the running program.\n\nThe standard input stream is named std::cin\n\nOften shortened to cin (add using std::cin after the include)\nWe will refer to the standard input stream as cin in discussion\n\nInput streams work together with the stream extraction operator ( &gt;&gt; ).\n\n&gt;&gt; extracts data from the stream (on its left) and stores the data in the variable on its right."
  },
  {
    "objectID": "content/13_Input_and_Output.html#stream-extraction---details",
    "href": "content/13_Input_and_Output.html#stream-extraction---details",
    "title": "Input and Output",
    "section": "Stream Extraction - details",
    "text": "Stream Extraction - details\n\nThe type of the variable that is intended to store the data must match the type of the data being extracted.\n\nThe extraction may fail if this is not the case.\n\nThe stream extraction operator is whitespace delimited, meaning that it will read the next series of non-whitespace characters in the input stream and convert those to the required type.\n\nThis means you cannot read anything containing spaces using &gt;&gt;."
  },
  {
    "objectID": "content/13_Input_and_Output.html#streams-plural",
    "href": "content/13_Input_and_Output.html#streams-plural",
    "title": "Input and Output",
    "section": "Streams: Plural",
    "text": "Streams: Plural\nYou have used the standard input stream and the standard output stream; C++ provides the opportunity to create other streams as well.\n\nAll input streams support the same operations.\nAll output streams support the same operations.\nSo, if you can use std::cin and std::cout, you can use any stream!"
  },
  {
    "objectID": "content/13_Input_and_Output.html#getline",
    "href": "content/13_Input_and_Output.html#getline",
    "title": "Input and Output",
    "section": "getline()",
    "text": "getline()\nIn order to read a std::string that may contain whitespace from an input stream, the getline() function should be used:\nstd::string full_name;\n\nstd::cout &lt;&lt; \"Enter your first and last name: \";\ngetline(std::cin, full_name);\n\nstd::cout &lt;&lt; \"Hello, \" &lt;&lt; full_name &lt;&lt; \"!\\n\";\ngetline() will read an entire line of user input (until the &lt;ENTER&gt; key is pressed). The syntax is:  getline( source_stream , destination_string ) \nWhere source stream is any input stream and destination string is a variable of type std::string."
  },
  {
    "objectID": "content/13_Input_and_Output.html#cin.get",
    "href": "content/13_Input_and_Output.html#cin.get",
    "title": "Input and Output",
    "section": "cin.get()",
    "text": "cin.get()\nThe cin.get() function can be used to read a single character, which may be whitespace, from the standard input stream.\nExample\nchar ch;\n// Reading the &lt;ENTER&gt; key with `&gt;&gt;` alone is difficult... \n// So, use `get()`:\nstd::cout &lt;&lt; \"Press &lt;ENTER&gt; to continue...\";\nstd::cin.get(ch); // Will wait for the enter key, then continue.\nThe get() function also works with other streams, in general the syntax is:  stream.get(character_var)"
  },
  {
    "objectID": "content/13_Input_and_Output.html#in-case-the-stream-goes-bad",
    "href": "content/13_Input_and_Output.html#in-case-the-stream-goes-bad",
    "title": "Input and Output",
    "section": "In case the stream goes bad…",
    "text": "In case the stream goes bad…\nIf you are working with an open stream, several things can cause the stream to no longer be in the “good” state. The most common are:\n\nFailure of stream extraction operator to convert the apparent type it “sees” to the type requested on its right-hand side.\nEnd-of-file (or end of stream) encountered during a “read” operation.\n\nIn these cases you may be able to remedy the problem – perhaps by removing unwanted characters from the stream with ignore(), or by moving the stream position “earlier” in the stream in case of EOF – then resume operation. The clear() method will help with this by clearing the stream’s state flags:\nstd::cin.clear();  // clears the state flags on `cin`"
  },
  {
    "objectID": "content/13_Input_and_Output.html#files-1",
    "href": "content/13_Input_and_Output.html#files-1",
    "title": "Input and Output",
    "section": "Files",
    "text": "Files\nTo work with files, start by including the &lt;fstream&gt; library.\n\nWe will be working with files in text mode, meaning the contents are encoded as plain ASCII text.\n\nOur interaction with the file will “feel” exactly the same as interacting with a user/screen.\n\nYou can also access a file in pure binary mode as well. (later)"
  },
  {
    "objectID": "content/13_Input_and_Output.html#file-operations",
    "href": "content/13_Input_and_Output.html#file-operations",
    "title": "Input and Output",
    "section": "File Operations",
    "text": "File Operations\nWorking with files will involve the following series of high-level steps:\n\nOpen the file\n\nThis associates the file name with the physical file, and initializes a stream to/from the file.\n\nRead or write data from/to the file\n\nThe file can be read/written as a stream - just like any other stream.\n\nClose the file\n\nThis allows the Operating System to release resources associated with the file, and flush buffers."
  },
  {
    "objectID": "content/13_Input_and_Output.html#output-file-streams",
    "href": "content/13_Input_and_Output.html#output-file-streams",
    "title": "Input and Output",
    "section": "Output File Streams",
    "text": "Output File Streams\n\nCreate a std::ofstream file stream object and use it to open and manipulate the file:\n\ndouble value1 = 4.4, value2 = 3.8;       \nstd::ofstream fout;             // declare a stream\nfout.open(\"my_input_file.txt\"); // open the file\nfout &lt;&lt; value1                  // insert values\n     &lt;&lt; \"\\n\"                    // separated on\n     &lt;&lt; value2;                 // two lines\nfout.close();                   // close the file"
  },
  {
    "objectID": "content/13_Input_and_Output.html#input-file-streams",
    "href": "content/13_Input_and_Output.html#input-file-streams",
    "title": "Input and Output",
    "section": "Input File Streams",
    "text": "Input File Streams\n\nCreate a std::ifstream file stream object and use it to open and manipulate the file:\n\ndouble value1, value2;        \nstd::ifstream fin;             // declare a stream\nfin.open(\"my_input_file.txt\"); // open the file\nfin &gt;&gt; value1 &gt;&gt; value2;       // read some values\nfin.close();                   // close the file\nstd::cout &lt;&lt; value1 &lt;&lt; \", \" &lt;&lt; value2 &lt;&lt; \"\\n\";"
  },
  {
    "objectID": "content/13_Input_and_Output.html#alternatives",
    "href": "content/13_Input_and_Output.html#alternatives",
    "title": "Input and Output",
    "section": "Alternatives",
    "text": "Alternatives\n\nYou can also declare and open in one line:\n\nstd::ifstream fin(\"my_input_file.txt\");\n\nA std::fstream object can do either input or output – or both, but you must specify the open mode:\n\nstd::fstream fp;"
  },
  {
    "objectID": "content/13_Input_and_Output.html#open-modes",
    "href": "content/13_Input_and_Output.html#open-modes",
    "title": "Input and Output",
    "section": "Open Modes",
    "text": "Open Modes\n\n\n\nOpen Mode       Description\n---------------------------------------------\nstd:: ios::in   Input mode (file must exist)\nstd:: ios::out  Output mode (file will be \n                created, if it exists, it will\n                be overwritten)\nstd:: ios::app  Use with ios::out to append \n                to the end of an output file.\n\n\n\nThere are other modes as well, but they are not of interest to us at this time."
  },
  {
    "objectID": "content/13_Input_and_Output.html#file-open-failures",
    "href": "content/13_Input_and_Output.html#file-open-failures",
    "title": "Input and Output",
    "section": "File Open Failures",
    "text": "File Open Failures\n\nOpening an input file may fail if:\n\nThe file does not exist, or is misnamed.\nYou do not have permission to read the file.\nAll OS file resources are in use.\n\nOpening an output file may fail if:\n\nThe file exists, but you do not have permission to overwrite it.\nYou do not have permission to write in the destination directory.\nAll OS file resources are in use."
  },
  {
    "objectID": "content/13_Input_and_Output.html#testing-for-file-open-success",
    "href": "content/13_Input_and_Output.html#testing-for-file-open-success",
    "title": "Input and Output",
    "section": "Testing for File Open Success",
    "text": "Testing for File Open Success\nFile streams support a function called is_open() that will return true if the file was opened successfully. This function can be used to check for a failure to open.\nWe will cover if statements soon, but here is a sneak peek:\nstd::ifstream fin;                         \nfin.open(\"my_input_file.txt\");             \nif( !fin.is_open() ){                      \n    std::cout &lt;&lt; \"Failed to open file.\\n\"; \n    exit(1);                               \n}"
  },
  {
    "objectID": "content/15_Structures.html#enum",
    "href": "content/15_Structures.html#enum",
    "title": "Structures",
    "section": "enum",
    "text": "enum\nEnumerated Type\n\nAllows the programmer to specify mnemonic literals.\nLow-level, not very flexible.\nExample:\n\nenum WorkDayAbr = {mon, tue, wed, thr, fri};\n\n//... later in the program ...\n\nWorkDayAbr today = mon;"
  },
  {
    "objectID": "content/15_Structures.html#modern-c-prefers-scoped-enum",
    "href": "content/15_Structures.html#modern-c-prefers-scoped-enum",
    "title": "Structures",
    "section": "Modern C++ prefers “scoped enum”",
    "text": "Modern C++ prefers “scoped enum”\nenum class WorkDayAbr{ mon, tue, wed,   // struct or class\n                       thr, fri };\n-----------------------------------------\nint rain[5]     {5, 15, 35, 95, 10};\nstring names[5] {\"Monday\", \"Tuesday\", \"Wednesday\", \n                 \"Thursday\",\"Friday\"};\nfor (int i = static_cast&lt;int&gt;(WorkDayAbr::mon);\n     i &lt;= static_cast&lt;int&gt;(WorkDayAbr::fri); ++i) {\n    cout &lt;&lt; \"Rain chance for \" &lt;&lt; names[i] &lt;&lt; \": \" &lt;&lt; rain[i] &lt;&lt; endl;\n}\n\nenum values do not implicitly cast to int - you have to static_cast.\nYou can define your own operators (like ++) to make it easier to work with these…\nCore Guidelines: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-enum"
  },
  {
    "objectID": "content/15_Structures.html#structures",
    "href": "content/15_Structures.html#structures",
    "title": "Structures",
    "section": "Structures",
    "text": "Structures\nStructures are used to “glue” several other types together to create a new type.\nThis is ideal when there is a lot of “related” data that represents a single “thing” in your code.\n\nStructures specify attributes, and potentially also behaviors.\nThe keyword struct is used to define a structure:\n\nstruct Circle {\n   int x;\n   int y;\n   double radius;\n};  // Notice the semicolon!"
  },
  {
    "objectID": "content/15_Structures.html#structures-and-functions",
    "href": "content/15_Structures.html#structures-and-functions",
    "title": "Structures",
    "section": "Structures and Functions",
    "text": "Structures and Functions\nThe previous function passed a structure to the printCircle() function by value.\n\nIs this a good idea?\nConsider passing by (const) reference instead:\n\nvoid printCircle(const Circle& c){\n    cout &lt;&lt; \"(\"      &lt;&lt; c.x\n         &lt;&lt; \",\"      &lt;&lt; c.y\n         &lt;&lt; \") r = \" &lt;&lt; c.radius;\n}\nAnd if you need the parameter to be changed by the function, use non-const reference:\nvoid readCircle(Circle& c){\n    cout &lt;&lt; \"Enter x and y: \";\n    cin  &gt;&gt; c.x &gt;&gt; c.y;\n    cout &lt;&lt; \"Enter radius:  \";\n    cin  &gt;&gt; c.radius;\n}"
  },
  {
    "objectID": "content/15_Structures.html#parallel-arrays-vs-structures",
    "href": "content/15_Structures.html#parallel-arrays-vs-structures",
    "title": "Structures",
    "section": "Parallel Arrays VS Structures",
    "text": "Parallel Arrays VS Structures\n\nParallel arrays store related data by common indexing.\nStructures store related data in a single variable…\n\nAn array of structures can be used in place of parallel arrays.\n\nWhen should you choose structures?\n\nHow closely are the data related?\nDo the items really “belong” to the same thing?\n\nIf so, structures would make sense\n\n\nPassing a single array VS passing several arrays\n\nEase of use is always a factor!"
  },
  {
    "objectID": "content/15_Structures.html#what-about-operators",
    "href": "content/15_Structures.html#what-about-operators",
    "title": "Structures",
    "section": "What About Operators?",
    "text": "What About Operators?\n\n\n\n\n\n\nA look ahead\n\n\nYou can also overload operators (and other functions) so that they will work with your new type:\n\n\n\nstd::ostream& operator&lt;&lt; (std::ostream& outstr,\n                          const Circle& c) {\n    outstr &lt;&lt; \"(\"      &lt;&lt; c.x\n           &lt;&lt; \",\"      &lt;&lt; c.y\n           &lt;&lt; \") r = \" &lt;&lt; c.radius;\n    return outstr;\n}\n\n\nMore info on operator overloading is coming soon … or read ahead to Chapter 14, or search online."
  },
  {
    "objectID": "content/15_Structures.html#assignment",
    "href": "content/15_Structures.html#assignment",
    "title": "Structures",
    "section": "Assignment",
    "text": "Assignment\nWhat happens when you assign one structure to another directly?\n\nThe assignment operator ( = ) makes a bit-wise copy of the entire structure’s contents.\n\n“Plain old data” is copied exactly correctly.\nArrays are encapsulated in the structure; they get copied as well!\n\nContrast with how arrays are usually treated…\n\n\n\n\n\nPointers can cause trouble!\n\nThe copy applies to the pointer only, not the item being pointed to.\n\nResources can cause trouble!\n\nNever make a copy of something like an open stream."
  },
  {
    "objectID": "content/15_Structures.html#initial-values",
    "href": "content/15_Structures.html#initial-values",
    "title": "Structures",
    "section": "Initial Values",
    "text": "Initial Values\nC++11 added the ability to include initialization in a structure definition:\nstruct Person {\n    int    age   = 0;    // initialize to 0\n    string name;\n};\n\nHere, inline member initialization is used to provide initial values for age.\n\n\nPerson p3{20, \"Cassandra\"}; // only if -std=c++14 or later\n\n\nC++ version warning:\nIf you specify initializers, you will not be able to use uniform initializer syntax with your new type in C++11, but in C++14 and afterward, it is OK."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#dynamic-memory-notes",
    "href": "content/17_Dynamic_Memory.html#dynamic-memory-notes",
    "title": "Dynamic Memory",
    "section": "Dynamic Memory Notes",
    "text": "Dynamic Memory Notes\n\n\nnew allocates memory from a pool of free memory known as the free store (or more commonly, “heap”).\n\nThe heap is a limited resource.\n\nThe pointer returned from the new operation is the only “link” you have to the heap-allocated memory.\n\nThe “owner” of this pointer has the responsibility to make sure the memory is eventually deleted.\n\nIf you lose the pointer, you’ve leaked the memory!\nYou may transfer ownership to another part of the program by passing the pointer.\n\n\n\n\nConceptual memory layout with stack and heap."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#dynamic-arrays",
    "href": "content/17_Dynamic_Memory.html#dynamic-arrays",
    "title": "Dynamic Memory",
    "section": "Dynamic Arrays",
    "text": "Dynamic Arrays\n\n\n\n\n\n\nNormal C++ arrays cannot be sized at runtime. This is a severe limitation.\n\n\n\n\nEither we over-allocate, which wastes space…\nOr we place a strict limit on the ability of the program’s data to “grow”.\n\nWith dynamic memory allocation, a variable can be used to determine the size of an array at runtime.\n\n\nThis gives us the ability to write programs that “adapt” to the size of the data."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#dynamic-array-notes",
    "href": "content/17_Dynamic_Memory.html#dynamic-array-notes",
    "title": "Dynamic Memory",
    "section": "Dynamic Array Notes",
    "text": "Dynamic Array Notes\n\n\nNote the different new and delete operators for arrays:\n\n\nint size = 10;\nint* a = new int[size];   // new array\n// [...]\ndelete [] a;              // delete array\na = nullptr;\n\n\n\nnew Array Syntax\n\nnew  type[size]\n\n\n\n\n\ndelete Array Syntax\n\ndelete []  ptr"
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#what-if-something-goes-wrong",
    "href": "content/17_Dynamic_Memory.html#what-if-something-goes-wrong",
    "title": "Dynamic Memory",
    "section": "What if something goes wrong?",
    "text": "What if something goes wrong?\n\nAn exception is thrown and the program will terminate if there is not enough free memory to complete the request.\nOr, you can use the (std::nothrow) version:\n\nint *xPtr = new(std::nothrow) int;\n\n\nIn this case, test that the address returned isn’t nullptr (nullptr will indicate failure).\n\n\nEx:   if(xPtr == nullptr)   // failed"
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#dynamic-memory-summary",
    "href": "content/17_Dynamic_Memory.html#dynamic-memory-summary",
    "title": "Dynamic Memory",
    "section": "Dynamic Memory Summary",
    "text": "Dynamic Memory Summary\n\nIf you “new” it, you “delete” it!\nnew and delete operations may or may not be in the same scope\n\nThis is a feature: It is one way to make data survive going out of scope.\n\nFailure to delete == memory leak!\nThis is what destructors are good at!\n\nObjects that do “new” operations will require a destructor."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#modern-c-smart-pointers",
    "href": "content/17_Dynamic_Memory.html#modern-c-smart-pointers",
    "title": "Dynamic Memory",
    "section": "Modern C++ Smart Pointers",
    "text": "Modern C++ Smart Pointers\nC++11 introduced “smart pointers”, which are really objects that are used to wrap a raw pointer and provide more automatic management of resources “owned” by the pointer.\n\n\n\nThree kinds of smart pointer in C++11:\n\nunique_ptr - used for exclusive ownership\nshared_ptr - used for shared ownership\nweak_ptr - a non-owning reference to a shared_ptr that can be upgraded to a shared_ptr.\n\n\n\nRequires the header &lt;memory&gt;"
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#unique_ptr",
    "href": "content/17_Dynamic_Memory.html#unique_ptr",
    "title": "Dynamic Memory",
    "section": "unique_ptr",
    "text": "unique_ptr\nA unique_ptr retains sole ownership of an object, and destroys the object when the unique_ptr goes out of scope.\n\nExample\nint main(){   \n   unique_ptr&lt;int&gt; ptr{ new int }; // allocate & take ownership\n   *ptr = 99;                      // place 99 at ptr\n   std::cout &lt;&lt; *ptr &lt;&lt; \"\\n\";      // print value at ptr (99)\n   return 0;                       // frees memory as ptr leaves\n}                                  // its local scope\n\nYou must tell the unique_ptr what type of data it will point to.\n\nThe part in the angle-brackets is called a template type argument\n\nYou must initialize the unique_ptr to contain a pointer to a dynamically-allocated object."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#unique_ptr-to-array",
    "href": "content/17_Dynamic_Memory.html#unique_ptr-to-array",
    "title": "Dynamic Memory",
    "section": "unique_ptr to Array",
    "text": "unique_ptr to Array\nint main(){\n    int n_scores;                           // size\n    std::cout &lt;&lt; \"Enter number of scores: \";\n    std::cin  &gt;&gt; n_scores;\n\n    // allocate array and take ownership with `scores`:\n    std::unique_ptr&lt;double[]&gt; scores{ new double[n_scores] };\n\n    for(int i = 0; i &lt; n_scores; i++){\n        std::cout &lt;&lt; \"Enter score \" &lt;&lt; (i+1) &lt;&lt; \": \";\n        std::cin  &gt;&gt; scores[i];\n    }\n    // [...]    Use the data for something interesting...\n    return 0;   // scores gets de-allocated automatically\n}\n\nPay attention to the type argument &lt;double[]&gt; : Type &lt;double*&gt; will not work here."
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#alternative-construct-with-make_unique",
    "href": "content/17_Dynamic_Memory.html#alternative-construct-with-make_unique",
    "title": "Dynamic Memory",
    "section": "Alternative: Construct with make_unique():",
    "text": "Alternative: Construct with make_unique():\nModern C++ idioms seem to be pushing toward using the make_unique() function (and make_shared() for shared_ptr):\n\n\nint main(){\n    unique_ptr&lt;int&gt; ptr{ std::make_unique(99) }; // allocate and init\n    std::cout &lt;&lt; *ptr &lt;&lt; \"\\n\";                   // print value at ptr (99)\n    \n    int n_scores;                                // size for array\n    std::cout &lt;&lt; \"Enter number of scores: \";\n    std::cin  &gt;&gt; n_scores;\n\n    // allocate array and take ownership with `scores`:\n    std::unique_ptr&lt;double[]&gt; scores{ std::make_unique&lt;double[]&gt;(n_scores) };\n\n    for(int i = 0; i &lt; n_scores; i++){\n        std::cout &lt;&lt; \"Enter score \" &lt;&lt; (i+1) &lt;&lt; \": \";\n        std::cin  &gt;&gt; scores[i];\n    }\n    // [...]    Use the data for something interesting...\n    return 0;   // scores and ptr are de-allocated automatically\n}"
  },
  {
    "objectID": "content/17_Dynamic_Memory.html#putting-it-together-with-auto",
    "href": "content/17_Dynamic_Memory.html#putting-it-together-with-auto",
    "title": "Dynamic Memory",
    "section": "Putting it together with auto:",
    "text": "Putting it together with auto:\n\n\n\nint main(){\n    auto ptr{ std::make_unique(99) };         // allocate and init\n    std::cout &lt;&lt; *ptr &lt;&lt; \"\\n\";                // print value at ptr (99)\n    \n    int n_scores;                             // size for array\n    std::cout &lt;&lt; \"Enter number of scores: \";\n    std::cin  &gt;&gt; n_scores;\n\n    // allocate array and take ownership with `scores`:\n    auto scores{ std::make_unique&lt;double[]&gt;(n_scores) };\n\n    for(int i = 0; i &lt; n_scores; i++){\n        std::cout &lt;&lt; \"Enter score \" &lt;&lt; (i+1) &lt;&lt; \": \";\n        std::cin  &gt;&gt; scores[i];\n    }\n    // [...]    Use the data for something interesting...\n    return 0;   // scores and ptr are de-allocated automatically\n}\n\nChoose the version you think is easier to understand.\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nDynamic Memory"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#introduction",
    "href": "content/19_Classes_and_Objects.html#introduction",
    "title": "Classes and Objects",
    "section": "Introduction",
    "text": "Introduction\n\nProcedural (structured) Programming\n\nConcerned with processes (actions) that occur in a program.\nBasic unit of modularity is the function.\n\nObject-Oriented Programming (OOP)\n\nFocuses on the data (things) and the functions that operate on it.\nBasic unit of modularity is the class (or structure)."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#oop-central-concepts",
    "href": "content/19_Classes_and_Objects.html#oop-central-concepts",
    "title": "Classes and Objects",
    "section": "OOP Central Concepts",
    "text": "OOP Central Concepts\n\nEncapsulation\n\nBundling\nData / Implementation Hiding\n\nPrinciple of least privilege.\n\nPublic Interface\n\nClass Hierarchies (Inheritance)\n\nFactoring out common data/behavior.\nStandardizing a common (public) interface."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#oop-terminology",
    "href": "content/19_Classes_and_Objects.html#oop-terminology",
    "title": "Classes and Objects",
    "section": "OOP Terminology",
    "text": "OOP Terminology\n\n\nClass - Encapsulates data and functions that are related, essentially like a structure. Creates a new type.\n\nThe class is the blueprint describing the new type of thing.\n\nObject - an instance of a class.\n\nThe object is the real thing that is built by following the blueprint.\n\nAttributes - a class’s member data\nMethods - a class’s member functions\n\n\nWe will use class and struct somewhat interchangeably."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#format-of-a-class",
    "href": "content/19_Classes_and_Objects.html#format-of-a-class",
    "title": "Classes and Objects",
    "section": "Format of a Class",
    "text": "Format of a Class\n\n\nclass ClassName {\n    declaration;\n    declaration;\n};\n\n\nExample\nstruct Rectangle {   |   class Rectangle {\n    double length;   |       public:\n    double width;    |           double length;\n    double area;     |           double width;\n};                   |           double area();\n                     |   };"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#access-specifiers",
    "href": "content/19_Classes_and_Objects.html#access-specifiers",
    "title": "Classes and Objects",
    "section": "Access Specifiers",
    "text": "Access Specifiers\n\n\npublic - Available both inside and outside the class definition.\nprivate - Only available inside the class definition.\nprotected - Similar to private (we’ll see this later).\n\n\n\nOrder doesn’t matter.\nDefault is private for class. (Default is public for struct.)\n\nThis is the only difference between class and struct in C++."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#methods",
    "href": "content/19_Classes_and_Objects.html#methods",
    "title": "Classes and Objects",
    "section": "Methods",
    "text": "Methods\n\nPrototype in class declaration\nDefinition usually in separate implementation file.\n\nMay also be in same file.\n\nScope resolution operator ( :: ) – used to establish ownership of an identifier\n\nMust be used when splitting method definitions from the class declaration.\n\nPrivate methods – what good are they?"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#separating-specification-and-implementation",
    "href": "content/19_Classes_and_Objects.html#separating-specification-and-implementation",
    "title": "Classes and Objects",
    "section": "Separating Specification and Implementation",
    "text": "Separating Specification and Implementation\n\nHeader files ( MyClass.h ) – place class specification (declaration) here\nImplementation file ( MyClass.cpp ) – implement methods here\n#include the header from the implementation file\nImplementation ( .cpp ) files can be compiled; header files cannot.\nNEVER #include a .cpp file!"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#accessors-and-mutators",
    "href": "content/19_Classes_and_Objects.html#accessors-and-mutators",
    "title": "Classes and Objects",
    "section": "Accessors and Mutators",
    "text": "Accessors and Mutators\n\nProvides a way to safely access data members.\nPrinciple of least privilege.\nStale data (Avoid it!)\nAllows the class to disallow incorrect states."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#constructors",
    "href": "content/19_Classes_and_Objects.html#constructors",
    "title": "Classes and Objects",
    "section": "Constructors",
    "text": "Constructors\n\nAllow an object to be instantiated (created) in an already-working state.\n\nContrast this with the uninitialized state that regular data and structs begin with.\n\nConstructors do not have any return type.\nConstructors have the same name as the class.\nDefault constructor is a constructor that takes no parameters; used to create a “default” or “blank” object.\nConstructors may take parameters to allow initialization during instantiation.\nClasses do not always have a default constructor."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#constructors-1",
    "href": "content/19_Classes_and_Objects.html#constructors-1",
    "title": "Classes and Objects",
    "section": "Constructors",
    "text": "Constructors\n\nAllow an object to be instantiated (created) in an already-working state.\n\nContrast this with the uninitialized state that regular data and structs begin with.\n\nConstructors do not have any return type.\nConstructors have the same name as the class.\nDefault constructor is a constructor that takes no parameters; used to create a “default” or “blank” object.\nConstructors may take parameters to allow initialization during instantiation.\nClasses do not always have a default constructor."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#constructors-c-tors",
    "href": "content/19_Classes_and_Objects.html#constructors-c-tors",
    "title": "Classes and Objects",
    "section": "Constructors (c-tors)",
    "text": "Constructors (c-tors)\n\n\nA constructor’s job is to initialize attributes of the class:\n\n\nclass Rectangle {\n    public:\n        Rectangle (int l, int w){\n            length = l;\n            width  = w;\n        }\n        int length;\n        int width;\n};"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#c-tor-initialization-lists",
    "href": "content/19_Classes_and_Objects.html#c-tor-initialization-lists",
    "title": "Classes and Objects",
    "section": "c-tor initialization lists",
    "text": "c-tor initialization lists\n\nBut… there is another way to do it: Constructor initialization list\n\nCompact syntax for placing values into attributes in a constructor implementation.\nGuarantees initialization before body of constructor executes."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#destructors",
    "href": "content/19_Classes_and_Objects.html#destructors",
    "title": "Classes and Objects",
    "section": "Destructors",
    "text": "Destructors\n\nCalled automatically when object is destroyed\n\nEither by being deleted or going out of scope\n\nNamed same as class, but begins with ~\nNo return value, no parameters\nCannot be overloaded\n… when and why destructors are needed"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#inline-methods",
    "href": "content/19_Classes_and_Objects.html#inline-methods",
    "title": "Classes and Objects",
    "section": "Inline Methods",
    "text": "Inline Methods\n\nImplemented directly in class specification.\nSubstituted during compilation.\nSpeed VS executable size\n“inline all 1-liners”\ninline keyword\n\nCan be used to inline functions implemented separately."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#overloading",
    "href": "content/19_Classes_and_Objects.html#overloading",
    "title": "Classes and Objects",
    "section": "Overloading",
    "text": "Overloading\n\nConstructors may be overloaded\n\nRemember that there are consequences for default constructor\n\nMethods may be overloaded\nDestructors may NOT be overloaded"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#pointers-to-objects",
    "href": "content/19_Classes_and_Objects.html#pointers-to-objects",
    "title": "Classes and Objects",
    "section": "Pointers to Objects",
    "text": "Pointers to Objects\n\nUses same pointer notation\n“dot-notation” becomes “arrow-notation”:\nArrow operator ( -&gt; )\nDynamic allocation of objects is possible"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#uniform-initialization-syntax",
    "href": "content/19_Classes_and_Objects.html#uniform-initialization-syntax",
    "title": "Classes and Objects",
    "section": "Uniform Initialization Syntax",
    "text": "Uniform Initialization Syntax\n\n\n\nAdded in C++11\nAllows initialization of all types of variables with the same syntax.\nThe “old” syntax for each type still works, but consider using uniform syntax.\n\nSyntax:\nvariableType  variableName{argument1, argument2};\n\n\nExample:\nint       age{23};\nRectangle classroom{24, 30};\n// The following is an array - we will talk more about these soon:\ndouble    temperatures[]{78.8, 80.2, 92.4, 87.5, 95.3, 95.1, 92.8};"
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#other-details",
    "href": "content/19_Classes_and_Objects.html#other-details",
    "title": "Classes and Objects",
    "section": "Other Details",
    "text": "Other Details\n\nTiming of constructors, destructors\nArrays of objects\n\nRequires default constructor …\n… unless initialization syntax is used.\n\nMay provide arguments only or constructor invocations."
  },
  {
    "objectID": "content/19_Classes_and_Objects.html#const-methods",
    "href": "content/19_Classes_and_Objects.html#const-methods",
    "title": "Classes and Objects",
    "section": "const methods",
    "text": "const methods\n\nIn classes / structures, a method can “promise” not to modify the state of the object.\n\nmeaning, values of attributes will not be modified\n\naccomplished by marking methods as const:\n\nclass Rectangle{\npublic:\n    int get_length() const;  // const method\n    //[... other code not shown ...]\nprivate:\n    int length = 0;\n    int width  = 0;\n};\nget_length() cannot modify the attributes (length and width).\n\nThis protection is often added to accessors, and should be added whenever possible.\n\nMutators cannot be const methods, since they need to change the state of the object.\n\n\n\n\n\nCS 50x2 Accelerated Programming Series\n\n\n\n\n\n\n \n\n\nClasses and Objects"
  }
]