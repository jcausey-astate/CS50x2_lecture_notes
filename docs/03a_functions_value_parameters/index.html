<!DOCTYPE html>
<html>
<head>
	<title></title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link rel="icon" type="image/vnd.microsoft.icon" sizes="32x32" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/favicon.ico">
	<link rel="stylesheet" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/css/remark.css" />
	<link rel="stylesheet" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/css/prog-courses.css" />

</head>


<body>
    <textarea id="source" class="three-col">


# Functions and Value Parameters
## Gaddis (Ch. 6)

---

## Modular Programming

* **_Modular programming_** refers to the practice of designing a program so that it is broken up into small, manageable pieces called _functions_ or _modules_.

* In C&#43;&#43;, a _function_ is a collection of related statements that perform a single logical task.  

* In Object-Oriented programming, a function may also be referred to as a _method_.  For example, in `cin.ignore()`, the `ignore()` function is actually a method owned by the `cin` object.

---

## Motivation

* Modular programs are easier to read and understand.
    - Each logical step has its own function definition that is easily examined separately from other code.
* Modular programs are easier to maintain.
    - Changing an algorithm to fix or improve it involves simply re-writing the function where it is implemented.
* Modular programs promote code re-use.
    - It is much easier to re-use a neatly packaged function than to try to find all the code in a monolithic program that performs a particular action.

---

## Calls and Definitions

* A **_function call_** is an expression that causes a function to be executed.
    - Ex:  `pow(3, 6)`
    - Function calls may or may not evaluate to a _result_.  If it does, this result is referred to as a _return value_.
    
* A **_function definition_** is the code that defines the actions taken by the function when it is called.
    - The `main()` function we have been writing is an example.

---

## Types of Functions

Functions can be generally divided into two categories:

* **_Fruitful functions_** (or _value-producing functions_) are functions whose purpose is to compute and return a value.
    - Mathematical functions are the best example of this.
    
* **_Non-fruitful functions_** (or _void functions_) are functions that do not directly return any result.
    - These functions usually produce some useful side-effect.
    - An example would be the `close()` method of a file stream.
    - Some languages (and so some programmers) refer to these as _procedures_.

---

## Calling a Function

* Any statement can contain a function call.
    * Non-fruitful functions are often called as a stand-alone statement.
    * Fruitful functions are usually called as part of a larger expression.
* Any function can call any other function (including itself).
* Like a variable, a function must be &#34;declared&#34; before it is first called.  The compiler must know:
    - function name
    - return type
    - number and type of parameters required

---

## Defining a function
The function definition must define the function&#39;s _interface_, as well as the statements that must be executed to perform the function&#39;s action.
* The **_function header_** defines the function&#39;s interface.
    - name, return type, list of parameters
* The **_function body_** is the block of statements that are executed when the function is called.

---

**Example (non-fruitful)**

``` cpp
void greeting( std::string name ){
    std::cout &lt;&lt; &#34;Hello, &#34; &lt;&lt; name &lt;&lt; &#34;!\n&#34;;
}
```
The _function header_ is the first line of the function definition:   
`void greeting( std::string name )`  
It defines the function&#39;s

* _name_ (`greeting`)   
* _return type_ (`void`, meaning &#34;none&#34;)   
* _parameter list_ (`std::string name`)

---

**Example (fruitful)**

``` cpp
int read_age(){
    int age;
    std::cout &lt;&lt; &#34;Enter your age: &#34;;
    std::cin  &gt;&gt; age;
    return age;
}
```
This function&#39;s name is `read_age`, it returns an integer value, and its parameter list is _empty_, meaning it requires no arguments when it is called.

---

## Formal and Actual Parameters

* **_Formal parameters_** (or **_parameters_**): The temporary placeholders declared in the function header used to receive data provided by the caller.
* **_Actual parameters_** (or **_arguments_**): The data values that are actually passed to the function during a call.

&lt;br /&gt;
&lt;small&gt;&lt;i&gt;Unfortunately, the terms &#34;parameter&#34; and &#34;argument&#34; are often used nearly interchangeably in conversation.  This can lead to confusion.  Please take care to make a distinction between the two.&lt;/i&gt;&lt;/small&gt;

---

**Example (with &lt;tt&gt;main()&lt;/tt&gt;)**

``` cpp
void greeting( std::string name ){              // [2]
    std::cout &lt;&lt; &#34;Hello, &#34; &lt;&lt; name &lt;&lt; &#34;!\n&#34;;
}

int main(){
    std::string player_1 = &#34;Kevin&#34;;             

    greeting( player_1 );                       // [1]

    return 0;
}
```
[1]:  `player_1` is the _actual parameter_ in the call.

[2]: `name` is the _formal parameter_ in the function header.

---

## Data Flow: Pass by Value

* In _pass by value_, the _value_ of the actual parameter is **_copied_** into the formal parameter.
* Pass by value is the default method by which data is moved into a function for _primitive types_, _structured types_ and _object types_.
    - Changes to the formal parameter _cannot_ affect the actual parameter.

---

**Kinds of Data**

* _primitive type_ (or _built-in type_): a built-in data type provided directly by the language.  Ex: `int`, `double`, `bool`, `char`.
* _structured type_: an instance of a C&#43;&#43; _struct_, which groups multiple individual data values into a single unit of storage. Ex: `time_t`
* _object type_: an instance of a C&#43;&#43; _class_, providing not only data storage but also methods that can be applied to that data.  Example: `std::string`
* _reference type_: types that refer to their data by starting address, not by directly &#34;labeling&#34; a unit of storage.  Ex: C&#43;&#43; arrays

---

## Returning Values from a Function

Fruitful functions producing a value by means of a _`return` statement_ in the function definition.

* Must define the type of the return value in the function header.
* The value returned must match the type specified in the header.
* When called, the function call is &#34;replaced&#34; by the value that is returned.

---

## Scope

A function is a like a sealed box.  The only way &#34;in&#34; is through the parameter list or global scope.  The only direct way &#34;out&#34; is through a `return`.

* Formal parameters are locally-scoped within the function definition.
* Variables declared in a function will be locally-scoped within the function definition.
* Global variables declared before a function definition will be available in the function definition.

---

## `static` Local Variables

A `static` variable displays a hybrid of local and global behavior.  It is used to maintain _state_ between calls.

``` cpp
void foo(){
    static int count = 1;
    std::cout &lt;&lt; &#34;Call # &#34; &lt;&lt; count &lt;&lt; &#34;\n&#34;;
    count&#43;&#43;;
}
```
* The _identifier_ is governed by local scoping rules
* The _value_ is governed by global scoping rules (it doesn&#39;t go away between calls).
    - Provides &#34;sticky&#34; values that are &#34;remembered&#34; between calls.

---

**Example (`static`)**

``` cpp
void foo(){
    static int count = 1;
    std::cout &lt;&lt; &#34;Call # &#34; &lt;&lt; count &lt;&lt; &#34;\n&#34;;
    count&#43;&#43;;
}

int main(){
    foo();      // &#34;Call # 1&#34;
    foo();      // &#34;Call # 2&#34;
    foo();      // &#34;Call # 3&#34;
    foo();      // &#34;Call # 4&#34;
}
```

---

## Function Prototypes

We would prefer to _define_ the `main()` function first... But the compiler requires that all other function interfaces be specified before they can be called.

* **_function prototype_**: A declaration statement for a function, providing the function&#39;s interface but not a body.
* Placed at the top of a program so that the function definition can be placed after `main()`, in any order.

---

**Example**

``` cpp
void greeting( std::string name );  // prototype

int main(){
    greeting( &#34;Elizabeth&#34; );        // call
    return 0;
}

void greeting( std::string name ){  // definition
    std::cout &lt;&lt; &#34;Hello, &#34; &lt;&lt; name &lt;&lt; &#34;!\n&#34;;
}
```

---

## Default Parameters

Often a parameter will always be set to a common value; in these cases, a _default value_ can be specified for the parameter.  Doing so makes the parameter _optional_ when calling the function.

* Default parameters are specified in the function prototype (if used) or header by using initialization syntax:
``` cpp
double divide( double dividend, double divisor = 2.0 );
```
* If the actual parameter corresponding to the default parameter is omitted, the default value (2.0 in this case) will be used.

---

## Default Parameter Notes

* Defaults are placed in the function prototype if it is used (and _not_ in the header).
    - Place a default value in the header _only_ if no prototype is being used.
* Order is important!  
    - Once you give one parameter a default, all parameters to its right must also have defaults.
    - In a call, once you omit an argument, you must also omit all arguments to its right.

---

**Example**
``` cpp
double divide( double dividend, double divisor = 2.0 );

int main(){
    std::cout &lt;&lt; divide(3.0, 4.0) &lt;&lt; &#34;\n&#34;; // prints 0.75
    std::cout &lt;&lt; divide(3.0)      &lt;&lt; &#34;\n&#34;; // prints 1.5
    return 0;
}

double divide( double dividend, double divisor ){
    return dividend / divisor;
}
```

---

## Documentation

All function definitions require documentation headers describing the function, its parameters, and return value.  See course Grading Guidelines.

``` cpp
/**
 * Divide `dividend` by `divisor` and return the result.
 * @param   dividend    Dividend for the division 
 * @param   divisor     Divisor for the division 
 *                      (defaults to 2.0)
 * @return  The result of `dividend` / `divisor` is returned.
 */
double divide( double dividend, double divisor ){
    return dividend / divisor;
}
```

---

## Stubs and Drivers

* No need to define full functionality immediately.
    - Compile Early, Compile Often
* Function body only needs an appropriate `return` statement.
    - The rest can be left &#34;empty&#34; until later.
* **_function stub_**: an empty function used for incremental development.
* **_driver_**: a function used only for testing other functions by calling them.


</textarea>
    <script src="https://jcausey-astate.github.io/CS50x2_lecture_notes/js/remark-latest.min.js"></script>
<script src="https://jcausey-astate.github.io/CS50x2_lecture_notes/js/remark-macros.js"></script>
<script src='https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML' type="text/javascript"></script>
<script>
	var slideshow = remark.create();

	
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [['$', '$'], ['\\(', '\\)']],
			skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
		}
	});
	MathJax.Hub.Queue(function () {
		$(MathJax.Hub.getAllJax()).map(function (index, elem) {
			return (elem.SourceElement());
		}).parent().addClass('has-jax');
	});

	MathJax.Hub.Configured();
</script>
</body>

</html>