<!DOCTYPE html>
<html>
<head>
	<title></title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link rel="icon" type="image/vnd.microsoft.icon" sizes="32x32" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/favicon.ico">
	<link rel="stylesheet" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/css/remark.css" />
	<link rel="stylesheet" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/css/slides-additional.css" />
	<link rel="stylesheet" href="https://jcausey-astate.github.io/CS50x2_lecture_notes/css/prog-courses.css" />
    <base target="_blank" />
</head>


<body>
    <textarea id="source" class="three-col">


# Templates and Generic Programming

## Gaddis Ch. 16, 19

---

## Function Templates

Function templates provide a pattern for a function that can work with many types of data.

* When written, the data type specifiers are replaced with type parameters.
* When called, the compiler generates a function with actual data types that match those provided in the call.

**Example**

```cpp
template&lt;typename Numeric&gt;
Numeric times10(Numeric num){
     return 10 * num;
}
```

`Numeric` is the _type parameter_ (it can be any valid identifier, but is usually capitalized (`UpperCamelCase` or sometimes `ALL_CAPS`) by convention.

---

```cpp
template&lt;typename Numeric&gt;
Numeric times10(Numeric num){
     return 10 * num;
}
```

`Numeric` is the _type parameter_ (it can be any valid identifier, but is usually capitalized (`UpperCamelCase` or sometimes `ALL_CAPS`) by convention.

&lt;i&gt;&lt;b&gt;Tip&lt;/b&gt;:  Write the function for a normal data type first, then convert to a function template!&lt;/i&gt;

---

## Function Template Notes

* Multiple type parameters can be defined.
    - All type parameters specified in template prefix must be used in the definition.
* Function templates can be overloaded (as long as each overload has a unique signature).

---

**Multiple type parameters can be defined.**

```cpp
template&lt;typename Type1, typename Type2&gt;
void print_pair(const Type1&amp; v1, const Type2&amp; v2){
    std::cout &lt;&lt; &#39;(&#39; &lt;&lt; v1 &lt;&lt; &#34;, &#34; &lt;&lt; v2 &lt;&lt; &#39;)&#39;;
}
```

**All type parameters specified in template prefix must be used in the definition.**

---

**Function templates can be overloaded (as long as each overload has a unique signature).**

```cpp
template&lt;typename ValueType&gt;
void add(ValueType v1, ValueType v2);

template&lt;typename ValueType&gt;
void add(ValueType v1, ValueType v2, ValueType v3);
```

---

## Function Template Notes

* A function template is just a pattern:  No actual code is generated until the function is called.
    - A function template uses no memory.

* When passing objects to a function template, the object must be able to _behave_ in the way expected by the function.
    - If the function is expecting a number, your object must be able to _behave_ like a number.
    - You can determine the requirements by examining _operators_ and _operations_ performed on the parameters.
    - Be sure to document these requirements in your function documentation!

---

## Class Templates

C&#43;&#43; _class templates_ are used to create _generic classes_ and _abstract data types_.

* Often used for &#34;container types&#34;.
    - Allows writing a container once, re-using it for many types.
* Type arguments are provided when an object of the class template type is created.

---

**Example**
```cpp
template&lt;typename GradeType&gt;
class Grade{
    public:
        Grade(const GradeType&amp;);
        void      setGrade(const GradeType&amp;);
        GradeType getGrade() const;
    private:
        GradeType  grade;
};
```

---

**Example (implementation)**
```cpp
template&lt;typename GradeType&gt;
Grade&lt;GradeType&gt;::Grade(const GradeType&amp; newgrade) {
    grade = newgrade;
}
template&lt;typename GradeType&gt;
void Grade&lt;GradeType&gt;::setGrade(const GradeType&amp; newgrade) {
    grade = newgrade;
}
template&lt;typename GradeType&gt;
GradeType Grade&lt;GradeType&gt;::getGrade() const {
    return grade;
}
```


---

## Class Template Notes

* All references to the class as a type must include the type argument list.
    - When declaring/instantiating objects
    - Whenever scope resolution is required.

---

## Implementation Note

Template libraries (classes, functions, methods) should be implemented in the header file.  We do not split into _.h_/_.cpp_ pairs as we would with non-template code.

This is the result of the fact that template code does not directly compile to any object representation.

Remember that templates provide a _pattern_ from which the compiler will generate the actual &#34;code&#34; and produce an object representation automatically.

---

## Example

A linked list node just joins a &#34;payload&#34; value to a pointer to the next node...  We don&#39;t really care about what _type_ the payload is...

```cpp
// This node only holds integers...
class Node{
public:
    Node(int v);
    int   get_value() const;
    Node* get_next () const;
    void  set_next(Node* n);
private:
    int   payload;
    Node* next = nullptr;
};
```

---

```cpp
// This node only holds integers...
class Node{
public:
    Node(int v);
    int   get_value() const;
    Node* get_next () const;
    void  set_next(Node* n);
private:
    int   payload;
    Node* next = nullptr;
};
```

We can take this implementation and make it generic by introducing a template parameter to represent the type of the payload...

---

We can take this implementation and make it generic by introducing a template parameter to represent the type of the payload...

```cpp
*template &lt;typename PayloadType&gt;
class Node{
```

---

Now, we _carefully_ replace any reference to the _type_ that was associated with the payload with the parameterized `PayloadType`.  That means we will be replacing `int` with `PayloadType` whenever the `int` referred to the type of the payload (beware of loop counters, etc.).

```cpp
template &lt;typename PayloadType&gt;
class Node{
public:
    Node(`int` v);
    `int`   get_value() const;
    Node* get_next () const;
    void  set_next(Node* n);
private:
    `int`   payload;
    Node* next = nullptr;
};
```

---

Now, we _carefully_ replace any reference to the _type_ that was associated with the payload with the parameterized `PayloadType`.  That means we will be replacing `int` with `PayloadType` whenever the `int` referred to the type of the payload (beware of loop counters, etc.).

```cpp
template &lt;typename PayloadType&gt;
class Node{
public:
    Node(`PayloadType` v);
    `PayloadType` get_value() const;
    Node*       get_next()  const;
    void        set_next(Node* n);
private:
    `PayloadType` payload;
    Node*       next = nullptr;
};
```

---

```cpp
template &lt;typename PayloadType&gt;
class Node{
public:
    Node(PayloadType v);
    PayloadType get_value() const;
    `Node`*       get_next()  const;
    void        set_next(`Node`* n);
private:
    PayloadType payload;
    `Node`*       next = nullptr;
};
```

Next, we replace any instance of the class name `Node` that is being used as a typename, so that we add the template parameterization list to it...

---

```cpp
template &lt;typename PayloadType&gt;
class Node{
public:
    Node(PayloadType v);
    PayloadType        get_value() const;
    `Node&lt;PayloadType&gt;`* get_next()  const;
    void               set_next(`Node&lt;PayloadType&gt;`* n);
private:
    PayloadType        payload;
    `Node&lt;PayloadType&gt;`* next = nullptr;
};
```

Now, we have a fully templated class definition.

---

```cpp
template &lt;typename PayloadType&gt;
class Node{
public:
    Node(PayloadType v);
    PayloadType        get_value() const;
    Node&lt;PayloadType&gt;* get_next()  const;
    void               set_next(Node&lt;PayloadType&gt;* n);
private:
    PayloadType        payload;
    Node&lt;PayloadType&gt;* next = nullptr;
};
```

Here are two example method implementations:

```cpp
template &lt;typename PayloadType&gt;
Node&lt;PayloadType&gt;* Node&lt;PayloadType&gt;::get_next() const{
    return next;
}

template &lt;typename PayloadType&gt;
void Node&lt;PayloadType&gt;::set_next(Node&lt;PayloadType&gt;* n){
    next = n;
}
```

</textarea>
    <script src="https://jcausey-astate.github.io/CS50x2_lecture_notes/js/remark-latest.min.js"></script>
<script src="https://jcausey-astate.github.io/CS50x2_lecture_notes/js/remark-macros.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js"></script>
<script>
	var slideshow = remark.create({
		highlightStyle: "github",
		highlightLines: true,
  		highlightSpans: true
	});

	
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [['$', '$'], ['\\(', '\\)']],
			skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
		}
	});
	MathJax.Hub.Queue(function () {
		$(MathJax.Hub.getAllJax()).map(function (index, elem) {
			return (elem.SourceElement());
		}).parent().addClass('has-jax');
	});

	MathJax.Hub.Configured();
</script>
</body>

</html>